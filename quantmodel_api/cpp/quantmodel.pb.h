// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: quantmodel.proto

#ifndef PROTOBUF_quantmodel_2eproto__INCLUDED
#define PROTOBUF_quantmodel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace quantmodel {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_quantmodel_2eproto();
void protobuf_AssignDesc_quantmodel_2eproto();
void protobuf_ShutdownFile_quantmodel_2eproto();

class FixMarketData;
class CMEMarketData;
class FastEngineBroadcast;
class FixEngineBroadcast;
class MarketDataPriceData;
class MarketDataTradeData;
class MarketDataQuoteData;
class MarketDataBroadcast;
class HeartbeatData;
class FixEngineData;
class SystemParameterData;
class PositionOvernightData;
class AccountLimitData;
class DraftOrderData;
class DraftAllocationData;
class AccountData;
class OrderData;
class AllocationData;
class ReleaseData;
class ExecutionData;
class InstrumentData;
class SignalData;
class InvestmentSystemData;
class StrategyData;
class AccountStrategyData;
class ExecutionReportData;
class DraftOrderMessage;
class OrderMessage;
class DatabaseEngineRequest;
class DatabaseEngineRequest_Query;
class DatabaseEngineResponse;
class DatabaseEngineResponse_ResultSet;
class DatabaseEngineResponse_ResultSet_Row;
class DatabaseEngineResponse_ResultSet_Row_Column;
class DealingEngineRequest;
class DealingEngineResponse;
class DealingEngineBroadcast;
class FixEngineRequest;
class FixEngineResponse;
class ClientAdapterRequest;
class ClientAdapterResponse;
class ClientAdapterBroadcast;
class InvestmentSystemRequest;
class InvestmentSystemResponse;
class InvestmentSystemBroadcast;

enum FixMarketData_EntryType {
  FixMarketData_EntryType_BID = 1,
  FixMarketData_EntryType_ASK = 2,
  FixMarketData_EntryType_TRADE = 3,
  FixMarketData_EntryType_UNKNOWN = 4
};
bool FixMarketData_EntryType_IsValid(int value);
const FixMarketData_EntryType FixMarketData_EntryType_EntryType_MIN = FixMarketData_EntryType_BID;
const FixMarketData_EntryType FixMarketData_EntryType_EntryType_MAX = FixMarketData_EntryType_UNKNOWN;
const int FixMarketData_EntryType_EntryType_ARRAYSIZE = FixMarketData_EntryType_EntryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FixMarketData_EntryType_descriptor();
inline const ::std::string& FixMarketData_EntryType_Name(FixMarketData_EntryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FixMarketData_EntryType_descriptor(), value);
}
inline bool FixMarketData_EntryType_Parse(
    const ::std::string& name, FixMarketData_EntryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FixMarketData_EntryType>(
    FixMarketData_EntryType_descriptor(), name, value);
}
enum CMEMarketData_EntryType {
  CMEMarketData_EntryType_BID = 0,
  CMEMarketData_EntryType_ASK = 1,
  CMEMarketData_EntryType_TRADE = 2,
  CMEMarketData_EntryType_OPENING_PRICE = 4,
  CMEMarketData_EntryType_SETTLEMENT_PRICE = 6,
  CMEMarketData_EntryType_TRADING_SESSION_HIGH_PRICE = 7,
  CMEMarketData_EntryType_TRADING_SESSION_LOW_PRICE = 8,
  CMEMarketData_EntryType_TRADE_VOLUME = 9,
  CMEMarketData_EntryType_OPEN_INTEREST = 10,
  CMEMarketData_EntryType_SIMULATED_SELL = 11,
  CMEMarketData_EntryType_SIMULATED_BUY = 12,
  CMEMarketData_EntryType_EMPTY_BOOK = 13,
  CMEMarketData_EntryType_PRIOR = 14,
  CMEMarketData_EntryType_SESSION_HIGH_BID = 15,
  CMEMarketData_EntryType_SESSION_LOW_OFFER = 16,
  CMEMarketData_EntryType_FIXING_PRICE = 17,
  CMEMarketData_EntryType_CASH_NOTE = 18
};
bool CMEMarketData_EntryType_IsValid(int value);
const CMEMarketData_EntryType CMEMarketData_EntryType_EntryType_MIN = CMEMarketData_EntryType_BID;
const CMEMarketData_EntryType CMEMarketData_EntryType_EntryType_MAX = CMEMarketData_EntryType_CASH_NOTE;
const int CMEMarketData_EntryType_EntryType_ARRAYSIZE = CMEMarketData_EntryType_EntryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMEMarketData_EntryType_descriptor();
inline const ::std::string& CMEMarketData_EntryType_Name(CMEMarketData_EntryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMEMarketData_EntryType_descriptor(), value);
}
inline bool CMEMarketData_EntryType_Parse(
    const ::std::string& name, CMEMarketData_EntryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMEMarketData_EntryType>(
    CMEMarketData_EntryType_descriptor(), name, value);
}
enum CMEMarketData_UpdateAction {
  CMEMarketData_UpdateAction_ADD = 0,
  CMEMarketData_UpdateAction_CHANGE = 1,
  CMEMarketData_UpdateAction_DELETE = 2,
  CMEMarketData_UpdateAction_OVERLAY = 5
};
bool CMEMarketData_UpdateAction_IsValid(int value);
const CMEMarketData_UpdateAction CMEMarketData_UpdateAction_UpdateAction_MIN = CMEMarketData_UpdateAction_ADD;
const CMEMarketData_UpdateAction CMEMarketData_UpdateAction_UpdateAction_MAX = CMEMarketData_UpdateAction_OVERLAY;
const int CMEMarketData_UpdateAction_UpdateAction_ARRAYSIZE = CMEMarketData_UpdateAction_UpdateAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMEMarketData_UpdateAction_descriptor();
inline const ::std::string& CMEMarketData_UpdateAction_Name(CMEMarketData_UpdateAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMEMarketData_UpdateAction_descriptor(), value);
}
inline bool CMEMarketData_UpdateAction_Parse(
    const ::std::string& name, CMEMarketData_UpdateAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMEMarketData_UpdateAction>(
    CMEMarketData_UpdateAction_descriptor(), name, value);
}
enum CMEMarketData_AggressorType {
  CMEMarketData_AggressorType_UNKNOWN = 0,
  CMEMarketData_AggressorType_BUY = 1,
  CMEMarketData_AggressorType_SELL = 2
};
bool CMEMarketData_AggressorType_IsValid(int value);
const CMEMarketData_AggressorType CMEMarketData_AggressorType_AggressorType_MIN = CMEMarketData_AggressorType_UNKNOWN;
const CMEMarketData_AggressorType CMEMarketData_AggressorType_AggressorType_MAX = CMEMarketData_AggressorType_SELL;
const int CMEMarketData_AggressorType_AggressorType_ARRAYSIZE = CMEMarketData_AggressorType_AggressorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMEMarketData_AggressorType_descriptor();
inline const ::std::string& CMEMarketData_AggressorType_Name(CMEMarketData_AggressorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMEMarketData_AggressorType_descriptor(), value);
}
inline bool CMEMarketData_AggressorType_Parse(
    const ::std::string& name, CMEMarketData_AggressorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMEMarketData_AggressorType>(
    CMEMarketData_AggressorType_descriptor(), name, value);
}
enum FastEngineBroadcast_BroadcastType {
  FastEngineBroadcast_BroadcastType_CME = 1,
  FastEngineBroadcast_BroadcastType_ICE = 2,
  FastEngineBroadcast_BroadcastType_CBOE = 3
};
bool FastEngineBroadcast_BroadcastType_IsValid(int value);
const FastEngineBroadcast_BroadcastType FastEngineBroadcast_BroadcastType_BroadcastType_MIN = FastEngineBroadcast_BroadcastType_CME;
const FastEngineBroadcast_BroadcastType FastEngineBroadcast_BroadcastType_BroadcastType_MAX = FastEngineBroadcast_BroadcastType_CBOE;
const int FastEngineBroadcast_BroadcastType_BroadcastType_ARRAYSIZE = FastEngineBroadcast_BroadcastType_BroadcastType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FastEngineBroadcast_BroadcastType_descriptor();
inline const ::std::string& FastEngineBroadcast_BroadcastType_Name(FastEngineBroadcast_BroadcastType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FastEngineBroadcast_BroadcastType_descriptor(), value);
}
inline bool FastEngineBroadcast_BroadcastType_Parse(
    const ::std::string& name, FastEngineBroadcast_BroadcastType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FastEngineBroadcast_BroadcastType>(
    FastEngineBroadcast_BroadcastType_descriptor(), name, value);
}
enum MarketDataTradeData_AggressorType {
  MarketDataTradeData_AggressorType_UNKNOWN = 0,
  MarketDataTradeData_AggressorType_BUY = 1,
  MarketDataTradeData_AggressorType_SELL = 2
};
bool MarketDataTradeData_AggressorType_IsValid(int value);
const MarketDataTradeData_AggressorType MarketDataTradeData_AggressorType_AggressorType_MIN = MarketDataTradeData_AggressorType_UNKNOWN;
const MarketDataTradeData_AggressorType MarketDataTradeData_AggressorType_AggressorType_MAX = MarketDataTradeData_AggressorType_SELL;
const int MarketDataTradeData_AggressorType_AggressorType_ARRAYSIZE = MarketDataTradeData_AggressorType_AggressorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MarketDataTradeData_AggressorType_descriptor();
inline const ::std::string& MarketDataTradeData_AggressorType_Name(MarketDataTradeData_AggressorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MarketDataTradeData_AggressorType_descriptor(), value);
}
inline bool MarketDataTradeData_AggressorType_Parse(
    const ::std::string& name, MarketDataTradeData_AggressorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarketDataTradeData_AggressorType>(
    MarketDataTradeData_AggressorType_descriptor(), name, value);
}
enum MarketDataQuoteData_QuoteType {
  MarketDataQuoteData_QuoteType_BID = 1,
  MarketDataQuoteData_QuoteType_ASK = 2
};
bool MarketDataQuoteData_QuoteType_IsValid(int value);
const MarketDataQuoteData_QuoteType MarketDataQuoteData_QuoteType_QuoteType_MIN = MarketDataQuoteData_QuoteType_BID;
const MarketDataQuoteData_QuoteType MarketDataQuoteData_QuoteType_QuoteType_MAX = MarketDataQuoteData_QuoteType_ASK;
const int MarketDataQuoteData_QuoteType_QuoteType_ARRAYSIZE = MarketDataQuoteData_QuoteType_QuoteType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MarketDataQuoteData_QuoteType_descriptor();
inline const ::std::string& MarketDataQuoteData_QuoteType_Name(MarketDataQuoteData_QuoteType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MarketDataQuoteData_QuoteType_descriptor(), value);
}
inline bool MarketDataQuoteData_QuoteType_Parse(
    const ::std::string& name, MarketDataQuoteData_QuoteType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarketDataQuoteData_QuoteType>(
    MarketDataQuoteData_QuoteType_descriptor(), name, value);
}
enum MarketDataBroadcast_BroadcastType {
  MarketDataBroadcast_BroadcastType_PRICE = 1,
  MarketDataBroadcast_BroadcastType_TRADE = 2,
  MarketDataBroadcast_BroadcastType_QUOTE = 3
};
bool MarketDataBroadcast_BroadcastType_IsValid(int value);
const MarketDataBroadcast_BroadcastType MarketDataBroadcast_BroadcastType_BroadcastType_MIN = MarketDataBroadcast_BroadcastType_PRICE;
const MarketDataBroadcast_BroadcastType MarketDataBroadcast_BroadcastType_BroadcastType_MAX = MarketDataBroadcast_BroadcastType_QUOTE;
const int MarketDataBroadcast_BroadcastType_BroadcastType_ARRAYSIZE = MarketDataBroadcast_BroadcastType_BroadcastType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MarketDataBroadcast_BroadcastType_descriptor();
inline const ::std::string& MarketDataBroadcast_BroadcastType_Name(MarketDataBroadcast_BroadcastType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MarketDataBroadcast_BroadcastType_descriptor(), value);
}
inline bool MarketDataBroadcast_BroadcastType_Parse(
    const ::std::string& name, MarketDataBroadcast_BroadcastType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarketDataBroadcast_BroadcastType>(
    MarketDataBroadcast_BroadcastType_descriptor(), name, value);
}
enum PositionOvernightData_PositionType {
  PositionOvernightData_PositionType_CLOSED = 0,
  PositionOvernightData_PositionType_LONG = 1,
  PositionOvernightData_PositionType_SHORT = 2
};
bool PositionOvernightData_PositionType_IsValid(int value);
const PositionOvernightData_PositionType PositionOvernightData_PositionType_PositionType_MIN = PositionOvernightData_PositionType_CLOSED;
const PositionOvernightData_PositionType PositionOvernightData_PositionType_PositionType_MAX = PositionOvernightData_PositionType_SHORT;
const int PositionOvernightData_PositionType_PositionType_ARRAYSIZE = PositionOvernightData_PositionType_PositionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PositionOvernightData_PositionType_descriptor();
inline const ::std::string& PositionOvernightData_PositionType_Name(PositionOvernightData_PositionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PositionOvernightData_PositionType_descriptor(), value);
}
inline bool PositionOvernightData_PositionType_Parse(
    const ::std::string& name, PositionOvernightData_PositionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PositionOvernightData_PositionType>(
    PositionOvernightData_PositionType_descriptor(), name, value);
}
enum DraftOrderData_SideCode {
  DraftOrderData_SideCode_BUY = 1,
  DraftOrderData_SideCode_SELL = 2
};
bool DraftOrderData_SideCode_IsValid(int value);
const DraftOrderData_SideCode DraftOrderData_SideCode_SideCode_MIN = DraftOrderData_SideCode_BUY;
const DraftOrderData_SideCode DraftOrderData_SideCode_SideCode_MAX = DraftOrderData_SideCode_SELL;
const int DraftOrderData_SideCode_SideCode_ARRAYSIZE = DraftOrderData_SideCode_SideCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* DraftOrderData_SideCode_descriptor();
inline const ::std::string& DraftOrderData_SideCode_Name(DraftOrderData_SideCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    DraftOrderData_SideCode_descriptor(), value);
}
inline bool DraftOrderData_SideCode_Parse(
    const ::std::string& name, DraftOrderData_SideCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DraftOrderData_SideCode>(
    DraftOrderData_SideCode_descriptor(), name, value);
}
enum DraftOrderData_OrderType {
  DraftOrderData_OrderType_MARKET = 1,
  DraftOrderData_OrderType_LIMIT = 2,
  DraftOrderData_OrderType_STOP = 3,
  DraftOrderData_OrderType_STOP_LIMIT = 4,
  DraftOrderData_OrderType_MARKET_ON_CLOSE = 5,
  DraftOrderData_OrderType_MARKET_LIMIT = 6
};
bool DraftOrderData_OrderType_IsValid(int value);
const DraftOrderData_OrderType DraftOrderData_OrderType_OrderType_MIN = DraftOrderData_OrderType_MARKET;
const DraftOrderData_OrderType DraftOrderData_OrderType_OrderType_MAX = DraftOrderData_OrderType_MARKET_LIMIT;
const int DraftOrderData_OrderType_OrderType_ARRAYSIZE = DraftOrderData_OrderType_OrderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DraftOrderData_OrderType_descriptor();
inline const ::std::string& DraftOrderData_OrderType_Name(DraftOrderData_OrderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DraftOrderData_OrderType_descriptor(), value);
}
inline bool DraftOrderData_OrderType_Parse(
    const ::std::string& name, DraftOrderData_OrderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DraftOrderData_OrderType>(
    DraftOrderData_OrderType_descriptor(), name, value);
}
enum DraftOrderData_TimeInForce {
  DraftOrderData_TimeInForce_DAY = 0,
  DraftOrderData_TimeInForce_GTC = 1,
  DraftOrderData_TimeInForce_OPG = 2,
  DraftOrderData_TimeInForce_IOC = 3,
  DraftOrderData_TimeInForce_FOK = 4,
  DraftOrderData_TimeInForce_GTD = 6,
  DraftOrderData_TimeInForce_GIS = 8
};
bool DraftOrderData_TimeInForce_IsValid(int value);
const DraftOrderData_TimeInForce DraftOrderData_TimeInForce_TimeInForce_MIN = DraftOrderData_TimeInForce_DAY;
const DraftOrderData_TimeInForce DraftOrderData_TimeInForce_TimeInForce_MAX = DraftOrderData_TimeInForce_GIS;
const int DraftOrderData_TimeInForce_TimeInForce_ARRAYSIZE = DraftOrderData_TimeInForce_TimeInForce_MAX + 1;

const ::google::protobuf::EnumDescriptor* DraftOrderData_TimeInForce_descriptor();
inline const ::std::string& DraftOrderData_TimeInForce_Name(DraftOrderData_TimeInForce value) {
  return ::google::protobuf::internal::NameOfEnum(
    DraftOrderData_TimeInForce_descriptor(), value);
}
inline bool DraftOrderData_TimeInForce_Parse(
    const ::std::string& name, DraftOrderData_TimeInForce* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DraftOrderData_TimeInForce>(
    DraftOrderData_TimeInForce_descriptor(), name, value);
}
enum OrderData_SideCode {
  OrderData_SideCode_BUY = 1,
  OrderData_SideCode_SELL = 2
};
bool OrderData_SideCode_IsValid(int value);
const OrderData_SideCode OrderData_SideCode_SideCode_MIN = OrderData_SideCode_BUY;
const OrderData_SideCode OrderData_SideCode_SideCode_MAX = OrderData_SideCode_SELL;
const int OrderData_SideCode_SideCode_ARRAYSIZE = OrderData_SideCode_SideCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderData_SideCode_descriptor();
inline const ::std::string& OrderData_SideCode_Name(OrderData_SideCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderData_SideCode_descriptor(), value);
}
inline bool OrderData_SideCode_Parse(
    const ::std::string& name, OrderData_SideCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderData_SideCode>(
    OrderData_SideCode_descriptor(), name, value);
}
enum OrderData_OrderType {
  OrderData_OrderType_MARKET = 1,
  OrderData_OrderType_LIMIT = 2,
  OrderData_OrderType_STOP = 3,
  OrderData_OrderType_STOP_LIMIT = 4,
  OrderData_OrderType_MARKET_ON_CLOSE = 5,
  OrderData_OrderType_MARKET_LIMIT = 6
};
bool OrderData_OrderType_IsValid(int value);
const OrderData_OrderType OrderData_OrderType_OrderType_MIN = OrderData_OrderType_MARKET;
const OrderData_OrderType OrderData_OrderType_OrderType_MAX = OrderData_OrderType_MARKET_LIMIT;
const int OrderData_OrderType_OrderType_ARRAYSIZE = OrderData_OrderType_OrderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderData_OrderType_descriptor();
inline const ::std::string& OrderData_OrderType_Name(OrderData_OrderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderData_OrderType_descriptor(), value);
}
inline bool OrderData_OrderType_Parse(
    const ::std::string& name, OrderData_OrderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderData_OrderType>(
    OrderData_OrderType_descriptor(), name, value);
}
enum OrderData_OrderStatus {
  OrderData_OrderStatus_SUPPRESSED = 0,
  OrderData_OrderStatus_NEW = 1,
  OrderData_OrderStatus_PENDING_RELEASE = 2,
  OrderData_OrderStatus_RELEASED = 3,
  OrderData_OrderStatus_PARTIALLY_FILLED = 4,
  OrderData_OrderStatus_FILLED = 5,
  OrderData_OrderStatus_CANCELED = 6,
  OrderData_OrderStatus_CLOSED = 7
};
bool OrderData_OrderStatus_IsValid(int value);
const OrderData_OrderStatus OrderData_OrderStatus_OrderStatus_MIN = OrderData_OrderStatus_SUPPRESSED;
const OrderData_OrderStatus OrderData_OrderStatus_OrderStatus_MAX = OrderData_OrderStatus_CLOSED;
const int OrderData_OrderStatus_OrderStatus_ARRAYSIZE = OrderData_OrderStatus_OrderStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderData_OrderStatus_descriptor();
inline const ::std::string& OrderData_OrderStatus_Name(OrderData_OrderStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderData_OrderStatus_descriptor(), value);
}
inline bool OrderData_OrderStatus_Parse(
    const ::std::string& name, OrderData_OrderStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderData_OrderStatus>(
    OrderData_OrderStatus_descriptor(), name, value);
}
enum OrderData_TimeInForce {
  OrderData_TimeInForce_DAY = 0,
  OrderData_TimeInForce_GTC = 1,
  OrderData_TimeInForce_OPG = 2,
  OrderData_TimeInForce_IOC = 3,
  OrderData_TimeInForce_FOK = 4,
  OrderData_TimeInForce_GTD = 6,
  OrderData_TimeInForce_GIS = 8
};
bool OrderData_TimeInForce_IsValid(int value);
const OrderData_TimeInForce OrderData_TimeInForce_TimeInForce_MIN = OrderData_TimeInForce_DAY;
const OrderData_TimeInForce OrderData_TimeInForce_TimeInForce_MAX = OrderData_TimeInForce_GIS;
const int OrderData_TimeInForce_TimeInForce_ARRAYSIZE = OrderData_TimeInForce_TimeInForce_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderData_TimeInForce_descriptor();
inline const ::std::string& OrderData_TimeInForce_Name(OrderData_TimeInForce value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderData_TimeInForce_descriptor(), value);
}
inline bool OrderData_TimeInForce_Parse(
    const ::std::string& name, OrderData_TimeInForce* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderData_TimeInForce>(
    OrderData_TimeInForce_descriptor(), name, value);
}
enum DatabaseEngineRequest_QueryType {
  DatabaseEngineRequest_QueryType_SELECT = 1,
  DatabaseEngineRequest_QueryType_UPDATE = 2
};
bool DatabaseEngineRequest_QueryType_IsValid(int value);
const DatabaseEngineRequest_QueryType DatabaseEngineRequest_QueryType_QueryType_MIN = DatabaseEngineRequest_QueryType_SELECT;
const DatabaseEngineRequest_QueryType DatabaseEngineRequest_QueryType_QueryType_MAX = DatabaseEngineRequest_QueryType_UPDATE;
const int DatabaseEngineRequest_QueryType_QueryType_ARRAYSIZE = DatabaseEngineRequest_QueryType_QueryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DatabaseEngineRequest_QueryType_descriptor();
inline const ::std::string& DatabaseEngineRequest_QueryType_Name(DatabaseEngineRequest_QueryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DatabaseEngineRequest_QueryType_descriptor(), value);
}
inline bool DatabaseEngineRequest_QueryType_Parse(
    const ::std::string& name, DatabaseEngineRequest_QueryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseEngineRequest_QueryType>(
    DatabaseEngineRequest_QueryType_descriptor(), name, value);
}
enum DealingEngineRequest_RequestType {
  DealingEngineRequest_RequestType_EXECUTE_SIGNAL = 1,
  DealingEngineRequest_RequestType_EXECUTE_DRAFT_ORDER = 2,
  DealingEngineRequest_RequestType_CREATE_DRAFT_ORDER = 3,
  DealingEngineRequest_RequestType_CREATE_ORDER = 4,
  DealingEngineRequest_RequestType_UPDATE_ORDER = 5,
  DealingEngineRequest_RequestType_CANCEL_ORDER = 6,
  DealingEngineRequest_RequestType_RELEASE_ORDER = 7,
  DealingEngineRequest_RequestType_CREATE_RELEASE = 8,
  DealingEngineRequest_RequestType_VALIDATE_RELEASE = 9,
  DealingEngineRequest_RequestType_CANCEL_RELEASE = 10,
  DealingEngineRequest_RequestType_REPLACE_RELEASE = 11,
  DealingEngineRequest_RequestType_RELEASE_REJECTED = 12,
  DealingEngineRequest_RequestType_CANCEL_REJECTED = 13,
  DealingEngineRequest_RequestType_RELEASE_RESTATED = 14,
  DealingEngineRequest_RequestType_RELEASE_CANCELED = 15,
  DealingEngineRequest_RequestType_RELEASE_REPLACED = 16,
  DealingEngineRequest_RequestType_CREATE_EXECUTION = 17,
  DealingEngineRequest_RequestType_EXECUTION_CANCELED = 18,
  DealingEngineRequest_RequestType_BROADCAST_DATA = 19,
  DealingEngineRequest_RequestType_ACTIVE_SET = 20,
  DealingEngineRequest_RequestType_QUERY_ORDER = 21,
  DealingEngineRequest_RequestType_QUERY_RELEASE = 22,
  DealingEngineRequest_RequestType_QUERY_EXECUTION = 23,
  DealingEngineRequest_RequestType_ROLLOVER = 24,
  DealingEngineRequest_RequestType_CURRENT_STATUS = 25,
  DealingEngineRequest_RequestType_UPDATE_STATUS = 26,
  DealingEngineRequest_RequestType_MARKETDATA_SUBSCRIBE = 27,
  DealingEngineRequest_RequestType_MARKETDATA_UNSUBSCRIBE = 28,
  DealingEngineRequest_RequestType_FIXENGINE_LOGIN = 29,
  DealingEngineRequest_RequestType_FIXENGINE_LOGOUT = 30,
  DealingEngineRequest_RequestType_LOGOUT_FIXENGINE = 31,
  DealingEngineRequest_RequestType_LOGIN_FIXENGINE = 32,
  DealingEngineRequest_RequestType_RELOAD_STATIC_DATA = 33,
  DealingEngineRequest_RequestType_SHUTDOWN = 34
};
bool DealingEngineRequest_RequestType_IsValid(int value);
const DealingEngineRequest_RequestType DealingEngineRequest_RequestType_RequestType_MIN = DealingEngineRequest_RequestType_EXECUTE_SIGNAL;
const DealingEngineRequest_RequestType DealingEngineRequest_RequestType_RequestType_MAX = DealingEngineRequest_RequestType_SHUTDOWN;
const int DealingEngineRequest_RequestType_RequestType_ARRAYSIZE = DealingEngineRequest_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DealingEngineRequest_RequestType_descriptor();
inline const ::std::string& DealingEngineRequest_RequestType_Name(DealingEngineRequest_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DealingEngineRequest_RequestType_descriptor(), value);
}
inline bool DealingEngineRequest_RequestType_Parse(
    const ::std::string& name, DealingEngineRequest_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DealingEngineRequest_RequestType>(
    DealingEngineRequest_RequestType_descriptor(), name, value);
}
enum DealingEngineResponse_ResponseType {
  DealingEngineResponse_ResponseType_ACKNOWLEDGEMENT = 1,
  DealingEngineResponse_ResponseType_REJECT = 2,
  DealingEngineResponse_ResponseType_ERROR = 3
};
bool DealingEngineResponse_ResponseType_IsValid(int value);
const DealingEngineResponse_ResponseType DealingEngineResponse_ResponseType_ResponseType_MIN = DealingEngineResponse_ResponseType_ACKNOWLEDGEMENT;
const DealingEngineResponse_ResponseType DealingEngineResponse_ResponseType_ResponseType_MAX = DealingEngineResponse_ResponseType_ERROR;
const int DealingEngineResponse_ResponseType_ResponseType_ARRAYSIZE = DealingEngineResponse_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DealingEngineResponse_ResponseType_descriptor();
inline const ::std::string& DealingEngineResponse_ResponseType_Name(DealingEngineResponse_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DealingEngineResponse_ResponseType_descriptor(), value);
}
inline bool DealingEngineResponse_ResponseType_Parse(
    const ::std::string& name, DealingEngineResponse_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DealingEngineResponse_ResponseType>(
    DealingEngineResponse_ResponseType_descriptor(), name, value);
}
enum DealingEngineBroadcast_BroadcastType {
  DealingEngineBroadcast_BroadcastType_EXECUTE_SIGNAL = 1,
  DealingEngineBroadcast_BroadcastType_EXECUTE_DRAFT_ORDER = 2,
  DealingEngineBroadcast_BroadcastType_CREATE_DRAFT_ORDER = 3,
  DealingEngineBroadcast_BroadcastType_CREATE_ORDER = 4,
  DealingEngineBroadcast_BroadcastType_UPDATE_ORDER = 5,
  DealingEngineBroadcast_BroadcastType_CANCEL_ORDER = 6,
  DealingEngineBroadcast_BroadcastType_RELEASE_ORDER = 7,
  DealingEngineBroadcast_BroadcastType_CREATE_RELEASE = 8,
  DealingEngineBroadcast_BroadcastType_VALIDATE_RELEASE = 9,
  DealingEngineBroadcast_BroadcastType_CANCEL_RELEASE = 10,
  DealingEngineBroadcast_BroadcastType_REPLACE_RELEASE = 11,
  DealingEngineBroadcast_BroadcastType_RELEASE_REJECTED = 12,
  DealingEngineBroadcast_BroadcastType_CANCEL_REJECTED = 13,
  DealingEngineBroadcast_BroadcastType_RELEASE_RESTATED = 14,
  DealingEngineBroadcast_BroadcastType_RELEASE_CANCELED = 15,
  DealingEngineBroadcast_BroadcastType_RELEASE_REPLACED = 16,
  DealingEngineBroadcast_BroadcastType_CREATE_EXECUTION = 17,
  DealingEngineBroadcast_BroadcastType_EXECUTION_CANCELED = 18,
  DealingEngineBroadcast_BroadcastType_BROADCAST_DATA = 19,
  DealingEngineBroadcast_BroadcastType_ACTIVE_SET = 20,
  DealingEngineBroadcast_BroadcastType_QUERY_ORDER = 21,
  DealingEngineBroadcast_BroadcastType_QUERY_RELEASE = 22,
  DealingEngineBroadcast_BroadcastType_QUERY_EXECUTION = 23,
  DealingEngineBroadcast_BroadcastType_ROLLOVER = 24,
  DealingEngineBroadcast_BroadcastType_CURRENT_STATUS = 25,
  DealingEngineBroadcast_BroadcastType_UPDATE_STATUS = 26,
  DealingEngineBroadcast_BroadcastType_MARKETDATA_SUBSCRIBE = 27,
  DealingEngineBroadcast_BroadcastType_MARKETDATA_UNSUBSCRIBE = 28,
  DealingEngineBroadcast_BroadcastType_FIXENGINE_LOGIN = 29,
  DealingEngineBroadcast_BroadcastType_FIXENGINE_LOGOUT = 30,
  DealingEngineBroadcast_BroadcastType_LOGOUT_FIXENGINE = 31,
  DealingEngineBroadcast_BroadcastType_LOGIN_FIXENGINE = 32,
  DealingEngineBroadcast_BroadcastType_RELOAD_STATIC_DATA = 33,
  DealingEngineBroadcast_BroadcastType_SHUTDOWN = 34
};
bool DealingEngineBroadcast_BroadcastType_IsValid(int value);
const DealingEngineBroadcast_BroadcastType DealingEngineBroadcast_BroadcastType_BroadcastType_MIN = DealingEngineBroadcast_BroadcastType_EXECUTE_SIGNAL;
const DealingEngineBroadcast_BroadcastType DealingEngineBroadcast_BroadcastType_BroadcastType_MAX = DealingEngineBroadcast_BroadcastType_SHUTDOWN;
const int DealingEngineBroadcast_BroadcastType_BroadcastType_ARRAYSIZE = DealingEngineBroadcast_BroadcastType_BroadcastType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DealingEngineBroadcast_BroadcastType_descriptor();
inline const ::std::string& DealingEngineBroadcast_BroadcastType_Name(DealingEngineBroadcast_BroadcastType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DealingEngineBroadcast_BroadcastType_descriptor(), value);
}
inline bool DealingEngineBroadcast_BroadcastType_Parse(
    const ::std::string& name, DealingEngineBroadcast_BroadcastType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DealingEngineBroadcast_BroadcastType>(
    DealingEngineBroadcast_BroadcastType_descriptor(), name, value);
}
enum FixEngineRequest_RequestType {
  FixEngineRequest_RequestType_CREATE_RELEASE = 1,
  FixEngineRequest_RequestType_CANCEL_RELEASE = 2,
  FixEngineRequest_RequestType_REPLACE_RELEASE = 3,
  FixEngineRequest_RequestType_DEFINE_SECURITY = 4,
  FixEngineRequest_RequestType_MARKETDATA_SUBSCRIBE = 5,
  FixEngineRequest_RequestType_FIXENGINE_LOGOUT = 6,
  FixEngineRequest_RequestType_FIXENGINE_LOGIN = 7,
  FixEngineRequest_RequestType_SEQUENCE_RESET = 8,
  FixEngineRequest_RequestType_RESEND_REQUEST = 9,
  FixEngineRequest_RequestType_TEST_REQUEST = 10,
  FixEngineRequest_RequestType_SHUTDOWN = 11
};
bool FixEngineRequest_RequestType_IsValid(int value);
const FixEngineRequest_RequestType FixEngineRequest_RequestType_RequestType_MIN = FixEngineRequest_RequestType_CREATE_RELEASE;
const FixEngineRequest_RequestType FixEngineRequest_RequestType_RequestType_MAX = FixEngineRequest_RequestType_SHUTDOWN;
const int FixEngineRequest_RequestType_RequestType_ARRAYSIZE = FixEngineRequest_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FixEngineRequest_RequestType_descriptor();
inline const ::std::string& FixEngineRequest_RequestType_Name(FixEngineRequest_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FixEngineRequest_RequestType_descriptor(), value);
}
inline bool FixEngineRequest_RequestType_Parse(
    const ::std::string& name, FixEngineRequest_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FixEngineRequest_RequestType>(
    FixEngineRequest_RequestType_descriptor(), name, value);
}
enum FixEngineResponse_ResponseType {
  FixEngineResponse_ResponseType_ACKNOWLEDGEMENT = 1,
  FixEngineResponse_ResponseType_REJECT = 2,
  FixEngineResponse_ResponseType_ERROR = 3
};
bool FixEngineResponse_ResponseType_IsValid(int value);
const FixEngineResponse_ResponseType FixEngineResponse_ResponseType_ResponseType_MIN = FixEngineResponse_ResponseType_ACKNOWLEDGEMENT;
const FixEngineResponse_ResponseType FixEngineResponse_ResponseType_ResponseType_MAX = FixEngineResponse_ResponseType_ERROR;
const int FixEngineResponse_ResponseType_ResponseType_ARRAYSIZE = FixEngineResponse_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FixEngineResponse_ResponseType_descriptor();
inline const ::std::string& FixEngineResponse_ResponseType_Name(FixEngineResponse_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FixEngineResponse_ResponseType_descriptor(), value);
}
inline bool FixEngineResponse_ResponseType_Parse(
    const ::std::string& name, FixEngineResponse_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FixEngineResponse_ResponseType>(
    FixEngineResponse_ResponseType_descriptor(), name, value);
}
enum ClientAdapterRequest_RequestType {
  ClientAdapterRequest_RequestType_HEARTBEAT = 1,
  ClientAdapterRequest_RequestType_DATABASE = 2,
  ClientAdapterRequest_RequestType_DEALING = 3,
  ClientAdapterRequest_RequestType_SHUTDOWN = 4
};
bool ClientAdapterRequest_RequestType_IsValid(int value);
const ClientAdapterRequest_RequestType ClientAdapterRequest_RequestType_RequestType_MIN = ClientAdapterRequest_RequestType_HEARTBEAT;
const ClientAdapterRequest_RequestType ClientAdapterRequest_RequestType_RequestType_MAX = ClientAdapterRequest_RequestType_SHUTDOWN;
const int ClientAdapterRequest_RequestType_RequestType_ARRAYSIZE = ClientAdapterRequest_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientAdapterRequest_RequestType_descriptor();
inline const ::std::string& ClientAdapterRequest_RequestType_Name(ClientAdapterRequest_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientAdapterRequest_RequestType_descriptor(), value);
}
inline bool ClientAdapterRequest_RequestType_Parse(
    const ::std::string& name, ClientAdapterRequest_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientAdapterRequest_RequestType>(
    ClientAdapterRequest_RequestType_descriptor(), name, value);
}
enum ClientAdapterResponse_ResponseType {
  ClientAdapterResponse_ResponseType_ACKNOWLEDGEMENT = 1,
  ClientAdapterResponse_ResponseType_REJECT = 2,
  ClientAdapterResponse_ResponseType_ERROR = 3
};
bool ClientAdapterResponse_ResponseType_IsValid(int value);
const ClientAdapterResponse_ResponseType ClientAdapterResponse_ResponseType_ResponseType_MIN = ClientAdapterResponse_ResponseType_ACKNOWLEDGEMENT;
const ClientAdapterResponse_ResponseType ClientAdapterResponse_ResponseType_ResponseType_MAX = ClientAdapterResponse_ResponseType_ERROR;
const int ClientAdapterResponse_ResponseType_ResponseType_ARRAYSIZE = ClientAdapterResponse_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientAdapterResponse_ResponseType_descriptor();
inline const ::std::string& ClientAdapterResponse_ResponseType_Name(ClientAdapterResponse_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientAdapterResponse_ResponseType_descriptor(), value);
}
inline bool ClientAdapterResponse_ResponseType_Parse(
    const ::std::string& name, ClientAdapterResponse_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientAdapterResponse_ResponseType>(
    ClientAdapterResponse_ResponseType_descriptor(), name, value);
}
enum ClientAdapterBroadcast_BroadcastType {
  ClientAdapterBroadcast_BroadcastType_HEARTBEAT = 1,
  ClientAdapterBroadcast_BroadcastType_DATABASE = 2,
  ClientAdapterBroadcast_BroadcastType_DEALING = 3,
  ClientAdapterBroadcast_BroadcastType_MARKETDATA = 4,
  ClientAdapterBroadcast_BroadcastType_SHUTDOWN = 5
};
bool ClientAdapterBroadcast_BroadcastType_IsValid(int value);
const ClientAdapterBroadcast_BroadcastType ClientAdapterBroadcast_BroadcastType_BroadcastType_MIN = ClientAdapterBroadcast_BroadcastType_HEARTBEAT;
const ClientAdapterBroadcast_BroadcastType ClientAdapterBroadcast_BroadcastType_BroadcastType_MAX = ClientAdapterBroadcast_BroadcastType_SHUTDOWN;
const int ClientAdapterBroadcast_BroadcastType_BroadcastType_ARRAYSIZE = ClientAdapterBroadcast_BroadcastType_BroadcastType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientAdapterBroadcast_BroadcastType_descriptor();
inline const ::std::string& ClientAdapterBroadcast_BroadcastType_Name(ClientAdapterBroadcast_BroadcastType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientAdapterBroadcast_BroadcastType_descriptor(), value);
}
inline bool ClientAdapterBroadcast_BroadcastType_Parse(
    const ::std::string& name, ClientAdapterBroadcast_BroadcastType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientAdapterBroadcast_BroadcastType>(
    ClientAdapterBroadcast_BroadcastType_descriptor(), name, value);
}
enum InvestmentSystemRequest_RequestType {
  InvestmentSystemRequest_RequestType_HEARTBEAT = 1,
  InvestmentSystemRequest_RequestType_COMMAND = 2
};
bool InvestmentSystemRequest_RequestType_IsValid(int value);
const InvestmentSystemRequest_RequestType InvestmentSystemRequest_RequestType_RequestType_MIN = InvestmentSystemRequest_RequestType_HEARTBEAT;
const InvestmentSystemRequest_RequestType InvestmentSystemRequest_RequestType_RequestType_MAX = InvestmentSystemRequest_RequestType_COMMAND;
const int InvestmentSystemRequest_RequestType_RequestType_ARRAYSIZE = InvestmentSystemRequest_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InvestmentSystemRequest_RequestType_descriptor();
inline const ::std::string& InvestmentSystemRequest_RequestType_Name(InvestmentSystemRequest_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InvestmentSystemRequest_RequestType_descriptor(), value);
}
inline bool InvestmentSystemRequest_RequestType_Parse(
    const ::std::string& name, InvestmentSystemRequest_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InvestmentSystemRequest_RequestType>(
    InvestmentSystemRequest_RequestType_descriptor(), name, value);
}
enum InvestmentSystemResponse_ResponseType {
  InvestmentSystemResponse_ResponseType_ACKNOWLEDGEMENT = 1,
  InvestmentSystemResponse_ResponseType_REJECT = 2,
  InvestmentSystemResponse_ResponseType_ERROR = 3
};
bool InvestmentSystemResponse_ResponseType_IsValid(int value);
const InvestmentSystemResponse_ResponseType InvestmentSystemResponse_ResponseType_ResponseType_MIN = InvestmentSystemResponse_ResponseType_ACKNOWLEDGEMENT;
const InvestmentSystemResponse_ResponseType InvestmentSystemResponse_ResponseType_ResponseType_MAX = InvestmentSystemResponse_ResponseType_ERROR;
const int InvestmentSystemResponse_ResponseType_ResponseType_ARRAYSIZE = InvestmentSystemResponse_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InvestmentSystemResponse_ResponseType_descriptor();
inline const ::std::string& InvestmentSystemResponse_ResponseType_Name(InvestmentSystemResponse_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InvestmentSystemResponse_ResponseType_descriptor(), value);
}
inline bool InvestmentSystemResponse_ResponseType_Parse(
    const ::std::string& name, InvestmentSystemResponse_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InvestmentSystemResponse_ResponseType>(
    InvestmentSystemResponse_ResponseType_descriptor(), name, value);
}
enum InvestmentSystemBroadcast_BroadcastType {
  InvestmentSystemBroadcast_BroadcastType_PRICE = 1,
  InvestmentSystemBroadcast_BroadcastType_TRADE = 2,
  InvestmentSystemBroadcast_BroadcastType_DATA = 3,
  InvestmentSystemBroadcast_BroadcastType_HEARTBEAT = 4
};
bool InvestmentSystemBroadcast_BroadcastType_IsValid(int value);
const InvestmentSystemBroadcast_BroadcastType InvestmentSystemBroadcast_BroadcastType_BroadcastType_MIN = InvestmentSystemBroadcast_BroadcastType_PRICE;
const InvestmentSystemBroadcast_BroadcastType InvestmentSystemBroadcast_BroadcastType_BroadcastType_MAX = InvestmentSystemBroadcast_BroadcastType_HEARTBEAT;
const int InvestmentSystemBroadcast_BroadcastType_BroadcastType_ARRAYSIZE = InvestmentSystemBroadcast_BroadcastType_BroadcastType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InvestmentSystemBroadcast_BroadcastType_descriptor();
inline const ::std::string& InvestmentSystemBroadcast_BroadcastType_Name(InvestmentSystemBroadcast_BroadcastType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InvestmentSystemBroadcast_BroadcastType_descriptor(), value);
}
inline bool InvestmentSystemBroadcast_BroadcastType_Parse(
    const ::std::string& name, InvestmentSystemBroadcast_BroadcastType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InvestmentSystemBroadcast_BroadcastType>(
    InvestmentSystemBroadcast_BroadcastType_descriptor(), name, value);
}
// ===================================================================

class FixMarketData : public ::google::protobuf::Message {
 public:
  FixMarketData();
  virtual ~FixMarketData();
  
  FixMarketData(const FixMarketData& from);
  
  inline FixMarketData& operator=(const FixMarketData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FixMarketData& default_instance();
  
  void Swap(FixMarketData* other);
  
  // implements Message ----------------------------------------------
  
  FixMarketData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FixMarketData& from);
  void MergeFrom(const FixMarketData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FixMarketData_EntryType EntryType;
  static const EntryType BID = FixMarketData_EntryType_BID;
  static const EntryType ASK = FixMarketData_EntryType_ASK;
  static const EntryType TRADE = FixMarketData_EntryType_TRADE;
  static const EntryType UNKNOWN = FixMarketData_EntryType_UNKNOWN;
  static inline bool EntryType_IsValid(int value) {
    return FixMarketData_EntryType_IsValid(value);
  }
  static const EntryType EntryType_MIN =
    FixMarketData_EntryType_EntryType_MIN;
  static const EntryType EntryType_MAX =
    FixMarketData_EntryType_EntryType_MAX;
  static const int EntryType_ARRAYSIZE =
    FixMarketData_EntryType_EntryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EntryType_descriptor() {
    return FixMarketData_EntryType_descriptor();
  }
  static inline const ::std::string& EntryType_Name(EntryType value) {
    return FixMarketData_EntryType_Name(value);
  }
  static inline bool EntryType_Parse(const ::std::string& name,
      EntryType* value) {
    return FixMarketData_EntryType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string instrument_id = 1;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 1;
  inline const ::std::string& instrument_id() const;
  inline void set_instrument_id(const ::std::string& value);
  inline void set_instrument_id(const char* value);
  inline void set_instrument_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_id();
  inline ::std::string* release_instrument_id();
  
  // optional string sending_tm = 2;
  inline bool has_sending_tm() const;
  inline void clear_sending_tm();
  static const int kSendingTmFieldNumber = 2;
  inline const ::std::string& sending_tm() const;
  inline void set_sending_tm(const ::std::string& value);
  inline void set_sending_tm(const char* value);
  inline void set_sending_tm(const char* value, size_t size);
  inline ::std::string* mutable_sending_tm();
  inline ::std::string* release_sending_tm();
  
  // optional .quantmodel.FixMarketData.EntryType entry_type = 3;
  inline bool has_entry_type() const;
  inline void clear_entry_type();
  static const int kEntryTypeFieldNumber = 3;
  inline ::quantmodel::FixMarketData_EntryType entry_type() const;
  inline void set_entry_type(::quantmodel::FixMarketData_EntryType value);
  
  // optional string update_action = 4;
  inline bool has_update_action() const;
  inline void clear_update_action();
  static const int kUpdateActionFieldNumber = 4;
  inline const ::std::string& update_action() const;
  inline void set_update_action(const ::std::string& value);
  inline void set_update_action(const char* value);
  inline void set_update_action(const char* value, size_t size);
  inline ::std::string* mutable_update_action();
  inline ::std::string* release_update_action();
  
  // optional string entry_px = 5 [default = "0"];
  inline bool has_entry_px() const;
  inline void clear_entry_px();
  static const int kEntryPxFieldNumber = 5;
  inline const ::std::string& entry_px() const;
  inline void set_entry_px(const ::std::string& value);
  inline void set_entry_px(const char* value);
  inline void set_entry_px(const char* value, size_t size);
  inline ::std::string* mutable_entry_px();
  inline ::std::string* release_entry_px();
  
  // optional string entry_size = 6 [default = "0"];
  inline bool has_entry_size() const;
  inline void clear_entry_size();
  static const int kEntrySizeFieldNumber = 6;
  inline const ::std::string& entry_size() const;
  inline void set_entry_size(const ::std::string& value);
  inline void set_entry_size(const char* value);
  inline void set_entry_size(const char* value, size_t size);
  inline ::std::string* mutable_entry_size();
  inline ::std::string* release_entry_size();
  
  // @@protoc_insertion_point(class_scope:quantmodel.FixMarketData)
 private:
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_sending_tm();
  inline void clear_has_sending_tm();
  inline void set_has_entry_type();
  inline void clear_has_entry_type();
  inline void set_has_update_action();
  inline void clear_has_update_action();
  inline void set_has_entry_px();
  inline void clear_has_entry_px();
  inline void set_has_entry_size();
  inline void clear_has_entry_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* instrument_id_;
  ::std::string* sending_tm_;
  ::std::string* update_action_;
  ::std::string* entry_px_;
  static const ::std::string _default_entry_px_;
  ::std::string* entry_size_;
  static const ::std::string _default_entry_size_;
  int entry_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static FixMarketData* default_instance_;
};
// -------------------------------------------------------------------

class CMEMarketData : public ::google::protobuf::Message {
 public:
  CMEMarketData();
  virtual ~CMEMarketData();
  
  CMEMarketData(const CMEMarketData& from);
  
  inline CMEMarketData& operator=(const CMEMarketData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CMEMarketData& default_instance();
  
  void Swap(CMEMarketData* other);
  
  // implements Message ----------------------------------------------
  
  CMEMarketData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMEMarketData& from);
  void MergeFrom(const CMEMarketData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef CMEMarketData_EntryType EntryType;
  static const EntryType BID = CMEMarketData_EntryType_BID;
  static const EntryType ASK = CMEMarketData_EntryType_ASK;
  static const EntryType TRADE = CMEMarketData_EntryType_TRADE;
  static const EntryType OPENING_PRICE = CMEMarketData_EntryType_OPENING_PRICE;
  static const EntryType SETTLEMENT_PRICE = CMEMarketData_EntryType_SETTLEMENT_PRICE;
  static const EntryType TRADING_SESSION_HIGH_PRICE = CMEMarketData_EntryType_TRADING_SESSION_HIGH_PRICE;
  static const EntryType TRADING_SESSION_LOW_PRICE = CMEMarketData_EntryType_TRADING_SESSION_LOW_PRICE;
  static const EntryType TRADE_VOLUME = CMEMarketData_EntryType_TRADE_VOLUME;
  static const EntryType OPEN_INTEREST = CMEMarketData_EntryType_OPEN_INTEREST;
  static const EntryType SIMULATED_SELL = CMEMarketData_EntryType_SIMULATED_SELL;
  static const EntryType SIMULATED_BUY = CMEMarketData_EntryType_SIMULATED_BUY;
  static const EntryType EMPTY_BOOK = CMEMarketData_EntryType_EMPTY_BOOK;
  static const EntryType PRIOR = CMEMarketData_EntryType_PRIOR;
  static const EntryType SESSION_HIGH_BID = CMEMarketData_EntryType_SESSION_HIGH_BID;
  static const EntryType SESSION_LOW_OFFER = CMEMarketData_EntryType_SESSION_LOW_OFFER;
  static const EntryType FIXING_PRICE = CMEMarketData_EntryType_FIXING_PRICE;
  static const EntryType CASH_NOTE = CMEMarketData_EntryType_CASH_NOTE;
  static inline bool EntryType_IsValid(int value) {
    return CMEMarketData_EntryType_IsValid(value);
  }
  static const EntryType EntryType_MIN =
    CMEMarketData_EntryType_EntryType_MIN;
  static const EntryType EntryType_MAX =
    CMEMarketData_EntryType_EntryType_MAX;
  static const int EntryType_ARRAYSIZE =
    CMEMarketData_EntryType_EntryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EntryType_descriptor() {
    return CMEMarketData_EntryType_descriptor();
  }
  static inline const ::std::string& EntryType_Name(EntryType value) {
    return CMEMarketData_EntryType_Name(value);
  }
  static inline bool EntryType_Parse(const ::std::string& name,
      EntryType* value) {
    return CMEMarketData_EntryType_Parse(name, value);
  }
  
  typedef CMEMarketData_UpdateAction UpdateAction;
  static const UpdateAction ADD = CMEMarketData_UpdateAction_ADD;
  static const UpdateAction CHANGE = CMEMarketData_UpdateAction_CHANGE;
  static const UpdateAction DELETE = CMEMarketData_UpdateAction_DELETE;
  static const UpdateAction OVERLAY = CMEMarketData_UpdateAction_OVERLAY;
  static inline bool UpdateAction_IsValid(int value) {
    return CMEMarketData_UpdateAction_IsValid(value);
  }
  static const UpdateAction UpdateAction_MIN =
    CMEMarketData_UpdateAction_UpdateAction_MIN;
  static const UpdateAction UpdateAction_MAX =
    CMEMarketData_UpdateAction_UpdateAction_MAX;
  static const int UpdateAction_ARRAYSIZE =
    CMEMarketData_UpdateAction_UpdateAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UpdateAction_descriptor() {
    return CMEMarketData_UpdateAction_descriptor();
  }
  static inline const ::std::string& UpdateAction_Name(UpdateAction value) {
    return CMEMarketData_UpdateAction_Name(value);
  }
  static inline bool UpdateAction_Parse(const ::std::string& name,
      UpdateAction* value) {
    return CMEMarketData_UpdateAction_Parse(name, value);
  }
  
  typedef CMEMarketData_AggressorType AggressorType;
  static const AggressorType UNKNOWN = CMEMarketData_AggressorType_UNKNOWN;
  static const AggressorType BUY = CMEMarketData_AggressorType_BUY;
  static const AggressorType SELL = CMEMarketData_AggressorType_SELL;
  static inline bool AggressorType_IsValid(int value) {
    return CMEMarketData_AggressorType_IsValid(value);
  }
  static const AggressorType AggressorType_MIN =
    CMEMarketData_AggressorType_AggressorType_MIN;
  static const AggressorType AggressorType_MAX =
    CMEMarketData_AggressorType_AggressorType_MAX;
  static const int AggressorType_ARRAYSIZE =
    CMEMarketData_AggressorType_AggressorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AggressorType_descriptor() {
    return CMEMarketData_AggressorType_descriptor();
  }
  static inline const ::std::string& AggressorType_Name(AggressorType value) {
    return CMEMarketData_AggressorType_Name(value);
  }
  static inline bool AggressorType_Parse(const ::std::string& name,
      AggressorType* value) {
    return CMEMarketData_AggressorType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required uint64 sending_tm = 1;
  inline bool has_sending_tm() const;
  inline void clear_sending_tm();
  static const int kSendingTmFieldNumber = 1;
  inline ::google::protobuf::uint64 sending_tm() const;
  inline void set_sending_tm(::google::protobuf::uint64 value);
  
  // required uint32 security_id = 2;
  inline bool has_security_id() const;
  inline void clear_security_id();
  static const int kSecurityIdFieldNumber = 2;
  inline ::google::protobuf::uint32 security_id() const;
  inline void set_security_id(::google::protobuf::uint32 value);
  
  // required .quantmodel.CMEMarketData.UpdateAction update_action = 3;
  inline bool has_update_action() const;
  inline void clear_update_action();
  static const int kUpdateActionFieldNumber = 3;
  inline ::quantmodel::CMEMarketData_UpdateAction update_action() const;
  inline void set_update_action(::quantmodel::CMEMarketData_UpdateAction value);
  
  // required .quantmodel.CMEMarketData.EntryType entry_type = 4;
  inline bool has_entry_type() const;
  inline void clear_entry_type();
  static const int kEntryTypeFieldNumber = 4;
  inline ::quantmodel::CMEMarketData_EntryType entry_type() const;
  inline void set_entry_type(::quantmodel::CMEMarketData_EntryType value);
  
  // required bool is_implied = 5;
  inline bool has_is_implied() const;
  inline void clear_is_implied();
  static const int kIsImpliedFieldNumber = 5;
  inline bool is_implied() const;
  inline void set_is_implied(bool value);
  
  // optional int32 entry_size = 6 [default = 0];
  inline bool has_entry_size() const;
  inline void clear_entry_size();
  static const int kEntrySizeFieldNumber = 6;
  inline ::google::protobuf::int32 entry_size() const;
  inline void set_entry_size(::google::protobuf::int32 value);
  
  // optional string entry_px = 7 [default = "0", deprecated = true];
  inline bool has_entry_px() const PROTOBUF_DEPRECATED;
  inline void clear_entry_px() PROTOBUF_DEPRECATED;
  static const int kEntryPxFieldNumber = 7;
  inline const ::std::string& entry_px() const PROTOBUF_DEPRECATED;
  inline void set_entry_px(const ::std::string& value) PROTOBUF_DEPRECATED;
  inline void set_entry_px(const char* value) PROTOBUF_DEPRECATED;
  inline void set_entry_px(const char* value, size_t size) PROTOBUF_DEPRECATED;
  inline ::std::string* mutable_entry_px() PROTOBUF_DEPRECATED;
  inline ::std::string* release_entry_px() PROTOBUF_DEPRECATED;
  
  // optional uint32 orders = 8 [default = 0];
  inline bool has_orders() const;
  inline void clear_orders();
  static const int kOrdersFieldNumber = 8;
  inline ::google::protobuf::uint32 orders() const;
  inline void set_orders(::google::protobuf::uint32 value);
  
  // optional uint32 price_level = 9 [default = 0];
  inline bool has_price_level() const;
  inline void clear_price_level();
  static const int kPriceLevelFieldNumber = 9;
  inline ::google::protobuf::uint32 price_level() const;
  inline void set_price_level(::google::protobuf::uint32 value);
  
  // optional uint32 entry_tm = 10 [default = 0];
  inline bool has_entry_tm() const;
  inline void clear_entry_tm();
  static const int kEntryTmFieldNumber = 10;
  inline ::google::protobuf::uint32 entry_tm() const;
  inline void set_entry_tm(::google::protobuf::uint32 value);
  
  // optional .quantmodel.CMEMarketData.AggressorType aggressor = 11 [default = UNKNOWN];
  inline bool has_aggressor() const;
  inline void clear_aggressor();
  static const int kAggressorFieldNumber = 11;
  inline ::quantmodel::CMEMarketData_AggressorType aggressor() const;
  inline void set_aggressor(::quantmodel::CMEMarketData_AggressorType value);
  
  // optional int64 mantissa = 12 [default = 0];
  inline bool has_mantissa() const;
  inline void clear_mantissa();
  static const int kMantissaFieldNumber = 12;
  inline ::google::protobuf::int64 mantissa() const;
  inline void set_mantissa(::google::protobuf::int64 value);
  
  // optional int32 exponent = 13 [default = 0];
  inline bool has_exponent() const;
  inline void clear_exponent();
  static const int kExponentFieldNumber = 13;
  inline ::google::protobuf::int32 exponent() const;
  inline void set_exponent(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:quantmodel.CMEMarketData)
 private:
  inline void set_has_sending_tm();
  inline void clear_has_sending_tm();
  inline void set_has_security_id();
  inline void clear_has_security_id();
  inline void set_has_update_action();
  inline void clear_has_update_action();
  inline void set_has_entry_type();
  inline void clear_has_entry_type();
  inline void set_has_is_implied();
  inline void clear_has_is_implied();
  inline void set_has_entry_size();
  inline void clear_has_entry_size();
  inline void set_has_entry_px();
  inline void clear_has_entry_px();
  inline void set_has_orders();
  inline void clear_has_orders();
  inline void set_has_price_level();
  inline void clear_has_price_level();
  inline void set_has_entry_tm();
  inline void clear_has_entry_tm();
  inline void set_has_aggressor();
  inline void clear_has_aggressor();
  inline void set_has_mantissa();
  inline void clear_has_mantissa();
  inline void set_has_exponent();
  inline void clear_has_exponent();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 sending_tm_;
  ::google::protobuf::uint32 security_id_;
  int update_action_;
  int entry_type_;
  bool is_implied_;
  ::std::string* entry_px_;
  static const ::std::string _default_entry_px_;
  ::google::protobuf::int32 entry_size_;
  ::google::protobuf::uint32 orders_;
  ::google::protobuf::uint32 price_level_;
  ::google::protobuf::uint32 entry_tm_;
  ::google::protobuf::int64 mantissa_;
  int aggressor_;
  ::google::protobuf::int32 exponent_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static CMEMarketData* default_instance_;
};
// -------------------------------------------------------------------

class FastEngineBroadcast : public ::google::protobuf::Message {
 public:
  FastEngineBroadcast();
  virtual ~FastEngineBroadcast();
  
  FastEngineBroadcast(const FastEngineBroadcast& from);
  
  inline FastEngineBroadcast& operator=(const FastEngineBroadcast& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FastEngineBroadcast& default_instance();
  
  void Swap(FastEngineBroadcast* other);
  
  // implements Message ----------------------------------------------
  
  FastEngineBroadcast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FastEngineBroadcast& from);
  void MergeFrom(const FastEngineBroadcast& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FastEngineBroadcast_BroadcastType BroadcastType;
  static const BroadcastType CME = FastEngineBroadcast_BroadcastType_CME;
  static const BroadcastType ICE = FastEngineBroadcast_BroadcastType_ICE;
  static const BroadcastType CBOE = FastEngineBroadcast_BroadcastType_CBOE;
  static inline bool BroadcastType_IsValid(int value) {
    return FastEngineBroadcast_BroadcastType_IsValid(value);
  }
  static const BroadcastType BroadcastType_MIN =
    FastEngineBroadcast_BroadcastType_BroadcastType_MIN;
  static const BroadcastType BroadcastType_MAX =
    FastEngineBroadcast_BroadcastType_BroadcastType_MAX;
  static const int BroadcastType_ARRAYSIZE =
    FastEngineBroadcast_BroadcastType_BroadcastType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BroadcastType_descriptor() {
    return FastEngineBroadcast_BroadcastType_descriptor();
  }
  static inline const ::std::string& BroadcastType_Name(BroadcastType value) {
    return FastEngineBroadcast_BroadcastType_Name(value);
  }
  static inline bool BroadcastType_Parse(const ::std::string& name,
      BroadcastType* value) {
    return FastEngineBroadcast_BroadcastType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // required .quantmodel.FastEngineBroadcast.BroadcastType broadcast_type = 2;
  inline bool has_broadcast_type() const;
  inline void clear_broadcast_type();
  static const int kBroadcastTypeFieldNumber = 2;
  inline ::quantmodel::FastEngineBroadcast_BroadcastType broadcast_type() const;
  inline void set_broadcast_type(::quantmodel::FastEngineBroadcast_BroadcastType value);
  
  // repeated .quantmodel.CMEMarketData cme_market_data = 3;
  inline int cme_market_data_size() const;
  inline void clear_cme_market_data();
  static const int kCmeMarketDataFieldNumber = 3;
  inline const ::quantmodel::CMEMarketData& cme_market_data(int index) const;
  inline ::quantmodel::CMEMarketData* mutable_cme_market_data(int index);
  inline ::quantmodel::CMEMarketData* add_cme_market_data();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::CMEMarketData >&
      cme_market_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::CMEMarketData >*
      mutable_cme_market_data();
  
  // @@protoc_insertion_point(class_scope:quantmodel.FastEngineBroadcast)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_broadcast_type();
  inline void clear_has_broadcast_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* timestamp_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::CMEMarketData > cme_market_data_;
  int broadcast_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static FastEngineBroadcast* default_instance_;
};
// -------------------------------------------------------------------

class FixEngineBroadcast : public ::google::protobuf::Message {
 public:
  FixEngineBroadcast();
  virtual ~FixEngineBroadcast();
  
  FixEngineBroadcast(const FixEngineBroadcast& from);
  
  inline FixEngineBroadcast& operator=(const FixEngineBroadcast& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FixEngineBroadcast& default_instance();
  
  void Swap(FixEngineBroadcast* other);
  
  // implements Message ----------------------------------------------
  
  FixEngineBroadcast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FixEngineBroadcast& from);
  void MergeFrom(const FixEngineBroadcast& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // optional string instrument_id = 2;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 2;
  inline const ::std::string& instrument_id() const;
  inline void set_instrument_id(const ::std::string& value);
  inline void set_instrument_id(const char* value);
  inline void set_instrument_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_id();
  inline ::std::string* release_instrument_id();
  
  // repeated .quantmodel.FixMarketData fix_market_data = 3;
  inline int fix_market_data_size() const;
  inline void clear_fix_market_data();
  static const int kFixMarketDataFieldNumber = 3;
  inline const ::quantmodel::FixMarketData& fix_market_data(int index) const;
  inline ::quantmodel::FixMarketData* mutable_fix_market_data(int index);
  inline ::quantmodel::FixMarketData* add_fix_market_data();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::FixMarketData >&
      fix_market_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::FixMarketData >*
      mutable_fix_market_data();
  
  // @@protoc_insertion_point(class_scope:quantmodel.FixEngineBroadcast)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* timestamp_;
  ::std::string* instrument_id_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::FixMarketData > fix_market_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static FixEngineBroadcast* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataPriceData : public ::google::protobuf::Message {
 public:
  MarketDataPriceData();
  virtual ~MarketDataPriceData();
  
  MarketDataPriceData(const MarketDataPriceData& from);
  
  inline MarketDataPriceData& operator=(const MarketDataPriceData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataPriceData& default_instance();
  
  void Swap(MarketDataPriceData* other);
  
  // implements Message ----------------------------------------------
  
  MarketDataPriceData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataPriceData& from);
  void MergeFrom(const MarketDataPriceData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string instrument_id = 1;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 1;
  inline const ::std::string& instrument_id() const;
  inline void set_instrument_id(const ::std::string& value);
  inline void set_instrument_id(const char* value);
  inline void set_instrument_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_id();
  inline ::std::string* release_instrument_id();
  
  // optional string last_prc = 2 [default = "0.0"];
  inline bool has_last_prc() const;
  inline void clear_last_prc();
  static const int kLastPrcFieldNumber = 2;
  inline const ::std::string& last_prc() const;
  inline void set_last_prc(const ::std::string& value);
  inline void set_last_prc(const char* value);
  inline void set_last_prc(const char* value, size_t size);
  inline ::std::string* mutable_last_prc();
  inline ::std::string* release_last_prc();
  
  // @@protoc_insertion_point(class_scope:quantmodel.MarketDataPriceData)
 private:
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_last_prc();
  inline void clear_has_last_prc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* instrument_id_;
  ::std::string* last_prc_;
  static const ::std::string _default_last_prc_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static MarketDataPriceData* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataTradeData : public ::google::protobuf::Message {
 public:
  MarketDataTradeData();
  virtual ~MarketDataTradeData();
  
  MarketDataTradeData(const MarketDataTradeData& from);
  
  inline MarketDataTradeData& operator=(const MarketDataTradeData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataTradeData& default_instance();
  
  void Swap(MarketDataTradeData* other);
  
  // implements Message ----------------------------------------------
  
  MarketDataTradeData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataTradeData& from);
  void MergeFrom(const MarketDataTradeData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MarketDataTradeData_AggressorType AggressorType;
  static const AggressorType UNKNOWN = MarketDataTradeData_AggressorType_UNKNOWN;
  static const AggressorType BUY = MarketDataTradeData_AggressorType_BUY;
  static const AggressorType SELL = MarketDataTradeData_AggressorType_SELL;
  static inline bool AggressorType_IsValid(int value) {
    return MarketDataTradeData_AggressorType_IsValid(value);
  }
  static const AggressorType AggressorType_MIN =
    MarketDataTradeData_AggressorType_AggressorType_MIN;
  static const AggressorType AggressorType_MAX =
    MarketDataTradeData_AggressorType_AggressorType_MAX;
  static const int AggressorType_ARRAYSIZE =
    MarketDataTradeData_AggressorType_AggressorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AggressorType_descriptor() {
    return MarketDataTradeData_AggressorType_descriptor();
  }
  static inline const ::std::string& AggressorType_Name(AggressorType value) {
    return MarketDataTradeData_AggressorType_Name(value);
  }
  static inline bool AggressorType_Parse(const ::std::string& name,
      AggressorType* value) {
    return MarketDataTradeData_AggressorType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string instrument_id = 1;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 1;
  inline const ::std::string& instrument_id() const;
  inline void set_instrument_id(const ::std::string& value);
  inline void set_instrument_id(const char* value);
  inline void set_instrument_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_id();
  inline ::std::string* release_instrument_id();
  
  // optional .quantmodel.MarketDataTradeData.AggressorType aggressor = 2 [default = UNKNOWN];
  inline bool has_aggressor() const;
  inline void clear_aggressor();
  static const int kAggressorFieldNumber = 2;
  inline ::quantmodel::MarketDataTradeData_AggressorType aggressor() const;
  inline void set_aggressor(::quantmodel::MarketDataTradeData_AggressorType value);
  
  // optional string trade_prc = 3 [default = "0.0"];
  inline bool has_trade_prc() const;
  inline void clear_trade_prc();
  static const int kTradePrcFieldNumber = 3;
  inline const ::std::string& trade_prc() const;
  inline void set_trade_prc(const ::std::string& value);
  inline void set_trade_prc(const char* value);
  inline void set_trade_prc(const char* value, size_t size);
  inline ::std::string* mutable_trade_prc();
  inline ::std::string* release_trade_prc();
  
  // optional int32 trade_qty = 4 [default = 0];
  inline bool has_trade_qty() const;
  inline void clear_trade_qty();
  static const int kTradeQtyFieldNumber = 4;
  inline ::google::protobuf::int32 trade_qty() const;
  inline void set_trade_qty(::google::protobuf::int32 value);
  
  // optional uint32 entry_tm = 5;
  inline bool has_entry_tm() const;
  inline void clear_entry_tm();
  static const int kEntryTmFieldNumber = 5;
  inline ::google::protobuf::uint32 entry_tm() const;
  inline void set_entry_tm(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:quantmodel.MarketDataTradeData)
 private:
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_aggressor();
  inline void clear_has_aggressor();
  inline void set_has_trade_prc();
  inline void clear_has_trade_prc();
  inline void set_has_trade_qty();
  inline void clear_has_trade_qty();
  inline void set_has_entry_tm();
  inline void clear_has_entry_tm();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* instrument_id_;
  ::std::string* trade_prc_;
  static const ::std::string _default_trade_prc_;
  int aggressor_;
  ::google::protobuf::int32 trade_qty_;
  ::google::protobuf::uint32 entry_tm_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static MarketDataTradeData* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataQuoteData : public ::google::protobuf::Message {
 public:
  MarketDataQuoteData();
  virtual ~MarketDataQuoteData();
  
  MarketDataQuoteData(const MarketDataQuoteData& from);
  
  inline MarketDataQuoteData& operator=(const MarketDataQuoteData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataQuoteData& default_instance();
  
  void Swap(MarketDataQuoteData* other);
  
  // implements Message ----------------------------------------------
  
  MarketDataQuoteData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataQuoteData& from);
  void MergeFrom(const MarketDataQuoteData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MarketDataQuoteData_QuoteType QuoteType;
  static const QuoteType BID = MarketDataQuoteData_QuoteType_BID;
  static const QuoteType ASK = MarketDataQuoteData_QuoteType_ASK;
  static inline bool QuoteType_IsValid(int value) {
    return MarketDataQuoteData_QuoteType_IsValid(value);
  }
  static const QuoteType QuoteType_MIN =
    MarketDataQuoteData_QuoteType_QuoteType_MIN;
  static const QuoteType QuoteType_MAX =
    MarketDataQuoteData_QuoteType_QuoteType_MAX;
  static const int QuoteType_ARRAYSIZE =
    MarketDataQuoteData_QuoteType_QuoteType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  QuoteType_descriptor() {
    return MarketDataQuoteData_QuoteType_descriptor();
  }
  static inline const ::std::string& QuoteType_Name(QuoteType value) {
    return MarketDataQuoteData_QuoteType_Name(value);
  }
  static inline bool QuoteType_Parse(const ::std::string& name,
      QuoteType* value) {
    return MarketDataQuoteData_QuoteType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string instrument_id = 1;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 1;
  inline const ::std::string& instrument_id() const;
  inline void set_instrument_id(const ::std::string& value);
  inline void set_instrument_id(const char* value);
  inline void set_instrument_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_id();
  inline ::std::string* release_instrument_id();
  
  // optional .quantmodel.MarketDataQuoteData.QuoteType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::quantmodel::MarketDataQuoteData_QuoteType type() const;
  inline void set_type(::quantmodel::MarketDataQuoteData_QuoteType value);
  
  // optional string quote_prc = 3 [default = "0.0"];
  inline bool has_quote_prc() const;
  inline void clear_quote_prc();
  static const int kQuotePrcFieldNumber = 3;
  inline const ::std::string& quote_prc() const;
  inline void set_quote_prc(const ::std::string& value);
  inline void set_quote_prc(const char* value);
  inline void set_quote_prc(const char* value, size_t size);
  inline ::std::string* mutable_quote_prc();
  inline ::std::string* release_quote_prc();
  
  // optional int32 quote_qty = 4 [default = 0];
  inline bool has_quote_qty() const;
  inline void clear_quote_qty();
  static const int kQuoteQtyFieldNumber = 4;
  inline ::google::protobuf::int32 quote_qty() const;
  inline void set_quote_qty(::google::protobuf::int32 value);
  
  // optional int32 level = 5 [default = 0];
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:quantmodel.MarketDataQuoteData)
 private:
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_quote_prc();
  inline void clear_has_quote_prc();
  inline void set_has_quote_qty();
  inline void clear_has_quote_qty();
  inline void set_has_level();
  inline void clear_has_level();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* instrument_id_;
  ::std::string* quote_prc_;
  static const ::std::string _default_quote_prc_;
  int type_;
  ::google::protobuf::int32 quote_qty_;
  ::google::protobuf::int32 level_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static MarketDataQuoteData* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataBroadcast : public ::google::protobuf::Message {
 public:
  MarketDataBroadcast();
  virtual ~MarketDataBroadcast();
  
  MarketDataBroadcast(const MarketDataBroadcast& from);
  
  inline MarketDataBroadcast& operator=(const MarketDataBroadcast& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataBroadcast& default_instance();
  
  void Swap(MarketDataBroadcast* other);
  
  // implements Message ----------------------------------------------
  
  MarketDataBroadcast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataBroadcast& from);
  void MergeFrom(const MarketDataBroadcast& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef MarketDataBroadcast_BroadcastType BroadcastType;
  static const BroadcastType PRICE = MarketDataBroadcast_BroadcastType_PRICE;
  static const BroadcastType TRADE = MarketDataBroadcast_BroadcastType_TRADE;
  static const BroadcastType QUOTE = MarketDataBroadcast_BroadcastType_QUOTE;
  static inline bool BroadcastType_IsValid(int value) {
    return MarketDataBroadcast_BroadcastType_IsValid(value);
  }
  static const BroadcastType BroadcastType_MIN =
    MarketDataBroadcast_BroadcastType_BroadcastType_MIN;
  static const BroadcastType BroadcastType_MAX =
    MarketDataBroadcast_BroadcastType_BroadcastType_MAX;
  static const int BroadcastType_ARRAYSIZE =
    MarketDataBroadcast_BroadcastType_BroadcastType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BroadcastType_descriptor() {
    return MarketDataBroadcast_BroadcastType_descriptor();
  }
  static inline const ::std::string& BroadcastType_Name(BroadcastType value) {
    return MarketDataBroadcast_BroadcastType_Name(value);
  }
  static inline bool BroadcastType_Parse(const ::std::string& name,
      BroadcastType* value) {
    return MarketDataBroadcast_BroadcastType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string broadcast_id = 1;
  inline bool has_broadcast_id() const;
  inline void clear_broadcast_id();
  static const int kBroadcastIdFieldNumber = 1;
  inline const ::std::string& broadcast_id() const;
  inline void set_broadcast_id(const ::std::string& value);
  inline void set_broadcast_id(const char* value);
  inline void set_broadcast_id(const char* value, size_t size);
  inline ::std::string* mutable_broadcast_id();
  inline ::std::string* release_broadcast_id();
  
  // optional string timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // optional .quantmodel.MarketDataBroadcast.BroadcastType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::quantmodel::MarketDataBroadcast_BroadcastType type() const;
  inline void set_type(::quantmodel::MarketDataBroadcast_BroadcastType value);
  
  // repeated .quantmodel.MarketDataPriceData price_data = 5;
  inline int price_data_size() const;
  inline void clear_price_data();
  static const int kPriceDataFieldNumber = 5;
  inline const ::quantmodel::MarketDataPriceData& price_data(int index) const;
  inline ::quantmodel::MarketDataPriceData* mutable_price_data(int index);
  inline ::quantmodel::MarketDataPriceData* add_price_data();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataPriceData >&
      price_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataPriceData >*
      mutable_price_data();
  
  // repeated .quantmodel.MarketDataTradeData trade_data = 6;
  inline int trade_data_size() const;
  inline void clear_trade_data();
  static const int kTradeDataFieldNumber = 6;
  inline const ::quantmodel::MarketDataTradeData& trade_data(int index) const;
  inline ::quantmodel::MarketDataTradeData* mutable_trade_data(int index);
  inline ::quantmodel::MarketDataTradeData* add_trade_data();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataTradeData >&
      trade_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataTradeData >*
      mutable_trade_data();
  
  // repeated .quantmodel.MarketDataQuoteData quote_data = 7;
  inline int quote_data_size() const;
  inline void clear_quote_data();
  static const int kQuoteDataFieldNumber = 7;
  inline const ::quantmodel::MarketDataQuoteData& quote_data(int index) const;
  inline ::quantmodel::MarketDataQuoteData* mutable_quote_data(int index);
  inline ::quantmodel::MarketDataQuoteData* add_quote_data();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataQuoteData >&
      quote_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataQuoteData >*
      mutable_quote_data();
  
  // @@protoc_insertion_point(class_scope:quantmodel.MarketDataBroadcast)
 private:
  inline void set_has_broadcast_id();
  inline void clear_has_broadcast_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* broadcast_id_;
  ::std::string* timestamp_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataPriceData > price_data_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataTradeData > trade_data_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataQuoteData > quote_data_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static MarketDataBroadcast* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatData : public ::google::protobuf::Message {
 public:
  HeartbeatData();
  virtual ~HeartbeatData();
  
  HeartbeatData(const HeartbeatData& from);
  
  inline HeartbeatData& operator=(const HeartbeatData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatData& default_instance();
  
  void Swap(HeartbeatData* other);
  
  // implements Message ----------------------------------------------
  
  HeartbeatData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatData& from);
  void MergeFrom(const HeartbeatData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string heartbeat_id = 1;
  inline bool has_heartbeat_id() const;
  inline void clear_heartbeat_id();
  static const int kHeartbeatIdFieldNumber = 1;
  inline const ::std::string& heartbeat_id() const;
  inline void set_heartbeat_id(const ::std::string& value);
  inline void set_heartbeat_id(const char* value);
  inline void set_heartbeat_id(const char* value, size_t size);
  inline ::std::string* mutable_heartbeat_id();
  inline ::std::string* release_heartbeat_id();
  
  // optional string timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // @@protoc_insertion_point(class_scope:quantmodel.HeartbeatData)
 private:
  inline void set_has_heartbeat_id();
  inline void clear_has_heartbeat_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* heartbeat_id_;
  ::std::string* timestamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static HeartbeatData* default_instance_;
};
// -------------------------------------------------------------------

class FixEngineData : public ::google::protobuf::Message {
 public:
  FixEngineData();
  virtual ~FixEngineData();
  
  FixEngineData(const FixEngineData& from);
  
  inline FixEngineData& operator=(const FixEngineData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FixEngineData& default_instance();
  
  void Swap(FixEngineData* other);
  
  // implements Message ----------------------------------------------
  
  FixEngineData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FixEngineData& from);
  void MergeFrom(const FixEngineData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string fix_engine_id = 1;
  inline bool has_fix_engine_id() const;
  inline void clear_fix_engine_id();
  static const int kFixEngineIdFieldNumber = 1;
  inline const ::std::string& fix_engine_id() const;
  inline void set_fix_engine_id(const ::std::string& value);
  inline void set_fix_engine_id(const char* value);
  inline void set_fix_engine_id(const char* value, size_t size);
  inline ::std::string* mutable_fix_engine_id();
  inline ::std::string* release_fix_engine_id();
  
  // optional string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // @@protoc_insertion_point(class_scope:quantmodel.FixEngineData)
 private:
  inline void set_has_fix_engine_id();
  inline void clear_has_fix_engine_id();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* fix_engine_id_;
  ::std::string* session_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static FixEngineData* default_instance_;
};
// -------------------------------------------------------------------

class SystemParameterData : public ::google::protobuf::Message {
 public:
  SystemParameterData();
  virtual ~SystemParameterData();
  
  SystemParameterData(const SystemParameterData& from);
  
  inline SystemParameterData& operator=(const SystemParameterData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemParameterData& default_instance();
  
  void Swap(SystemParameterData* other);
  
  // implements Message ----------------------------------------------
  
  SystemParameterData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemParameterData& from);
  void MergeFrom(const SystemParameterData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string parameter_id = 1;
  inline bool has_parameter_id() const;
  inline void clear_parameter_id();
  static const int kParameterIdFieldNumber = 1;
  inline const ::std::string& parameter_id() const;
  inline void set_parameter_id(const ::std::string& value);
  inline void set_parameter_id(const char* value);
  inline void set_parameter_id(const char* value, size_t size);
  inline ::std::string* mutable_parameter_id();
  inline ::std::string* release_parameter_id();
  
  // optional string category = 2;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 2;
  inline const ::std::string& category() const;
  inline void set_category(const ::std::string& value);
  inline void set_category(const char* value);
  inline void set_category(const char* value, size_t size);
  inline ::std::string* mutable_category();
  inline ::std::string* release_category();
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:quantmodel.SystemParameterData)
 private:
  inline void set_has_parameter_id();
  inline void clear_has_parameter_id();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* parameter_id_;
  ::std::string* category_;
  ::std::string* name_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static SystemParameterData* default_instance_;
};
// -------------------------------------------------------------------

class PositionOvernightData : public ::google::protobuf::Message {
 public:
  PositionOvernightData();
  virtual ~PositionOvernightData();
  
  PositionOvernightData(const PositionOvernightData& from);
  
  inline PositionOvernightData& operator=(const PositionOvernightData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionOvernightData& default_instance();
  
  void Swap(PositionOvernightData* other);
  
  // implements Message ----------------------------------------------
  
  PositionOvernightData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PositionOvernightData& from);
  void MergeFrom(const PositionOvernightData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef PositionOvernightData_PositionType PositionType;
  static const PositionType CLOSED = PositionOvernightData_PositionType_CLOSED;
  static const PositionType LONG = PositionOvernightData_PositionType_LONG;
  static const PositionType SHORT = PositionOvernightData_PositionType_SHORT;
  static inline bool PositionType_IsValid(int value) {
    return PositionOvernightData_PositionType_IsValid(value);
  }
  static const PositionType PositionType_MIN =
    PositionOvernightData_PositionType_PositionType_MIN;
  static const PositionType PositionType_MAX =
    PositionOvernightData_PositionType_PositionType_MAX;
  static const int PositionType_ARRAYSIZE =
    PositionOvernightData_PositionType_PositionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PositionType_descriptor() {
    return PositionOvernightData_PositionType_descriptor();
  }
  static inline const ::std::string& PositionType_Name(PositionType value) {
    return PositionOvernightData_PositionType_Name(value);
  }
  static inline bool PositionType_Parse(const ::std::string& name,
      PositionType* value) {
    return PositionOvernightData_PositionType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string position_overnight_id = 1;
  inline bool has_position_overnight_id() const;
  inline void clear_position_overnight_id();
  static const int kPositionOvernightIdFieldNumber = 1;
  inline const ::std::string& position_overnight_id() const;
  inline void set_position_overnight_id(const ::std::string& value);
  inline void set_position_overnight_id(const char* value);
  inline void set_position_overnight_id(const char* value, size_t size);
  inline ::std::string* mutable_position_overnight_id();
  inline ::std::string* release_position_overnight_id();
  
  // optional string account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline const ::std::string& account_id() const;
  inline void set_account_id(const ::std::string& value);
  inline void set_account_id(const char* value);
  inline void set_account_id(const char* value, size_t size);
  inline ::std::string* mutable_account_id();
  inline ::std::string* release_account_id();
  
  // optional string instrument_id = 3;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 3;
  inline const ::std::string& instrument_id() const;
  inline void set_instrument_id(const ::std::string& value);
  inline void set_instrument_id(const char* value);
  inline void set_instrument_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_id();
  inline ::std::string* release_instrument_id();
  
  // optional string investment_system_id = 4;
  inline bool has_investment_system_id() const;
  inline void clear_investment_system_id();
  static const int kInvestmentSystemIdFieldNumber = 4;
  inline const ::std::string& investment_system_id() const;
  inline void set_investment_system_id(const ::std::string& value);
  inline void set_investment_system_id(const char* value);
  inline void set_investment_system_id(const char* value, size_t size);
  inline ::std::string* mutable_investment_system_id();
  inline ::std::string* release_investment_system_id();
  
  // optional .quantmodel.PositionOvernightData.PositionType position_type = 5;
  inline bool has_position_type() const;
  inline void clear_position_type();
  static const int kPositionTypeFieldNumber = 5;
  inline ::quantmodel::PositionOvernightData_PositionType position_type() const;
  inline void set_position_type(::quantmodel::PositionOvernightData_PositionType value);
  
  // optional string open_pos = 6 [default = "0"];
  inline bool has_open_pos() const;
  inline void clear_open_pos();
  static const int kOpenPosFieldNumber = 6;
  inline const ::std::string& open_pos() const;
  inline void set_open_pos(const ::std::string& value);
  inline void set_open_pos(const char* value);
  inline void set_open_pos(const char* value, size_t size);
  inline ::std::string* mutable_open_pos();
  inline ::std::string* release_open_pos();
  
  // optional string open_prc = 7 [default = "0"];
  inline bool has_open_prc() const;
  inline void clear_open_prc();
  static const int kOpenPrcFieldNumber = 7;
  inline const ::std::string& open_prc() const;
  inline void set_open_prc(const ::std::string& value);
  inline void set_open_prc(const char* value);
  inline void set_open_prc(const char* value, size_t size);
  inline ::std::string* mutable_open_prc();
  inline ::std::string* release_open_prc();
  
  // optional string is_active = 8;
  inline bool has_is_active() const;
  inline void clear_is_active();
  static const int kIsActiveFieldNumber = 8;
  inline const ::std::string& is_active() const;
  inline void set_is_active(const ::std::string& value);
  inline void set_is_active(const char* value);
  inline void set_is_active(const char* value, size_t size);
  inline ::std::string* mutable_is_active();
  inline ::std::string* release_is_active();
  
  // optional string added_datetime = 9;
  inline bool has_added_datetime() const;
  inline void clear_added_datetime();
  static const int kAddedDatetimeFieldNumber = 9;
  inline const ::std::string& added_datetime() const;
  inline void set_added_datetime(const ::std::string& value);
  inline void set_added_datetime(const char* value);
  inline void set_added_datetime(const char* value, size_t size);
  inline ::std::string* mutable_added_datetime();
  inline ::std::string* release_added_datetime();
  
  // optional string added_by = 10;
  inline bool has_added_by() const;
  inline void clear_added_by();
  static const int kAddedByFieldNumber = 10;
  inline const ::std::string& added_by() const;
  inline void set_added_by(const ::std::string& value);
  inline void set_added_by(const char* value);
  inline void set_added_by(const char* value, size_t size);
  inline ::std::string* mutable_added_by();
  inline ::std::string* release_added_by();
  
  // optional string updated_datetime = 11;
  inline bool has_updated_datetime() const;
  inline void clear_updated_datetime();
  static const int kUpdatedDatetimeFieldNumber = 11;
  inline const ::std::string& updated_datetime() const;
  inline void set_updated_datetime(const ::std::string& value);
  inline void set_updated_datetime(const char* value);
  inline void set_updated_datetime(const char* value, size_t size);
  inline ::std::string* mutable_updated_datetime();
  inline ::std::string* release_updated_datetime();
  
  // optional string updated_by = 12;
  inline bool has_updated_by() const;
  inline void clear_updated_by();
  static const int kUpdatedByFieldNumber = 12;
  inline const ::std::string& updated_by() const;
  inline void set_updated_by(const ::std::string& value);
  inline void set_updated_by(const char* value);
  inline void set_updated_by(const char* value, size_t size);
  inline ::std::string* mutable_updated_by();
  inline ::std::string* release_updated_by();
  
  // @@protoc_insertion_point(class_scope:quantmodel.PositionOvernightData)
 private:
  inline void set_has_position_overnight_id();
  inline void clear_has_position_overnight_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_investment_system_id();
  inline void clear_has_investment_system_id();
  inline void set_has_position_type();
  inline void clear_has_position_type();
  inline void set_has_open_pos();
  inline void clear_has_open_pos();
  inline void set_has_open_prc();
  inline void clear_has_open_prc();
  inline void set_has_is_active();
  inline void clear_has_is_active();
  inline void set_has_added_datetime();
  inline void clear_has_added_datetime();
  inline void set_has_added_by();
  inline void clear_has_added_by();
  inline void set_has_updated_datetime();
  inline void clear_has_updated_datetime();
  inline void set_has_updated_by();
  inline void clear_has_updated_by();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* position_overnight_id_;
  ::std::string* account_id_;
  ::std::string* instrument_id_;
  ::std::string* investment_system_id_;
  ::std::string* open_pos_;
  static const ::std::string _default_open_pos_;
  ::std::string* open_prc_;
  static const ::std::string _default_open_prc_;
  ::std::string* is_active_;
  ::std::string* added_datetime_;
  ::std::string* added_by_;
  ::std::string* updated_datetime_;
  ::std::string* updated_by_;
  int position_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static PositionOvernightData* default_instance_;
};
// -------------------------------------------------------------------

class AccountLimitData : public ::google::protobuf::Message {
 public:
  AccountLimitData();
  virtual ~AccountLimitData();
  
  AccountLimitData(const AccountLimitData& from);
  
  inline AccountLimitData& operator=(const AccountLimitData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountLimitData& default_instance();
  
  void Swap(AccountLimitData* other);
  
  // implements Message ----------------------------------------------
  
  AccountLimitData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountLimitData& from);
  void MergeFrom(const AccountLimitData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline const ::std::string& account_id() const;
  inline void set_account_id(const ::std::string& value);
  inline void set_account_id(const char* value);
  inline void set_account_id(const char* value, size_t size);
  inline ::std::string* mutable_account_id();
  inline ::std::string* release_account_id();
  
  // optional string symbol = 2;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 2;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  
  // optional string security_exchange = 3;
  inline bool has_security_exchange() const;
  inline void clear_security_exchange();
  static const int kSecurityExchangeFieldNumber = 3;
  inline const ::std::string& security_exchange() const;
  inline void set_security_exchange(const ::std::string& value);
  inline void set_security_exchange(const char* value);
  inline void set_security_exchange(const char* value, size_t size);
  inline ::std::string* mutable_security_exchange();
  inline ::std::string* release_security_exchange();
  
  // optional string session_id = 4;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 4;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional string max_open_long_qty = 5 [default = "0"];
  inline bool has_max_open_long_qty() const;
  inline void clear_max_open_long_qty();
  static const int kMaxOpenLongQtyFieldNumber = 5;
  inline const ::std::string& max_open_long_qty() const;
  inline void set_max_open_long_qty(const ::std::string& value);
  inline void set_max_open_long_qty(const char* value);
  inline void set_max_open_long_qty(const char* value, size_t size);
  inline ::std::string* mutable_max_open_long_qty();
  inline ::std::string* release_max_open_long_qty();
  
  // optional string max_open_short_qty = 6 [default = "0"];
  inline bool has_max_open_short_qty() const;
  inline void clear_max_open_short_qty();
  static const int kMaxOpenShortQtyFieldNumber = 6;
  inline const ::std::string& max_open_short_qty() const;
  inline void set_max_open_short_qty(const ::std::string& value);
  inline void set_max_open_short_qty(const char* value);
  inline void set_max_open_short_qty(const char* value, size_t size);
  inline ::std::string* mutable_max_open_short_qty();
  inline ::std::string* release_max_open_short_qty();
  
  // optional string max_release_qty = 7 [default = "0"];
  inline bool has_max_release_qty() const;
  inline void clear_max_release_qty();
  static const int kMaxReleaseQtyFieldNumber = 7;
  inline const ::std::string& max_release_qty() const;
  inline void set_max_release_qty(const ::std::string& value);
  inline void set_max_release_qty(const char* value);
  inline void set_max_release_qty(const char* value, size_t size);
  inline ::std::string* mutable_max_release_qty();
  inline ::std::string* release_max_release_qty();
  
  // optional string is_active = 8 [default = "0"];
  inline bool has_is_active() const;
  inline void clear_is_active();
  static const int kIsActiveFieldNumber = 8;
  inline const ::std::string& is_active() const;
  inline void set_is_active(const ::std::string& value);
  inline void set_is_active(const char* value);
  inline void set_is_active(const char* value, size_t size);
  inline ::std::string* mutable_is_active();
  inline ::std::string* release_is_active();
  
  // optional string added_datetime = 9;
  inline bool has_added_datetime() const;
  inline void clear_added_datetime();
  static const int kAddedDatetimeFieldNumber = 9;
  inline const ::std::string& added_datetime() const;
  inline void set_added_datetime(const ::std::string& value);
  inline void set_added_datetime(const char* value);
  inline void set_added_datetime(const char* value, size_t size);
  inline ::std::string* mutable_added_datetime();
  inline ::std::string* release_added_datetime();
  
  // optional string added_by = 10;
  inline bool has_added_by() const;
  inline void clear_added_by();
  static const int kAddedByFieldNumber = 10;
  inline const ::std::string& added_by() const;
  inline void set_added_by(const ::std::string& value);
  inline void set_added_by(const char* value);
  inline void set_added_by(const char* value, size_t size);
  inline ::std::string* mutable_added_by();
  inline ::std::string* release_added_by();
  
  // optional string updated_datetime = 11;
  inline bool has_updated_datetime() const;
  inline void clear_updated_datetime();
  static const int kUpdatedDatetimeFieldNumber = 11;
  inline const ::std::string& updated_datetime() const;
  inline void set_updated_datetime(const ::std::string& value);
  inline void set_updated_datetime(const char* value);
  inline void set_updated_datetime(const char* value, size_t size);
  inline ::std::string* mutable_updated_datetime();
  inline ::std::string* release_updated_datetime();
  
  // optional string updated_by = 12;
  inline bool has_updated_by() const;
  inline void clear_updated_by();
  static const int kUpdatedByFieldNumber = 12;
  inline const ::std::string& updated_by() const;
  inline void set_updated_by(const ::std::string& value);
  inline void set_updated_by(const char* value);
  inline void set_updated_by(const char* value, size_t size);
  inline ::std::string* mutable_updated_by();
  inline ::std::string* release_updated_by();
  
  // @@protoc_insertion_point(class_scope:quantmodel.AccountLimitData)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_security_exchange();
  inline void clear_has_security_exchange();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_max_open_long_qty();
  inline void clear_has_max_open_long_qty();
  inline void set_has_max_open_short_qty();
  inline void clear_has_max_open_short_qty();
  inline void set_has_max_release_qty();
  inline void clear_has_max_release_qty();
  inline void set_has_is_active();
  inline void clear_has_is_active();
  inline void set_has_added_datetime();
  inline void clear_has_added_datetime();
  inline void set_has_added_by();
  inline void clear_has_added_by();
  inline void set_has_updated_datetime();
  inline void clear_has_updated_datetime();
  inline void set_has_updated_by();
  inline void clear_has_updated_by();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* account_id_;
  ::std::string* symbol_;
  ::std::string* security_exchange_;
  ::std::string* session_id_;
  ::std::string* max_open_long_qty_;
  static const ::std::string _default_max_open_long_qty_;
  ::std::string* max_open_short_qty_;
  static const ::std::string _default_max_open_short_qty_;
  ::std::string* max_release_qty_;
  static const ::std::string _default_max_release_qty_;
  ::std::string* is_active_;
  static const ::std::string _default_is_active_;
  ::std::string* added_datetime_;
  ::std::string* added_by_;
  ::std::string* updated_datetime_;
  ::std::string* updated_by_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static AccountLimitData* default_instance_;
};
// -------------------------------------------------------------------

class DraftOrderData : public ::google::protobuf::Message {
 public:
  DraftOrderData();
  virtual ~DraftOrderData();
  
  DraftOrderData(const DraftOrderData& from);
  
  inline DraftOrderData& operator=(const DraftOrderData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DraftOrderData& default_instance();
  
  void Swap(DraftOrderData* other);
  
  // implements Message ----------------------------------------------
  
  DraftOrderData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DraftOrderData& from);
  void MergeFrom(const DraftOrderData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef DraftOrderData_SideCode SideCode;
  static const SideCode BUY = DraftOrderData_SideCode_BUY;
  static const SideCode SELL = DraftOrderData_SideCode_SELL;
  static inline bool SideCode_IsValid(int value) {
    return DraftOrderData_SideCode_IsValid(value);
  }
  static const SideCode SideCode_MIN =
    DraftOrderData_SideCode_SideCode_MIN;
  static const SideCode SideCode_MAX =
    DraftOrderData_SideCode_SideCode_MAX;
  static const int SideCode_ARRAYSIZE =
    DraftOrderData_SideCode_SideCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SideCode_descriptor() {
    return DraftOrderData_SideCode_descriptor();
  }
  static inline const ::std::string& SideCode_Name(SideCode value) {
    return DraftOrderData_SideCode_Name(value);
  }
  static inline bool SideCode_Parse(const ::std::string& name,
      SideCode* value) {
    return DraftOrderData_SideCode_Parse(name, value);
  }
  
  typedef DraftOrderData_OrderType OrderType;
  static const OrderType MARKET = DraftOrderData_OrderType_MARKET;
  static const OrderType LIMIT = DraftOrderData_OrderType_LIMIT;
  static const OrderType STOP = DraftOrderData_OrderType_STOP;
  static const OrderType STOP_LIMIT = DraftOrderData_OrderType_STOP_LIMIT;
  static const OrderType MARKET_ON_CLOSE = DraftOrderData_OrderType_MARKET_ON_CLOSE;
  static const OrderType MARKET_LIMIT = DraftOrderData_OrderType_MARKET_LIMIT;
  static inline bool OrderType_IsValid(int value) {
    return DraftOrderData_OrderType_IsValid(value);
  }
  static const OrderType OrderType_MIN =
    DraftOrderData_OrderType_OrderType_MIN;
  static const OrderType OrderType_MAX =
    DraftOrderData_OrderType_OrderType_MAX;
  static const int OrderType_ARRAYSIZE =
    DraftOrderData_OrderType_OrderType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OrderType_descriptor() {
    return DraftOrderData_OrderType_descriptor();
  }
  static inline const ::std::string& OrderType_Name(OrderType value) {
    return DraftOrderData_OrderType_Name(value);
  }
  static inline bool OrderType_Parse(const ::std::string& name,
      OrderType* value) {
    return DraftOrderData_OrderType_Parse(name, value);
  }
  
  typedef DraftOrderData_TimeInForce TimeInForce;
  static const TimeInForce DAY = DraftOrderData_TimeInForce_DAY;
  static const TimeInForce GTC = DraftOrderData_TimeInForce_GTC;
  static const TimeInForce OPG = DraftOrderData_TimeInForce_OPG;
  static const TimeInForce IOC = DraftOrderData_TimeInForce_IOC;
  static const TimeInForce FOK = DraftOrderData_TimeInForce_FOK;
  static const TimeInForce GTD = DraftOrderData_TimeInForce_GTD;
  static const TimeInForce GIS = DraftOrderData_TimeInForce_GIS;
  static inline bool TimeInForce_IsValid(int value) {
    return DraftOrderData_TimeInForce_IsValid(value);
  }
  static const TimeInForce TimeInForce_MIN =
    DraftOrderData_TimeInForce_TimeInForce_MIN;
  static const TimeInForce TimeInForce_MAX =
    DraftOrderData_TimeInForce_TimeInForce_MAX;
  static const int TimeInForce_ARRAYSIZE =
    DraftOrderData_TimeInForce_TimeInForce_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TimeInForce_descriptor() {
    return DraftOrderData_TimeInForce_descriptor();
  }
  static inline const ::std::string& TimeInForce_Name(TimeInForce value) {
    return DraftOrderData_TimeInForce_Name(value);
  }
  static inline bool TimeInForce_Parse(const ::std::string& name,
      TimeInForce* value) {
    return DraftOrderData_TimeInForce_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string external_order_id = 1;
  inline bool has_external_order_id() const;
  inline void clear_external_order_id();
  static const int kExternalOrderIdFieldNumber = 1;
  inline const ::std::string& external_order_id() const;
  inline void set_external_order_id(const ::std::string& value);
  inline void set_external_order_id(const char* value);
  inline void set_external_order_id(const char* value, size_t size);
  inline ::std::string* mutable_external_order_id();
  inline ::std::string* release_external_order_id();
  
  // optional string investment_system_id = 2;
  inline bool has_investment_system_id() const;
  inline void clear_investment_system_id();
  static const int kInvestmentSystemIdFieldNumber = 2;
  inline const ::std::string& investment_system_id() const;
  inline void set_investment_system_id(const ::std::string& value);
  inline void set_investment_system_id(const char* value);
  inline void set_investment_system_id(const char* value, size_t size);
  inline ::std::string* mutable_investment_system_id();
  inline ::std::string* release_investment_system_id();
  
  // optional string instrument_id = 3;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 3;
  inline const ::std::string& instrument_id() const;
  inline void set_instrument_id(const ::std::string& value);
  inline void set_instrument_id(const char* value);
  inline void set_instrument_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_id();
  inline ::std::string* release_instrument_id();
  
  // optional .quantmodel.DraftOrderData.SideCode side_code = 4;
  inline bool has_side_code() const;
  inline void clear_side_code();
  static const int kSideCodeFieldNumber = 4;
  inline ::quantmodel::DraftOrderData_SideCode side_code() const;
  inline void set_side_code(::quantmodel::DraftOrderData_SideCode value);
  
  // optional .quantmodel.DraftOrderData.TimeInForce tif = 5;
  inline bool has_tif() const;
  inline void clear_tif();
  static const int kTifFieldNumber = 5;
  inline ::quantmodel::DraftOrderData_TimeInForce tif() const;
  inline void set_tif(::quantmodel::DraftOrderData_TimeInForce value);
  
  // optional .quantmodel.DraftOrderData.OrderType order_type = 6;
  inline bool has_order_type() const;
  inline void clear_order_type();
  static const int kOrderTypeFieldNumber = 6;
  inline ::quantmodel::DraftOrderData_OrderType order_type() const;
  inline void set_order_type(::quantmodel::DraftOrderData_OrderType value);
  
  // optional string order_qty = 7 [default = "0"];
  inline bool has_order_qty() const;
  inline void clear_order_qty();
  static const int kOrderQtyFieldNumber = 7;
  inline const ::std::string& order_qty() const;
  inline void set_order_qty(const ::std::string& value);
  inline void set_order_qty(const char* value);
  inline void set_order_qty(const char* value, size_t size);
  inline ::std::string* mutable_order_qty();
  inline ::std::string* release_order_qty();
  
  // optional string limit_prc = 8 [default = "0"];
  inline bool has_limit_prc() const;
  inline void clear_limit_prc();
  static const int kLimitPrcFieldNumber = 8;
  inline const ::std::string& limit_prc() const;
  inline void set_limit_prc(const ::std::string& value);
  inline void set_limit_prc(const char* value);
  inline void set_limit_prc(const char* value, size_t size);
  inline ::std::string* mutable_limit_prc();
  inline ::std::string* release_limit_prc();
  
  // optional string stop_prc = 9 [default = "0"];
  inline bool has_stop_prc() const;
  inline void clear_stop_prc();
  static const int kStopPrcFieldNumber = 9;
  inline const ::std::string& stop_prc() const;
  inline void set_stop_prc(const ::std::string& value);
  inline void set_stop_prc(const char* value);
  inline void set_stop_prc(const char* value, size_t size);
  inline ::std::string* mutable_stop_prc();
  inline ::std::string* release_stop_prc();
  
  // @@protoc_insertion_point(class_scope:quantmodel.DraftOrderData)
 private:
  inline void set_has_external_order_id();
  inline void clear_has_external_order_id();
  inline void set_has_investment_system_id();
  inline void clear_has_investment_system_id();
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_side_code();
  inline void clear_has_side_code();
  inline void set_has_tif();
  inline void clear_has_tif();
  inline void set_has_order_type();
  inline void clear_has_order_type();
  inline void set_has_order_qty();
  inline void clear_has_order_qty();
  inline void set_has_limit_prc();
  inline void clear_has_limit_prc();
  inline void set_has_stop_prc();
  inline void clear_has_stop_prc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* external_order_id_;
  ::std::string* investment_system_id_;
  ::std::string* instrument_id_;
  int side_code_;
  int tif_;
  ::std::string* order_qty_;
  static const ::std::string _default_order_qty_;
  ::std::string* limit_prc_;
  static const ::std::string _default_limit_prc_;
  ::std::string* stop_prc_;
  static const ::std::string _default_stop_prc_;
  int order_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static DraftOrderData* default_instance_;
};
// -------------------------------------------------------------------

class DraftAllocationData : public ::google::protobuf::Message {
 public:
  DraftAllocationData();
  virtual ~DraftAllocationData();
  
  DraftAllocationData(const DraftAllocationData& from);
  
  inline DraftAllocationData& operator=(const DraftAllocationData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DraftAllocationData& default_instance();
  
  void Swap(DraftAllocationData* other);
  
  // implements Message ----------------------------------------------
  
  DraftAllocationData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DraftAllocationData& from);
  void MergeFrom(const DraftAllocationData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline const ::std::string& account_id() const;
  inline void set_account_id(const ::std::string& value);
  inline void set_account_id(const char* value);
  inline void set_account_id(const char* value, size_t size);
  inline ::std::string* mutable_account_id();
  inline ::std::string* release_account_id();
  
  // optional string allocation_qty = 2 [default = "0"];
  inline bool has_allocation_qty() const;
  inline void clear_allocation_qty();
  static const int kAllocationQtyFieldNumber = 2;
  inline const ::std::string& allocation_qty() const;
  inline void set_allocation_qty(const ::std::string& value);
  inline void set_allocation_qty(const char* value);
  inline void set_allocation_qty(const char* value, size_t size);
  inline ::std::string* mutable_allocation_qty();
  inline ::std::string* release_allocation_qty();
  
  // @@protoc_insertion_point(class_scope:quantmodel.DraftAllocationData)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_allocation_qty();
  inline void clear_has_allocation_qty();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* account_id_;
  ::std::string* allocation_qty_;
  static const ::std::string _default_allocation_qty_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static DraftAllocationData* default_instance_;
};
// -------------------------------------------------------------------

class AccountData : public ::google::protobuf::Message {
 public:
  AccountData();
  virtual ~AccountData();
  
  AccountData(const AccountData& from);
  
  inline AccountData& operator=(const AccountData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountData& default_instance();
  
  void Swap(AccountData* other);
  
  // implements Message ----------------------------------------------
  
  AccountData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountData& from);
  void MergeFrom(const AccountData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline const ::std::string& account_id() const;
  inline void set_account_id(const ::std::string& value);
  inline void set_account_id(const char* value);
  inline void set_account_id(const char* value, size_t size);
  inline ::std::string* mutable_account_id();
  inline ::std::string* release_account_id();
  
  // optional string parent_account_id = 2;
  inline bool has_parent_account_id() const;
  inline void clear_parent_account_id();
  static const int kParentAccountIdFieldNumber = 2;
  inline const ::std::string& parent_account_id() const;
  inline void set_parent_account_id(const ::std::string& value);
  inline void set_parent_account_id(const char* value);
  inline void set_parent_account_id(const char* value, size_t size);
  inline ::std::string* mutable_parent_account_id();
  inline ::std::string* release_parent_account_id();
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string market_account_id = 4;
  inline bool has_market_account_id() const;
  inline void clear_market_account_id();
  static const int kMarketAccountIdFieldNumber = 4;
  inline const ::std::string& market_account_id() const;
  inline void set_market_account_id(const ::std::string& value);
  inline void set_market_account_id(const char* value);
  inline void set_market_account_id(const char* value, size_t size);
  inline ::std::string* mutable_market_account_id();
  inline ::std::string* release_market_account_id();
  
  // optional string custody_account_id = 5;
  inline bool has_custody_account_id() const;
  inline void clear_custody_account_id();
  static const int kCustodyAccountIdFieldNumber = 5;
  inline const ::std::string& custody_account_id() const;
  inline void set_custody_account_id(const ::std::string& value);
  inline void set_custody_account_id(const char* value);
  inline void set_custody_account_id(const char* value, size_t size);
  inline ::std::string* mutable_custody_account_id();
  inline ::std::string* release_custody_account_id();
  
  // optional string giveup_account_id = 6;
  inline bool has_giveup_account_id() const;
  inline void clear_giveup_account_id();
  static const int kGiveupAccountIdFieldNumber = 6;
  inline const ::std::string& giveup_account_id() const;
  inline void set_giveup_account_id(const ::std::string& value);
  inline void set_giveup_account_id(const char* value);
  inline void set_giveup_account_id(const char* value, size_t size);
  inline ::std::string* mutable_giveup_account_id();
  inline ::std::string* release_giveup_account_id();
  
  // optional string giveup_firm_id = 7;
  inline bool has_giveup_firm_id() const;
  inline void clear_giveup_firm_id();
  static const int kGiveupFirmIdFieldNumber = 7;
  inline const ::std::string& giveup_firm_id() const;
  inline void set_giveup_firm_id(const ::std::string& value);
  inline void set_giveup_firm_id(const char* value);
  inline void set_giveup_firm_id(const char* value, size_t size);
  inline ::std::string* mutable_giveup_firm_id();
  inline ::std::string* release_giveup_firm_id();
  
  // optional string notional_val = 8;
  inline bool has_notional_val() const;
  inline void clear_notional_val();
  static const int kNotionalValFieldNumber = 8;
  inline const ::std::string& notional_val() const;
  inline void set_notional_val(const ::std::string& value);
  inline void set_notional_val(const char* value);
  inline void set_notional_val(const char* value, size_t size);
  inline ::std::string* mutable_notional_val();
  inline ::std::string* release_notional_val();
  
  // optional string profit_target = 9;
  inline bool has_profit_target() const;
  inline void clear_profit_target();
  static const int kProfitTargetFieldNumber = 9;
  inline const ::std::string& profit_target() const;
  inline void set_profit_target(const ::std::string& value);
  inline void set_profit_target(const char* value);
  inline void set_profit_target(const char* value, size_t size);
  inline ::std::string* mutable_profit_target();
  inline ::std::string* release_profit_target();
  
  // optional string stop_loss = 10;
  inline bool has_stop_loss() const;
  inline void clear_stop_loss();
  static const int kStopLossFieldNumber = 10;
  inline const ::std::string& stop_loss() const;
  inline void set_stop_loss(const ::std::string& value);
  inline void set_stop_loss(const char* value);
  inline void set_stop_loss(const char* value, size_t size);
  inline ::std::string* mutable_stop_loss();
  inline ::std::string* release_stop_loss();
  
  // optional string signal_weight = 11;
  inline bool has_signal_weight() const;
  inline void clear_signal_weight();
  static const int kSignalWeightFieldNumber = 11;
  inline const ::std::string& signal_weight() const;
  inline void set_signal_weight(const ::std::string& value);
  inline void set_signal_weight(const char* value);
  inline void set_signal_weight(const char* value, size_t size);
  inline ::std::string* mutable_signal_weight();
  inline ::std::string* release_signal_weight();
  
  // optional string is_suppressed = 12;
  inline bool has_is_suppressed() const;
  inline void clear_is_suppressed();
  static const int kIsSuppressedFieldNumber = 12;
  inline const ::std::string& is_suppressed() const;
  inline void set_is_suppressed(const ::std::string& value);
  inline void set_is_suppressed(const char* value);
  inline void set_is_suppressed(const char* value, size_t size);
  inline ::std::string* mutable_is_suppressed();
  inline ::std::string* release_is_suppressed();
  
  // optional string is_active = 13;
  inline bool has_is_active() const;
  inline void clear_is_active();
  static const int kIsActiveFieldNumber = 13;
  inline const ::std::string& is_active() const;
  inline void set_is_active(const ::std::string& value);
  inline void set_is_active(const char* value);
  inline void set_is_active(const char* value, size_t size);
  inline ::std::string* mutable_is_active();
  inline ::std::string* release_is_active();
  
  // optional string contact_name = 14;
  inline bool has_contact_name() const;
  inline void clear_contact_name();
  static const int kContactNameFieldNumber = 14;
  inline const ::std::string& contact_name() const;
  inline void set_contact_name(const ::std::string& value);
  inline void set_contact_name(const char* value);
  inline void set_contact_name(const char* value, size_t size);
  inline ::std::string* mutable_contact_name();
  inline ::std::string* release_contact_name();
  
  // optional string contact_email = 15;
  inline bool has_contact_email() const;
  inline void clear_contact_email();
  static const int kContactEmailFieldNumber = 15;
  inline const ::std::string& contact_email() const;
  inline void set_contact_email(const ::std::string& value);
  inline void set_contact_email(const char* value);
  inline void set_contact_email(const char* value, size_t size);
  inline ::std::string* mutable_contact_email();
  inline ::std::string* release_contact_email();
  
  // optional string contact_phone = 16;
  inline bool has_contact_phone() const;
  inline void clear_contact_phone();
  static const int kContactPhoneFieldNumber = 16;
  inline const ::std::string& contact_phone() const;
  inline void set_contact_phone(const ::std::string& value);
  inline void set_contact_phone(const char* value);
  inline void set_contact_phone(const char* value, size_t size);
  inline ::std::string* mutable_contact_phone();
  inline ::std::string* release_contact_phone();
  
  // optional string trading_firm_name = 17;
  inline bool has_trading_firm_name() const;
  inline void clear_trading_firm_name();
  static const int kTradingFirmNameFieldNumber = 17;
  inline const ::std::string& trading_firm_name() const;
  inline void set_trading_firm_name(const ::std::string& value);
  inline void set_trading_firm_name(const char* value);
  inline void set_trading_firm_name(const char* value, size_t size);
  inline ::std::string* mutable_trading_firm_name();
  inline ::std::string* release_trading_firm_name();
  
  // optional string trading_firm_email = 18;
  inline bool has_trading_firm_email() const;
  inline void clear_trading_firm_email();
  static const int kTradingFirmEmailFieldNumber = 18;
  inline const ::std::string& trading_firm_email() const;
  inline void set_trading_firm_email(const ::std::string& value);
  inline void set_trading_firm_email(const char* value);
  inline void set_trading_firm_email(const char* value, size_t size);
  inline ::std::string* mutable_trading_firm_email();
  inline ::std::string* release_trading_firm_email();
  
  // optional string trading_firm_phone = 19;
  inline bool has_trading_firm_phone() const;
  inline void clear_trading_firm_phone();
  static const int kTradingFirmPhoneFieldNumber = 19;
  inline const ::std::string& trading_firm_phone() const;
  inline void set_trading_firm_phone(const ::std::string& value);
  inline void set_trading_firm_phone(const char* value);
  inline void set_trading_firm_phone(const char* value, size_t size);
  inline ::std::string* mutable_trading_firm_phone();
  inline ::std::string* release_trading_firm_phone();
  
  // optional string added_datetime = 20;
  inline bool has_added_datetime() const;
  inline void clear_added_datetime();
  static const int kAddedDatetimeFieldNumber = 20;
  inline const ::std::string& added_datetime() const;
  inline void set_added_datetime(const ::std::string& value);
  inline void set_added_datetime(const char* value);
  inline void set_added_datetime(const char* value, size_t size);
  inline ::std::string* mutable_added_datetime();
  inline ::std::string* release_added_datetime();
  
  // optional string added_by = 21;
  inline bool has_added_by() const;
  inline void clear_added_by();
  static const int kAddedByFieldNumber = 21;
  inline const ::std::string& added_by() const;
  inline void set_added_by(const ::std::string& value);
  inline void set_added_by(const char* value);
  inline void set_added_by(const char* value, size_t size);
  inline ::std::string* mutable_added_by();
  inline ::std::string* release_added_by();
  
  // optional string updated_datetime = 22;
  inline bool has_updated_datetime() const;
  inline void clear_updated_datetime();
  static const int kUpdatedDatetimeFieldNumber = 22;
  inline const ::std::string& updated_datetime() const;
  inline void set_updated_datetime(const ::std::string& value);
  inline void set_updated_datetime(const char* value);
  inline void set_updated_datetime(const char* value, size_t size);
  inline ::std::string* mutable_updated_datetime();
  inline ::std::string* release_updated_datetime();
  
  // optional string updated_by = 23;
  inline bool has_updated_by() const;
  inline void clear_updated_by();
  static const int kUpdatedByFieldNumber = 23;
  inline const ::std::string& updated_by() const;
  inline void set_updated_by(const ::std::string& value);
  inline void set_updated_by(const char* value);
  inline void set_updated_by(const char* value, size_t size);
  inline ::std::string* mutable_updated_by();
  inline ::std::string* release_updated_by();
  
  // @@protoc_insertion_point(class_scope:quantmodel.AccountData)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_parent_account_id();
  inline void clear_has_parent_account_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_market_account_id();
  inline void clear_has_market_account_id();
  inline void set_has_custody_account_id();
  inline void clear_has_custody_account_id();
  inline void set_has_giveup_account_id();
  inline void clear_has_giveup_account_id();
  inline void set_has_giveup_firm_id();
  inline void clear_has_giveup_firm_id();
  inline void set_has_notional_val();
  inline void clear_has_notional_val();
  inline void set_has_profit_target();
  inline void clear_has_profit_target();
  inline void set_has_stop_loss();
  inline void clear_has_stop_loss();
  inline void set_has_signal_weight();
  inline void clear_has_signal_weight();
  inline void set_has_is_suppressed();
  inline void clear_has_is_suppressed();
  inline void set_has_is_active();
  inline void clear_has_is_active();
  inline void set_has_contact_name();
  inline void clear_has_contact_name();
  inline void set_has_contact_email();
  inline void clear_has_contact_email();
  inline void set_has_contact_phone();
  inline void clear_has_contact_phone();
  inline void set_has_trading_firm_name();
  inline void clear_has_trading_firm_name();
  inline void set_has_trading_firm_email();
  inline void clear_has_trading_firm_email();
  inline void set_has_trading_firm_phone();
  inline void clear_has_trading_firm_phone();
  inline void set_has_added_datetime();
  inline void clear_has_added_datetime();
  inline void set_has_added_by();
  inline void clear_has_added_by();
  inline void set_has_updated_datetime();
  inline void clear_has_updated_datetime();
  inline void set_has_updated_by();
  inline void clear_has_updated_by();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* account_id_;
  ::std::string* parent_account_id_;
  ::std::string* name_;
  ::std::string* market_account_id_;
  ::std::string* custody_account_id_;
  ::std::string* giveup_account_id_;
  ::std::string* giveup_firm_id_;
  ::std::string* notional_val_;
  ::std::string* profit_target_;
  ::std::string* stop_loss_;
  ::std::string* signal_weight_;
  ::std::string* is_suppressed_;
  ::std::string* is_active_;
  ::std::string* contact_name_;
  ::std::string* contact_email_;
  ::std::string* contact_phone_;
  ::std::string* trading_firm_name_;
  ::std::string* trading_firm_email_;
  ::std::string* trading_firm_phone_;
  ::std::string* added_datetime_;
  ::std::string* added_by_;
  ::std::string* updated_datetime_;
  ::std::string* updated_by_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static AccountData* default_instance_;
};
// -------------------------------------------------------------------

class OrderData : public ::google::protobuf::Message {
 public:
  OrderData();
  virtual ~OrderData();
  
  OrderData(const OrderData& from);
  
  inline OrderData& operator=(const OrderData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderData& default_instance();
  
  void Swap(OrderData* other);
  
  // implements Message ----------------------------------------------
  
  OrderData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderData& from);
  void MergeFrom(const OrderData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef OrderData_SideCode SideCode;
  static const SideCode BUY = OrderData_SideCode_BUY;
  static const SideCode SELL = OrderData_SideCode_SELL;
  static inline bool SideCode_IsValid(int value) {
    return OrderData_SideCode_IsValid(value);
  }
  static const SideCode SideCode_MIN =
    OrderData_SideCode_SideCode_MIN;
  static const SideCode SideCode_MAX =
    OrderData_SideCode_SideCode_MAX;
  static const int SideCode_ARRAYSIZE =
    OrderData_SideCode_SideCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SideCode_descriptor() {
    return OrderData_SideCode_descriptor();
  }
  static inline const ::std::string& SideCode_Name(SideCode value) {
    return OrderData_SideCode_Name(value);
  }
  static inline bool SideCode_Parse(const ::std::string& name,
      SideCode* value) {
    return OrderData_SideCode_Parse(name, value);
  }
  
  typedef OrderData_OrderType OrderType;
  static const OrderType MARKET = OrderData_OrderType_MARKET;
  static const OrderType LIMIT = OrderData_OrderType_LIMIT;
  static const OrderType STOP = OrderData_OrderType_STOP;
  static const OrderType STOP_LIMIT = OrderData_OrderType_STOP_LIMIT;
  static const OrderType MARKET_ON_CLOSE = OrderData_OrderType_MARKET_ON_CLOSE;
  static const OrderType MARKET_LIMIT = OrderData_OrderType_MARKET_LIMIT;
  static inline bool OrderType_IsValid(int value) {
    return OrderData_OrderType_IsValid(value);
  }
  static const OrderType OrderType_MIN =
    OrderData_OrderType_OrderType_MIN;
  static const OrderType OrderType_MAX =
    OrderData_OrderType_OrderType_MAX;
  static const int OrderType_ARRAYSIZE =
    OrderData_OrderType_OrderType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OrderType_descriptor() {
    return OrderData_OrderType_descriptor();
  }
  static inline const ::std::string& OrderType_Name(OrderType value) {
    return OrderData_OrderType_Name(value);
  }
  static inline bool OrderType_Parse(const ::std::string& name,
      OrderType* value) {
    return OrderData_OrderType_Parse(name, value);
  }
  
  typedef OrderData_OrderStatus OrderStatus;
  static const OrderStatus SUPPRESSED = OrderData_OrderStatus_SUPPRESSED;
  static const OrderStatus NEW = OrderData_OrderStatus_NEW;
  static const OrderStatus PENDING_RELEASE = OrderData_OrderStatus_PENDING_RELEASE;
  static const OrderStatus RELEASED = OrderData_OrderStatus_RELEASED;
  static const OrderStatus PARTIALLY_FILLED = OrderData_OrderStatus_PARTIALLY_FILLED;
  static const OrderStatus FILLED = OrderData_OrderStatus_FILLED;
  static const OrderStatus CANCELED = OrderData_OrderStatus_CANCELED;
  static const OrderStatus CLOSED = OrderData_OrderStatus_CLOSED;
  static inline bool OrderStatus_IsValid(int value) {
    return OrderData_OrderStatus_IsValid(value);
  }
  static const OrderStatus OrderStatus_MIN =
    OrderData_OrderStatus_OrderStatus_MIN;
  static const OrderStatus OrderStatus_MAX =
    OrderData_OrderStatus_OrderStatus_MAX;
  static const int OrderStatus_ARRAYSIZE =
    OrderData_OrderStatus_OrderStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OrderStatus_descriptor() {
    return OrderData_OrderStatus_descriptor();
  }
  static inline const ::std::string& OrderStatus_Name(OrderStatus value) {
    return OrderData_OrderStatus_Name(value);
  }
  static inline bool OrderStatus_Parse(const ::std::string& name,
      OrderStatus* value) {
    return OrderData_OrderStatus_Parse(name, value);
  }
  
  typedef OrderData_TimeInForce TimeInForce;
  static const TimeInForce DAY = OrderData_TimeInForce_DAY;
  static const TimeInForce GTC = OrderData_TimeInForce_GTC;
  static const TimeInForce OPG = OrderData_TimeInForce_OPG;
  static const TimeInForce IOC = OrderData_TimeInForce_IOC;
  static const TimeInForce FOK = OrderData_TimeInForce_FOK;
  static const TimeInForce GTD = OrderData_TimeInForce_GTD;
  static const TimeInForce GIS = OrderData_TimeInForce_GIS;
  static inline bool TimeInForce_IsValid(int value) {
    return OrderData_TimeInForce_IsValid(value);
  }
  static const TimeInForce TimeInForce_MIN =
    OrderData_TimeInForce_TimeInForce_MIN;
  static const TimeInForce TimeInForce_MAX =
    OrderData_TimeInForce_TimeInForce_MAX;
  static const int TimeInForce_ARRAYSIZE =
    OrderData_TimeInForce_TimeInForce_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TimeInForce_descriptor() {
    return OrderData_TimeInForce_descriptor();
  }
  static inline const ::std::string& TimeInForce_Name(TimeInForce value) {
    return OrderData_TimeInForce_Name(value);
  }
  static inline bool TimeInForce_Parse(const ::std::string& name,
      TimeInForce* value) {
    return OrderData_TimeInForce_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string order_id = 1;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 1;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  
  // optional string external_order_id = 2;
  inline bool has_external_order_id() const;
  inline void clear_external_order_id();
  static const int kExternalOrderIdFieldNumber = 2;
  inline const ::std::string& external_order_id() const;
  inline void set_external_order_id(const ::std::string& value);
  inline void set_external_order_id(const char* value);
  inline void set_external_order_id(const char* value, size_t size);
  inline ::std::string* mutable_external_order_id();
  inline ::std::string* release_external_order_id();
  
  // optional string investment_system_id = 3;
  inline bool has_investment_system_id() const;
  inline void clear_investment_system_id();
  static const int kInvestmentSystemIdFieldNumber = 3;
  inline const ::std::string& investment_system_id() const;
  inline void set_investment_system_id(const ::std::string& value);
  inline void set_investment_system_id(const char* value);
  inline void set_investment_system_id(const char* value, size_t size);
  inline ::std::string* mutable_investment_system_id();
  inline ::std::string* release_investment_system_id();
  
  // optional string order_type = 4;
  inline bool has_order_type() const;
  inline void clear_order_type();
  static const int kOrderTypeFieldNumber = 4;
  inline const ::std::string& order_type() const;
  inline void set_order_type(const ::std::string& value);
  inline void set_order_type(const char* value);
  inline void set_order_type(const char* value, size_t size);
  inline ::std::string* mutable_order_type();
  inline ::std::string* release_order_type();
  
  // optional string order_status = 5;
  inline bool has_order_status() const;
  inline void clear_order_status();
  static const int kOrderStatusFieldNumber = 5;
  inline const ::std::string& order_status() const;
  inline void set_order_status(const ::std::string& value);
  inline void set_order_status(const char* value);
  inline void set_order_status(const char* value, size_t size);
  inline ::std::string* mutable_order_status();
  inline ::std::string* release_order_status();
  
  // optional string instrument_id = 6;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 6;
  inline const ::std::string& instrument_id() const;
  inline void set_instrument_id(const ::std::string& value);
  inline void set_instrument_id(const char* value);
  inline void set_instrument_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_id();
  inline ::std::string* release_instrument_id();
  
  // optional string symbol = 7;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 7;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  
  // optional string tif = 8;
  inline bool has_tif() const;
  inline void clear_tif();
  static const int kTifFieldNumber = 8;
  inline const ::std::string& tif() const;
  inline void set_tif(const ::std::string& value);
  inline void set_tif(const char* value);
  inline void set_tif(const char* value, size_t size);
  inline ::std::string* mutable_tif();
  inline ::std::string* release_tif();
  
  // optional string side_code = 9;
  inline bool has_side_code() const;
  inline void clear_side_code();
  static const int kSideCodeFieldNumber = 9;
  inline const ::std::string& side_code() const;
  inline void set_side_code(const ::std::string& value);
  inline void set_side_code(const char* value);
  inline void set_side_code(const char* value, size_t size);
  inline ::std::string* mutable_side_code();
  inline ::std::string* release_side_code();
  
  // optional string base_ccy = 10;
  inline bool has_base_ccy() const;
  inline void clear_base_ccy();
  static const int kBaseCcyFieldNumber = 10;
  inline const ::std::string& base_ccy() const;
  inline void set_base_ccy(const ::std::string& value);
  inline void set_base_ccy(const char* value);
  inline void set_base_ccy(const char* value, size_t size);
  inline ::std::string* mutable_base_ccy();
  inline ::std::string* release_base_ccy();
  
  // optional string order_qty = 11 [default = "0"];
  inline bool has_order_qty() const;
  inline void clear_order_qty();
  static const int kOrderQtyFieldNumber = 11;
  inline const ::std::string& order_qty() const;
  inline void set_order_qty(const ::std::string& value);
  inline void set_order_qty(const char* value);
  inline void set_order_qty(const char* value, size_t size);
  inline ::std::string* mutable_order_qty();
  inline ::std::string* release_order_qty();
  
  // optional string open_qty = 12 [default = "0"];
  inline bool has_open_qty() const;
  inline void clear_open_qty();
  static const int kOpenQtyFieldNumber = 12;
  inline const ::std::string& open_qty() const;
  inline void set_open_qty(const ::std::string& value);
  inline void set_open_qty(const char* value);
  inline void set_open_qty(const char* value, size_t size);
  inline ::std::string* mutable_open_qty();
  inline ::std::string* release_open_qty();
  
  // optional string released_qty = 13 [default = "0"];
  inline bool has_released_qty() const;
  inline void clear_released_qty();
  static const int kReleasedQtyFieldNumber = 13;
  inline const ::std::string& released_qty() const;
  inline void set_released_qty(const ::std::string& value);
  inline void set_released_qty(const char* value);
  inline void set_released_qty(const char* value, size_t size);
  inline ::std::string* mutable_released_qty();
  inline ::std::string* release_released_qty();
  
  // optional string executed_qty = 14 [default = "0"];
  inline bool has_executed_qty() const;
  inline void clear_executed_qty();
  static const int kExecutedQtyFieldNumber = 14;
  inline const ::std::string& executed_qty() const;
  inline void set_executed_qty(const ::std::string& value);
  inline void set_executed_qty(const char* value);
  inline void set_executed_qty(const char* value, size_t size);
  inline ::std::string* mutable_executed_qty();
  inline ::std::string* release_executed_qty();
  
  // optional string limit_prc = 15 [default = "0"];
  inline bool has_limit_prc() const;
  inline void clear_limit_prc();
  static const int kLimitPrcFieldNumber = 15;
  inline const ::std::string& limit_prc() const;
  inline void set_limit_prc(const ::std::string& value);
  inline void set_limit_prc(const char* value);
  inline void set_limit_prc(const char* value, size_t size);
  inline ::std::string* mutable_limit_prc();
  inline ::std::string* release_limit_prc();
  
  // optional string stop_prc = 16 [default = "0"];
  inline bool has_stop_prc() const;
  inline void clear_stop_prc();
  static const int kStopPrcFieldNumber = 16;
  inline const ::std::string& stop_prc() const;
  inline void set_stop_prc(const ::std::string& value);
  inline void set_stop_prc(const char* value);
  inline void set_stop_prc(const char* value, size_t size);
  inline ::std::string* mutable_stop_prc();
  inline ::std::string* release_stop_prc();
  
  // optional string mark_prc = 17 [default = "0"];
  inline bool has_mark_prc() const;
  inline void clear_mark_prc();
  static const int kMarkPrcFieldNumber = 17;
  inline const ::std::string& mark_prc() const;
  inline void set_mark_prc(const ::std::string& value);
  inline void set_mark_prc(const char* value);
  inline void set_mark_prc(const char* value, size_t size);
  inline ::std::string* mutable_mark_prc();
  inline ::std::string* release_mark_prc();
  
  // optional string average_prc = 18 [default = "0"];
  inline bool has_average_prc() const;
  inline void clear_average_prc();
  static const int kAveragePrcFieldNumber = 18;
  inline const ::std::string& average_prc() const;
  inline void set_average_prc(const ::std::string& value);
  inline void set_average_prc(const char* value);
  inline void set_average_prc(const char* value, size_t size);
  inline ::std::string* mutable_average_prc();
  inline ::std::string* release_average_prc();
  
  // optional string entry_prc = 19 [default = "0"];
  inline bool has_entry_prc() const;
  inline void clear_entry_prc();
  static const int kEntryPrcFieldNumber = 19;
  inline const ::std::string& entry_prc() const;
  inline void set_entry_prc(const ::std::string& value);
  inline void set_entry_prc(const char* value);
  inline void set_entry_prc(const char* value, size_t size);
  inline ::std::string* mutable_entry_prc();
  inline ::std::string* release_entry_prc();
  
  // optional string released_val = 20 [default = "0"];
  inline bool has_released_val() const;
  inline void clear_released_val();
  static const int kReleasedValFieldNumber = 20;
  inline const ::std::string& released_val() const;
  inline void set_released_val(const ::std::string& value);
  inline void set_released_val(const char* value);
  inline void set_released_val(const char* value, size_t size);
  inline ::std::string* mutable_released_val();
  inline ::std::string* release_released_val();
  
  // optional string executed_val = 21 [default = "0"];
  inline bool has_executed_val() const;
  inline void clear_executed_val();
  static const int kExecutedValFieldNumber = 21;
  inline const ::std::string& executed_val() const;
  inline void set_executed_val(const ::std::string& value);
  inline void set_executed_val(const char* value);
  inline void set_executed_val(const char* value, size_t size);
  inline ::std::string* mutable_executed_val();
  inline ::std::string* release_executed_val();
  
  // optional string added_datetime = 22;
  inline bool has_added_datetime() const;
  inline void clear_added_datetime();
  static const int kAddedDatetimeFieldNumber = 22;
  inline const ::std::string& added_datetime() const;
  inline void set_added_datetime(const ::std::string& value);
  inline void set_added_datetime(const char* value);
  inline void set_added_datetime(const char* value, size_t size);
  inline ::std::string* mutable_added_datetime();
  inline ::std::string* release_added_datetime();
  
  // optional string added_by = 23;
  inline bool has_added_by() const;
  inline void clear_added_by();
  static const int kAddedByFieldNumber = 23;
  inline const ::std::string& added_by() const;
  inline void set_added_by(const ::std::string& value);
  inline void set_added_by(const char* value);
  inline void set_added_by(const char* value, size_t size);
  inline ::std::string* mutable_added_by();
  inline ::std::string* release_added_by();
  
  // optional string updated_datetime = 24;
  inline bool has_updated_datetime() const;
  inline void clear_updated_datetime();
  static const int kUpdatedDatetimeFieldNumber = 24;
  inline const ::std::string& updated_datetime() const;
  inline void set_updated_datetime(const ::std::string& value);
  inline void set_updated_datetime(const char* value);
  inline void set_updated_datetime(const char* value, size_t size);
  inline ::std::string* mutable_updated_datetime();
  inline ::std::string* release_updated_datetime();
  
  // optional string updated_by = 25;
  inline bool has_updated_by() const;
  inline void clear_updated_by();
  static const int kUpdatedByFieldNumber = 25;
  inline const ::std::string& updated_by() const;
  inline void set_updated_by(const ::std::string& value);
  inline void set_updated_by(const char* value);
  inline void set_updated_by(const char* value, size_t size);
  inline ::std::string* mutable_updated_by();
  inline ::std::string* release_updated_by();
  
  // @@protoc_insertion_point(class_scope:quantmodel.OrderData)
 private:
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_external_order_id();
  inline void clear_has_external_order_id();
  inline void set_has_investment_system_id();
  inline void clear_has_investment_system_id();
  inline void set_has_order_type();
  inline void clear_has_order_type();
  inline void set_has_order_status();
  inline void clear_has_order_status();
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_tif();
  inline void clear_has_tif();
  inline void set_has_side_code();
  inline void clear_has_side_code();
  inline void set_has_base_ccy();
  inline void clear_has_base_ccy();
  inline void set_has_order_qty();
  inline void clear_has_order_qty();
  inline void set_has_open_qty();
  inline void clear_has_open_qty();
  inline void set_has_released_qty();
  inline void clear_has_released_qty();
  inline void set_has_executed_qty();
  inline void clear_has_executed_qty();
  inline void set_has_limit_prc();
  inline void clear_has_limit_prc();
  inline void set_has_stop_prc();
  inline void clear_has_stop_prc();
  inline void set_has_mark_prc();
  inline void clear_has_mark_prc();
  inline void set_has_average_prc();
  inline void clear_has_average_prc();
  inline void set_has_entry_prc();
  inline void clear_has_entry_prc();
  inline void set_has_released_val();
  inline void clear_has_released_val();
  inline void set_has_executed_val();
  inline void clear_has_executed_val();
  inline void set_has_added_datetime();
  inline void clear_has_added_datetime();
  inline void set_has_added_by();
  inline void clear_has_added_by();
  inline void set_has_updated_datetime();
  inline void clear_has_updated_datetime();
  inline void set_has_updated_by();
  inline void clear_has_updated_by();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* order_id_;
  ::std::string* external_order_id_;
  ::std::string* investment_system_id_;
  ::std::string* order_type_;
  ::std::string* order_status_;
  ::std::string* instrument_id_;
  ::std::string* symbol_;
  ::std::string* tif_;
  ::std::string* side_code_;
  ::std::string* base_ccy_;
  ::std::string* order_qty_;
  static const ::std::string _default_order_qty_;
  ::std::string* open_qty_;
  static const ::std::string _default_open_qty_;
  ::std::string* released_qty_;
  static const ::std::string _default_released_qty_;
  ::std::string* executed_qty_;
  static const ::std::string _default_executed_qty_;
  ::std::string* limit_prc_;
  static const ::std::string _default_limit_prc_;
  ::std::string* stop_prc_;
  static const ::std::string _default_stop_prc_;
  ::std::string* mark_prc_;
  static const ::std::string _default_mark_prc_;
  ::std::string* average_prc_;
  static const ::std::string _default_average_prc_;
  ::std::string* entry_prc_;
  static const ::std::string _default_entry_prc_;
  ::std::string* released_val_;
  static const ::std::string _default_released_val_;
  ::std::string* executed_val_;
  static const ::std::string _default_executed_val_;
  ::std::string* added_datetime_;
  ::std::string* added_by_;
  ::std::string* updated_datetime_;
  ::std::string* updated_by_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static OrderData* default_instance_;
};
// -------------------------------------------------------------------

class AllocationData : public ::google::protobuf::Message {
 public:
  AllocationData();
  virtual ~AllocationData();
  
  AllocationData(const AllocationData& from);
  
  inline AllocationData& operator=(const AllocationData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllocationData& default_instance();
  
  void Swap(AllocationData* other);
  
  // implements Message ----------------------------------------------
  
  AllocationData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllocationData& from);
  void MergeFrom(const AllocationData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string allocation_id = 1;
  inline bool has_allocation_id() const;
  inline void clear_allocation_id();
  static const int kAllocationIdFieldNumber = 1;
  inline const ::std::string& allocation_id() const;
  inline void set_allocation_id(const ::std::string& value);
  inline void set_allocation_id(const char* value);
  inline void set_allocation_id(const char* value, size_t size);
  inline ::std::string* mutable_allocation_id();
  inline ::std::string* release_allocation_id();
  
  // optional string order_id = 2;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 2;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  
  // optional string account_id = 3;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 3;
  inline const ::std::string& account_id() const;
  inline void set_account_id(const ::std::string& value);
  inline void set_account_id(const char* value);
  inline void set_account_id(const char* value, size_t size);
  inline ::std::string* mutable_account_id();
  inline ::std::string* release_account_id();
  
  // optional string instrument_id = 4;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 4;
  inline const ::std::string& instrument_id() const;
  inline void set_instrument_id(const ::std::string& value);
  inline void set_instrument_id(const char* value);
  inline void set_instrument_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_id();
  inline ::std::string* release_instrument_id();
  
  // optional string side_code = 5;
  inline bool has_side_code() const;
  inline void clear_side_code();
  static const int kSideCodeFieldNumber = 5;
  inline const ::std::string& side_code() const;
  inline void set_side_code(const ::std::string& value);
  inline void set_side_code(const char* value);
  inline void set_side_code(const char* value, size_t size);
  inline ::std::string* mutable_side_code();
  inline ::std::string* release_side_code();
  
  // optional string allocation_qty = 6 [default = "0"];
  inline bool has_allocation_qty() const;
  inline void clear_allocation_qty();
  static const int kAllocationQtyFieldNumber = 6;
  inline const ::std::string& allocation_qty() const;
  inline void set_allocation_qty(const ::std::string& value);
  inline void set_allocation_qty(const char* value);
  inline void set_allocation_qty(const char* value, size_t size);
  inline ::std::string* mutable_allocation_qty();
  inline ::std::string* release_allocation_qty();
  
  // optional string released_qty = 7 [default = "0"];
  inline bool has_released_qty() const;
  inline void clear_released_qty();
  static const int kReleasedQtyFieldNumber = 7;
  inline const ::std::string& released_qty() const;
  inline void set_released_qty(const ::std::string& value);
  inline void set_released_qty(const char* value);
  inline void set_released_qty(const char* value, size_t size);
  inline ::std::string* mutable_released_qty();
  inline ::std::string* release_released_qty();
  
  // optional string executed_qty = 8 [default = "0"];
  inline bool has_executed_qty() const;
  inline void clear_executed_qty();
  static const int kExecutedQtyFieldNumber = 8;
  inline const ::std::string& executed_qty() const;
  inline void set_executed_qty(const ::std::string& value);
  inline void set_executed_qty(const char* value);
  inline void set_executed_qty(const char* value, size_t size);
  inline ::std::string* mutable_executed_qty();
  inline ::std::string* release_executed_qty();
  
  // optional string executed_val = 9 [default = "0"];
  inline bool has_executed_val() const;
  inline void clear_executed_val();
  static const int kExecutedValFieldNumber = 9;
  inline const ::std::string& executed_val() const;
  inline void set_executed_val(const ::std::string& value);
  inline void set_executed_val(const char* value);
  inline void set_executed_val(const char* value, size_t size);
  inline ::std::string* mutable_executed_val();
  inline ::std::string* release_executed_val();
  
  // optional string average_prc = 10 [default = "0"];
  inline bool has_average_prc() const;
  inline void clear_average_prc();
  static const int kAveragePrcFieldNumber = 10;
  inline const ::std::string& average_prc() const;
  inline void set_average_prc(const ::std::string& value);
  inline void set_average_prc(const char* value);
  inline void set_average_prc(const char* value, size_t size);
  inline ::std::string* mutable_average_prc();
  inline ::std::string* release_average_prc();
  
  // optional string added_datetime = 11;
  inline bool has_added_datetime() const;
  inline void clear_added_datetime();
  static const int kAddedDatetimeFieldNumber = 11;
  inline const ::std::string& added_datetime() const;
  inline void set_added_datetime(const ::std::string& value);
  inline void set_added_datetime(const char* value);
  inline void set_added_datetime(const char* value, size_t size);
  inline ::std::string* mutable_added_datetime();
  inline ::std::string* release_added_datetime();
  
  // optional string added_by = 12;
  inline bool has_added_by() const;
  inline void clear_added_by();
  static const int kAddedByFieldNumber = 12;
  inline const ::std::string& added_by() const;
  inline void set_added_by(const ::std::string& value);
  inline void set_added_by(const char* value);
  inline void set_added_by(const char* value, size_t size);
  inline ::std::string* mutable_added_by();
  inline ::std::string* release_added_by();
  
  // optional string updated_datetime = 13;
  inline bool has_updated_datetime() const;
  inline void clear_updated_datetime();
  static const int kUpdatedDatetimeFieldNumber = 13;
  inline const ::std::string& updated_datetime() const;
  inline void set_updated_datetime(const ::std::string& value);
  inline void set_updated_datetime(const char* value);
  inline void set_updated_datetime(const char* value, size_t size);
  inline ::std::string* mutable_updated_datetime();
  inline ::std::string* release_updated_datetime();
  
  // optional string updated_by = 14;
  inline bool has_updated_by() const;
  inline void clear_updated_by();
  static const int kUpdatedByFieldNumber = 14;
  inline const ::std::string& updated_by() const;
  inline void set_updated_by(const ::std::string& value);
  inline void set_updated_by(const char* value);
  inline void set_updated_by(const char* value, size_t size);
  inline ::std::string* mutable_updated_by();
  inline ::std::string* release_updated_by();
  
  // @@protoc_insertion_point(class_scope:quantmodel.AllocationData)
 private:
  inline void set_has_allocation_id();
  inline void clear_has_allocation_id();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_side_code();
  inline void clear_has_side_code();
  inline void set_has_allocation_qty();
  inline void clear_has_allocation_qty();
  inline void set_has_released_qty();
  inline void clear_has_released_qty();
  inline void set_has_executed_qty();
  inline void clear_has_executed_qty();
  inline void set_has_executed_val();
  inline void clear_has_executed_val();
  inline void set_has_average_prc();
  inline void clear_has_average_prc();
  inline void set_has_added_datetime();
  inline void clear_has_added_datetime();
  inline void set_has_added_by();
  inline void clear_has_added_by();
  inline void set_has_updated_datetime();
  inline void clear_has_updated_datetime();
  inline void set_has_updated_by();
  inline void clear_has_updated_by();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* allocation_id_;
  ::std::string* order_id_;
  ::std::string* account_id_;
  ::std::string* instrument_id_;
  ::std::string* side_code_;
  ::std::string* allocation_qty_;
  static const ::std::string _default_allocation_qty_;
  ::std::string* released_qty_;
  static const ::std::string _default_released_qty_;
  ::std::string* executed_qty_;
  static const ::std::string _default_executed_qty_;
  ::std::string* executed_val_;
  static const ::std::string _default_executed_val_;
  ::std::string* average_prc_;
  static const ::std::string _default_average_prc_;
  ::std::string* added_datetime_;
  ::std::string* added_by_;
  ::std::string* updated_datetime_;
  ::std::string* updated_by_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static AllocationData* default_instance_;
};
// -------------------------------------------------------------------

class ReleaseData : public ::google::protobuf::Message {
 public:
  ReleaseData();
  virtual ~ReleaseData();
  
  ReleaseData(const ReleaseData& from);
  
  inline ReleaseData& operator=(const ReleaseData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReleaseData& default_instance();
  
  void Swap(ReleaseData* other);
  
  // implements Message ----------------------------------------------
  
  ReleaseData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReleaseData& from);
  void MergeFrom(const ReleaseData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string release_id = 1;
  inline bool has_release_id() const;
  inline void clear_release_id();
  static const int kReleaseIdFieldNumber = 1;
  inline const ::std::string& release_id() const;
  inline void set_release_id(const ::std::string& value);
  inline void set_release_id(const char* value);
  inline void set_release_id(const char* value, size_t size);
  inline ::std::string* mutable_release_id();
  inline ::std::string* release_release_id();
  
  // optional string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional string account_id = 3;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 3;
  inline const ::std::string& account_id() const;
  inline void set_account_id(const ::std::string& value);
  inline void set_account_id(const char* value);
  inline void set_account_id(const char* value, size_t size);
  inline ::std::string* mutable_account_id();
  inline ::std::string* release_account_id();
  
  // optional string order_id = 4;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 4;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  
  // optional string allocation_id = 5;
  inline bool has_allocation_id() const;
  inline void clear_allocation_id();
  static const int kAllocationIdFieldNumber = 5;
  inline const ::std::string& allocation_id() const;
  inline void set_allocation_id(const ::std::string& value);
  inline void set_allocation_id(const char* value);
  inline void set_allocation_id(const char* value, size_t size);
  inline ::std::string* mutable_allocation_id();
  inline ::std::string* release_allocation_id();
  
  // optional string investment_system_id = 6;
  inline bool has_investment_system_id() const;
  inline void clear_investment_system_id();
  static const int kInvestmentSystemIdFieldNumber = 6;
  inline const ::std::string& investment_system_id() const;
  inline void set_investment_system_id(const ::std::string& value);
  inline void set_investment_system_id(const char* value);
  inline void set_investment_system_id(const char* value, size_t size);
  inline ::std::string* mutable_investment_system_id();
  inline ::std::string* release_investment_system_id();
  
  // optional string instrument_id = 7;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 7;
  inline const ::std::string& instrument_id() const;
  inline void set_instrument_id(const ::std::string& value);
  inline void set_instrument_id(const char* value);
  inline void set_instrument_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_id();
  inline ::std::string* release_instrument_id();
  
  // optional string compliance_audit_id = 8;
  inline bool has_compliance_audit_id() const;
  inline void clear_compliance_audit_id();
  static const int kComplianceAuditIdFieldNumber = 8;
  inline const ::std::string& compliance_audit_id() const;
  inline void set_compliance_audit_id(const ::std::string& value);
  inline void set_compliance_audit_id(const char* value);
  inline void set_compliance_audit_id(const char* value, size_t size);
  inline ::std::string* mutable_compliance_audit_id();
  inline ::std::string* release_compliance_audit_id();
  
  // optional string client_order_id = 9;
  inline bool has_client_order_id() const;
  inline void clear_client_order_id();
  static const int kClientOrderIdFieldNumber = 9;
  inline const ::std::string& client_order_id() const;
  inline void set_client_order_id(const ::std::string& value);
  inline void set_client_order_id(const char* value);
  inline void set_client_order_id(const char* value, size_t size);
  inline ::std::string* mutable_client_order_id();
  inline ::std::string* release_client_order_id();
  
  // optional string counterparty_order_id = 10;
  inline bool has_counterparty_order_id() const;
  inline void clear_counterparty_order_id();
  static const int kCounterpartyOrderIdFieldNumber = 10;
  inline const ::std::string& counterparty_order_id() const;
  inline void set_counterparty_order_id(const ::std::string& value);
  inline void set_counterparty_order_id(const char* value);
  inline void set_counterparty_order_id(const char* value, size_t size);
  inline ::std::string* mutable_counterparty_order_id();
  inline ::std::string* release_counterparty_order_id();
  
  // optional string release_status = 11;
  inline bool has_release_status() const;
  inline void clear_release_status();
  static const int kReleaseStatusFieldNumber = 11;
  inline const ::std::string& release_status() const;
  inline void set_release_status(const ::std::string& value);
  inline void set_release_status(const char* value);
  inline void set_release_status(const char* value, size_t size);
  inline ::std::string* mutable_release_status();
  inline ::std::string* release_release_status();
  
  // optional string release_type = 12;
  inline bool has_release_type() const;
  inline void clear_release_type();
  static const int kReleaseTypeFieldNumber = 12;
  inline const ::std::string& release_type() const;
  inline void set_release_type(const ::std::string& value);
  inline void set_release_type(const char* value);
  inline void set_release_type(const char* value, size_t size);
  inline ::std::string* mutable_release_type();
  inline ::std::string* release_release_type();
  
  // optional string tif = 13;
  inline bool has_tif() const;
  inline void clear_tif();
  static const int kTifFieldNumber = 13;
  inline const ::std::string& tif() const;
  inline void set_tif(const ::std::string& value);
  inline void set_tif(const char* value);
  inline void set_tif(const char* value, size_t size);
  inline ::std::string* mutable_tif();
  inline ::std::string* release_tif();
  
  // optional string side_code = 14;
  inline bool has_side_code() const;
  inline void clear_side_code();
  static const int kSideCodeFieldNumber = 14;
  inline const ::std::string& side_code() const;
  inline void set_side_code(const ::std::string& value);
  inline void set_side_code(const char* value);
  inline void set_side_code(const char* value, size_t size);
  inline ::std::string* mutable_side_code();
  inline ::std::string* release_side_code();
  
  // optional string release_qty = 15 [default = "0"];
  inline bool has_release_qty() const;
  inline void clear_release_qty();
  static const int kReleaseQtyFieldNumber = 15;
  inline const ::std::string& release_qty() const;
  inline void set_release_qty(const ::std::string& value);
  inline void set_release_qty(const char* value);
  inline void set_release_qty(const char* value, size_t size);
  inline ::std::string* mutable_release_qty();
  inline ::std::string* release_release_qty();
  
  // optional string limit_prc = 16 [default = "0"];
  inline bool has_limit_prc() const;
  inline void clear_limit_prc();
  static const int kLimitPrcFieldNumber = 16;
  inline const ::std::string& limit_prc() const;
  inline void set_limit_prc(const ::std::string& value);
  inline void set_limit_prc(const char* value);
  inline void set_limit_prc(const char* value, size_t size);
  inline ::std::string* mutable_limit_prc();
  inline ::std::string* release_limit_prc();
  
  // optional string stop_prc = 17 [default = "0"];
  inline bool has_stop_prc() const;
  inline void clear_stop_prc();
  static const int kStopPrcFieldNumber = 17;
  inline const ::std::string& stop_prc() const;
  inline void set_stop_prc(const ::std::string& value);
  inline void set_stop_prc(const char* value);
  inline void set_stop_prc(const char* value, size_t size);
  inline ::std::string* mutable_stop_prc();
  inline ::std::string* release_stop_prc();
  
  // optional string average_prc = 18 [default = "0"];
  inline bool has_average_prc() const;
  inline void clear_average_prc();
  static const int kAveragePrcFieldNumber = 18;
  inline const ::std::string& average_prc() const;
  inline void set_average_prc(const ::std::string& value);
  inline void set_average_prc(const char* value);
  inline void set_average_prc(const char* value, size_t size);
  inline ::std::string* mutable_average_prc();
  inline ::std::string* release_average_prc();
  
  // optional string executed_val = 19 [default = "0"];
  inline bool has_executed_val() const;
  inline void clear_executed_val();
  static const int kExecutedValFieldNumber = 19;
  inline const ::std::string& executed_val() const;
  inline void set_executed_val(const ::std::string& value);
  inline void set_executed_val(const char* value);
  inline void set_executed_val(const char* value, size_t size);
  inline ::std::string* mutable_executed_val();
  inline ::std::string* release_executed_val();
  
  // optional string executed_qty = 20 [default = "0"];
  inline bool has_executed_qty() const;
  inline void clear_executed_qty();
  static const int kExecutedQtyFieldNumber = 20;
  inline const ::std::string& executed_qty() const;
  inline void set_executed_qty(const ::std::string& value);
  inline void set_executed_qty(const char* value);
  inline void set_executed_qty(const char* value, size_t size);
  inline ::std::string* mutable_executed_qty();
  inline ::std::string* release_executed_qty();
  
  // optional string added_datetime = 21;
  inline bool has_added_datetime() const;
  inline void clear_added_datetime();
  static const int kAddedDatetimeFieldNumber = 21;
  inline const ::std::string& added_datetime() const;
  inline void set_added_datetime(const ::std::string& value);
  inline void set_added_datetime(const char* value);
  inline void set_added_datetime(const char* value, size_t size);
  inline ::std::string* mutable_added_datetime();
  inline ::std::string* release_added_datetime();
  
  // optional string added_by = 22;
  inline bool has_added_by() const;
  inline void clear_added_by();
  static const int kAddedByFieldNumber = 22;
  inline const ::std::string& added_by() const;
  inline void set_added_by(const ::std::string& value);
  inline void set_added_by(const char* value);
  inline void set_added_by(const char* value, size_t size);
  inline ::std::string* mutable_added_by();
  inline ::std::string* release_added_by();
  
  // optional string updated_datetime = 23;
  inline bool has_updated_datetime() const;
  inline void clear_updated_datetime();
  static const int kUpdatedDatetimeFieldNumber = 23;
  inline const ::std::string& updated_datetime() const;
  inline void set_updated_datetime(const ::std::string& value);
  inline void set_updated_datetime(const char* value);
  inline void set_updated_datetime(const char* value, size_t size);
  inline ::std::string* mutable_updated_datetime();
  inline ::std::string* release_updated_datetime();
  
  // optional string updated_by = 24;
  inline bool has_updated_by() const;
  inline void clear_updated_by();
  static const int kUpdatedByFieldNumber = 24;
  inline const ::std::string& updated_by() const;
  inline void set_updated_by(const ::std::string& value);
  inline void set_updated_by(const char* value);
  inline void set_updated_by(const char* value, size_t size);
  inline ::std::string* mutable_updated_by();
  inline ::std::string* release_updated_by();
  
  // @@protoc_insertion_point(class_scope:quantmodel.ReleaseData)
 private:
  inline void set_has_release_id();
  inline void clear_has_release_id();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_allocation_id();
  inline void clear_has_allocation_id();
  inline void set_has_investment_system_id();
  inline void clear_has_investment_system_id();
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_compliance_audit_id();
  inline void clear_has_compliance_audit_id();
  inline void set_has_client_order_id();
  inline void clear_has_client_order_id();
  inline void set_has_counterparty_order_id();
  inline void clear_has_counterparty_order_id();
  inline void set_has_release_status();
  inline void clear_has_release_status();
  inline void set_has_release_type();
  inline void clear_has_release_type();
  inline void set_has_tif();
  inline void clear_has_tif();
  inline void set_has_side_code();
  inline void clear_has_side_code();
  inline void set_has_release_qty();
  inline void clear_has_release_qty();
  inline void set_has_limit_prc();
  inline void clear_has_limit_prc();
  inline void set_has_stop_prc();
  inline void clear_has_stop_prc();
  inline void set_has_average_prc();
  inline void clear_has_average_prc();
  inline void set_has_executed_val();
  inline void clear_has_executed_val();
  inline void set_has_executed_qty();
  inline void clear_has_executed_qty();
  inline void set_has_added_datetime();
  inline void clear_has_added_datetime();
  inline void set_has_added_by();
  inline void clear_has_added_by();
  inline void set_has_updated_datetime();
  inline void clear_has_updated_datetime();
  inline void set_has_updated_by();
  inline void clear_has_updated_by();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* release_id_;
  ::std::string* session_id_;
  ::std::string* account_id_;
  ::std::string* order_id_;
  ::std::string* allocation_id_;
  ::std::string* investment_system_id_;
  ::std::string* instrument_id_;
  ::std::string* compliance_audit_id_;
  ::std::string* client_order_id_;
  ::std::string* counterparty_order_id_;
  ::std::string* release_status_;
  ::std::string* release_type_;
  ::std::string* tif_;
  ::std::string* side_code_;
  ::std::string* release_qty_;
  static const ::std::string _default_release_qty_;
  ::std::string* limit_prc_;
  static const ::std::string _default_limit_prc_;
  ::std::string* stop_prc_;
  static const ::std::string _default_stop_prc_;
  ::std::string* average_prc_;
  static const ::std::string _default_average_prc_;
  ::std::string* executed_val_;
  static const ::std::string _default_executed_val_;
  ::std::string* executed_qty_;
  static const ::std::string _default_executed_qty_;
  ::std::string* added_datetime_;
  ::std::string* added_by_;
  ::std::string* updated_datetime_;
  ::std::string* updated_by_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(24 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static ReleaseData* default_instance_;
};
// -------------------------------------------------------------------

class ExecutionData : public ::google::protobuf::Message {
 public:
  ExecutionData();
  virtual ~ExecutionData();
  
  ExecutionData(const ExecutionData& from);
  
  inline ExecutionData& operator=(const ExecutionData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutionData& default_instance();
  
  void Swap(ExecutionData* other);
  
  // implements Message ----------------------------------------------
  
  ExecutionData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutionData& from);
  void MergeFrom(const ExecutionData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string execution_id = 1;
  inline bool has_execution_id() const;
  inline void clear_execution_id();
  static const int kExecutionIdFieldNumber = 1;
  inline const ::std::string& execution_id() const;
  inline void set_execution_id(const ::std::string& value);
  inline void set_execution_id(const char* value);
  inline void set_execution_id(const char* value, size_t size);
  inline ::std::string* mutable_execution_id();
  inline ::std::string* release_execution_id();
  
  // optional string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional string account_id = 3;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 3;
  inline const ::std::string& account_id() const;
  inline void set_account_id(const ::std::string& value);
  inline void set_account_id(const char* value);
  inline void set_account_id(const char* value, size_t size);
  inline ::std::string* mutable_account_id();
  inline ::std::string* release_account_id();
  
  // optional string order_id = 4;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 4;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  
  // optional string release_id = 5;
  inline bool has_release_id() const;
  inline void clear_release_id();
  static const int kReleaseIdFieldNumber = 5;
  inline const ::std::string& release_id() const;
  inline void set_release_id(const ::std::string& value);
  inline void set_release_id(const char* value);
  inline void set_release_id(const char* value, size_t size);
  inline ::std::string* mutable_release_id();
  inline ::std::string* release_release_id();
  
  // optional string investment_system_id = 6;
  inline bool has_investment_system_id() const;
  inline void clear_investment_system_id();
  static const int kInvestmentSystemIdFieldNumber = 6;
  inline const ::std::string& investment_system_id() const;
  inline void set_investment_system_id(const ::std::string& value);
  inline void set_investment_system_id(const char* value);
  inline void set_investment_system_id(const char* value, size_t size);
  inline ::std::string* mutable_investment_system_id();
  inline ::std::string* release_investment_system_id();
  
  // optional string instrument_id = 7;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 7;
  inline const ::std::string& instrument_id() const;
  inline void set_instrument_id(const ::std::string& value);
  inline void set_instrument_id(const char* value);
  inline void set_instrument_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_id();
  inline ::std::string* release_instrument_id();
  
  // optional string client_order_id = 8;
  inline bool has_client_order_id() const;
  inline void clear_client_order_id();
  static const int kClientOrderIdFieldNumber = 8;
  inline const ::std::string& client_order_id() const;
  inline void set_client_order_id(const ::std::string& value);
  inline void set_client_order_id(const char* value);
  inline void set_client_order_id(const char* value, size_t size);
  inline ::std::string* mutable_client_order_id();
  inline ::std::string* release_client_order_id();
  
  // optional string counterparty_execution_id = 9;
  inline bool has_counterparty_execution_id() const;
  inline void clear_counterparty_execution_id();
  static const int kCounterpartyExecutionIdFieldNumber = 9;
  inline const ::std::string& counterparty_execution_id() const;
  inline void set_counterparty_execution_id(const ::std::string& value);
  inline void set_counterparty_execution_id(const char* value);
  inline void set_counterparty_execution_id(const char* value, size_t size);
  inline ::std::string* mutable_counterparty_execution_id();
  inline ::std::string* release_counterparty_execution_id();
  
  // optional string side_code = 10;
  inline bool has_side_code() const;
  inline void clear_side_code();
  static const int kSideCodeFieldNumber = 10;
  inline const ::std::string& side_code() const;
  inline void set_side_code(const ::std::string& value);
  inline void set_side_code(const char* value);
  inline void set_side_code(const char* value, size_t size);
  inline ::std::string* mutable_side_code();
  inline ::std::string* release_side_code();
  
  // optional string execution_ccy = 11;
  inline bool has_execution_ccy() const;
  inline void clear_execution_ccy();
  static const int kExecutionCcyFieldNumber = 11;
  inline const ::std::string& execution_ccy() const;
  inline void set_execution_ccy(const ::std::string& value);
  inline void set_execution_ccy(const char* value);
  inline void set_execution_ccy(const char* value, size_t size);
  inline ::std::string* mutable_execution_ccy();
  inline ::std::string* release_execution_ccy();
  
  // optional string execution_status = 12;
  inline bool has_execution_status() const;
  inline void clear_execution_status();
  static const int kExecutionStatusFieldNumber = 12;
  inline const ::std::string& execution_status() const;
  inline void set_execution_status(const ::std::string& value);
  inline void set_execution_status(const char* value);
  inline void set_execution_status(const char* value, size_t size);
  inline ::std::string* mutable_execution_status();
  inline ::std::string* release_execution_status();
  
  // optional string execution_prc = 13 [default = "0"];
  inline bool has_execution_prc() const;
  inline void clear_execution_prc();
  static const int kExecutionPrcFieldNumber = 13;
  inline const ::std::string& execution_prc() const;
  inline void set_execution_prc(const ::std::string& value);
  inline void set_execution_prc(const char* value);
  inline void set_execution_prc(const char* value, size_t size);
  inline ::std::string* mutable_execution_prc();
  inline ::std::string* release_execution_prc();
  
  // optional string execution_qty = 14 [default = "0"];
  inline bool has_execution_qty() const;
  inline void clear_execution_qty();
  static const int kExecutionQtyFieldNumber = 14;
  inline const ::std::string& execution_qty() const;
  inline void set_execution_qty(const ::std::string& value);
  inline void set_execution_qty(const char* value);
  inline void set_execution_qty(const char* value, size_t size);
  inline ::std::string* mutable_execution_qty();
  inline ::std::string* release_execution_qty();
  
  // optional string execution_val = 15 [default = "0"];
  inline bool has_execution_val() const;
  inline void clear_execution_val();
  static const int kExecutionValFieldNumber = 15;
  inline const ::std::string& execution_val() const;
  inline void set_execution_val(const ::std::string& value);
  inline void set_execution_val(const char* value);
  inline void set_execution_val(const char* value, size_t size);
  inline ::std::string* mutable_execution_val();
  inline ::std::string* release_execution_val();
  
  // optional string leaves_qty = 16 [default = "0"];
  inline bool has_leaves_qty() const;
  inline void clear_leaves_qty();
  static const int kLeavesQtyFieldNumber = 16;
  inline const ::std::string& leaves_qty() const;
  inline void set_leaves_qty(const ::std::string& value);
  inline void set_leaves_qty(const char* value);
  inline void set_leaves_qty(const char* value, size_t size);
  inline ::std::string* mutable_leaves_qty();
  inline ::std::string* release_leaves_qty();
  
  // optional string average_prc = 17 [default = "0"];
  inline bool has_average_prc() const;
  inline void clear_average_prc();
  static const int kAveragePrcFieldNumber = 17;
  inline const ::std::string& average_prc() const;
  inline void set_average_prc(const ::std::string& value);
  inline void set_average_prc(const char* value);
  inline void set_average_prc(const char* value, size_t size);
  inline ::std::string* mutable_average_prc();
  inline ::std::string* release_average_prc();
  
  // optional string leg_type = 18 [default = "1"];
  inline bool has_leg_type() const;
  inline void clear_leg_type();
  static const int kLegTypeFieldNumber = 18;
  inline const ::std::string& leg_type() const;
  inline void set_leg_type(const ::std::string& value);
  inline void set_leg_type(const char* value);
  inline void set_leg_type(const char* value, size_t size);
  inline ::std::string* mutable_leg_type();
  inline ::std::string* release_leg_type();
  
  // optional string added_datetime = 19;
  inline bool has_added_datetime() const;
  inline void clear_added_datetime();
  static const int kAddedDatetimeFieldNumber = 19;
  inline const ::std::string& added_datetime() const;
  inline void set_added_datetime(const ::std::string& value);
  inline void set_added_datetime(const char* value);
  inline void set_added_datetime(const char* value, size_t size);
  inline ::std::string* mutable_added_datetime();
  inline ::std::string* release_added_datetime();
  
  // optional string added_by = 20;
  inline bool has_added_by() const;
  inline void clear_added_by();
  static const int kAddedByFieldNumber = 20;
  inline const ::std::string& added_by() const;
  inline void set_added_by(const ::std::string& value);
  inline void set_added_by(const char* value);
  inline void set_added_by(const char* value, size_t size);
  inline ::std::string* mutable_added_by();
  inline ::std::string* release_added_by();
  
  // optional string updated_datetime = 21;
  inline bool has_updated_datetime() const;
  inline void clear_updated_datetime();
  static const int kUpdatedDatetimeFieldNumber = 21;
  inline const ::std::string& updated_datetime() const;
  inline void set_updated_datetime(const ::std::string& value);
  inline void set_updated_datetime(const char* value);
  inline void set_updated_datetime(const char* value, size_t size);
  inline ::std::string* mutable_updated_datetime();
  inline ::std::string* release_updated_datetime();
  
  // optional string updated_by = 22;
  inline bool has_updated_by() const;
  inline void clear_updated_by();
  static const int kUpdatedByFieldNumber = 22;
  inline const ::std::string& updated_by() const;
  inline void set_updated_by(const ::std::string& value);
  inline void set_updated_by(const char* value);
  inline void set_updated_by(const char* value, size_t size);
  inline ::std::string* mutable_updated_by();
  inline ::std::string* release_updated_by();
  
  // @@protoc_insertion_point(class_scope:quantmodel.ExecutionData)
 private:
  inline void set_has_execution_id();
  inline void clear_has_execution_id();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_release_id();
  inline void clear_has_release_id();
  inline void set_has_investment_system_id();
  inline void clear_has_investment_system_id();
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_client_order_id();
  inline void clear_has_client_order_id();
  inline void set_has_counterparty_execution_id();
  inline void clear_has_counterparty_execution_id();
  inline void set_has_side_code();
  inline void clear_has_side_code();
  inline void set_has_execution_ccy();
  inline void clear_has_execution_ccy();
  inline void set_has_execution_status();
  inline void clear_has_execution_status();
  inline void set_has_execution_prc();
  inline void clear_has_execution_prc();
  inline void set_has_execution_qty();
  inline void clear_has_execution_qty();
  inline void set_has_execution_val();
  inline void clear_has_execution_val();
  inline void set_has_leaves_qty();
  inline void clear_has_leaves_qty();
  inline void set_has_average_prc();
  inline void clear_has_average_prc();
  inline void set_has_leg_type();
  inline void clear_has_leg_type();
  inline void set_has_added_datetime();
  inline void clear_has_added_datetime();
  inline void set_has_added_by();
  inline void clear_has_added_by();
  inline void set_has_updated_datetime();
  inline void clear_has_updated_datetime();
  inline void set_has_updated_by();
  inline void clear_has_updated_by();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* execution_id_;
  ::std::string* session_id_;
  ::std::string* account_id_;
  ::std::string* order_id_;
  ::std::string* release_id_;
  ::std::string* investment_system_id_;
  ::std::string* instrument_id_;
  ::std::string* client_order_id_;
  ::std::string* counterparty_execution_id_;
  ::std::string* side_code_;
  ::std::string* execution_ccy_;
  ::std::string* execution_status_;
  ::std::string* execution_prc_;
  static const ::std::string _default_execution_prc_;
  ::std::string* execution_qty_;
  static const ::std::string _default_execution_qty_;
  ::std::string* execution_val_;
  static const ::std::string _default_execution_val_;
  ::std::string* leaves_qty_;
  static const ::std::string _default_leaves_qty_;
  ::std::string* average_prc_;
  static const ::std::string _default_average_prc_;
  ::std::string* leg_type_;
  static const ::std::string _default_leg_type_;
  ::std::string* added_datetime_;
  ::std::string* added_by_;
  ::std::string* updated_datetime_;
  ::std::string* updated_by_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static ExecutionData* default_instance_;
};
// -------------------------------------------------------------------

class InstrumentData : public ::google::protobuf::Message {
 public:
  InstrumentData();
  virtual ~InstrumentData();
  
  InstrumentData(const InstrumentData& from);
  
  inline InstrumentData& operator=(const InstrumentData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InstrumentData& default_instance();
  
  void Swap(InstrumentData* other);
  
  // implements Message ----------------------------------------------
  
  InstrumentData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstrumentData& from);
  void MergeFrom(const InstrumentData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string instrument_id = 1;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 1;
  inline const ::std::string& instrument_id() const;
  inline void set_instrument_id(const ::std::string& value);
  inline void set_instrument_id(const char* value);
  inline void set_instrument_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_id();
  inline ::std::string* release_instrument_id();
  
  // optional string instrument_type = 2;
  inline bool has_instrument_type() const;
  inline void clear_instrument_type();
  static const int kInstrumentTypeFieldNumber = 2;
  inline const ::std::string& instrument_type() const;
  inline void set_instrument_type(const ::std::string& value);
  inline void set_instrument_type(const char* value);
  inline void set_instrument_type(const char* value, size_t size);
  inline ::std::string* mutable_instrument_type();
  inline ::std::string* release_instrument_type();
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string symbol = 4;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 4;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  
  // optional string cusip = 5;
  inline bool has_cusip() const;
  inline void clear_cusip();
  static const int kCusipFieldNumber = 5;
  inline const ::std::string& cusip() const;
  inline void set_cusip(const ::std::string& value);
  inline void set_cusip(const char* value);
  inline void set_cusip(const char* value, size_t size);
  inline ::std::string* mutable_cusip();
  inline ::std::string* release_cusip();
  
  // optional string sedol = 6;
  inline bool has_sedol() const;
  inline void clear_sedol();
  static const int kSedolFieldNumber = 6;
  inline const ::std::string& sedol() const;
  inline void set_sedol(const ::std::string& value);
  inline void set_sedol(const char* value);
  inline void set_sedol(const char* value, size_t size);
  inline ::std::string* mutable_sedol();
  inline ::std::string* release_sedol();
  
  // optional string isin = 7;
  inline bool has_isin() const;
  inline void clear_isin();
  static const int kIsinFieldNumber = 7;
  inline const ::std::string& isin() const;
  inline void set_isin(const ::std::string& value);
  inline void set_isin(const char* value);
  inline void set_isin(const char* value, size_t size);
  inline ::std::string* mutable_isin();
  inline ::std::string* release_isin();
  
  // optional string ric = 8;
  inline bool has_ric() const;
  inline void clear_ric();
  static const int kRicFieldNumber = 8;
  inline const ::std::string& ric() const;
  inline void set_ric(const ::std::string& value);
  inline void set_ric(const char* value);
  inline void set_ric(const char* value, size_t size);
  inline ::std::string* mutable_ric();
  inline ::std::string* release_ric();
  
  // optional string cfi_code = 9;
  inline bool has_cfi_code() const;
  inline void clear_cfi_code();
  static const int kCfiCodeFieldNumber = 9;
  inline const ::std::string& cfi_code() const;
  inline void set_cfi_code(const ::std::string& value);
  inline void set_cfi_code(const char* value);
  inline void set_cfi_code(const char* value, size_t size);
  inline ::std::string* mutable_cfi_code();
  inline ::std::string* release_cfi_code();
  
  // optional string security_id = 10;
  inline bool has_security_id() const;
  inline void clear_security_id();
  static const int kSecurityIdFieldNumber = 10;
  inline const ::std::string& security_id() const;
  inline void set_security_id(const ::std::string& value);
  inline void set_security_id(const char* value);
  inline void set_security_id(const char* value, size_t size);
  inline ::std::string* mutable_security_id();
  inline ::std::string* release_security_id();
  
  // optional string security_type = 11;
  inline bool has_security_type() const;
  inline void clear_security_type();
  static const int kSecurityTypeFieldNumber = 11;
  inline const ::std::string& security_type() const;
  inline void set_security_type(const ::std::string& value);
  inline void set_security_type(const char* value);
  inline void set_security_type(const char* value, size_t size);
  inline ::std::string* mutable_security_type();
  inline ::std::string* release_security_type();
  
  // optional string security_desc = 12;
  inline bool has_security_desc() const;
  inline void clear_security_desc();
  static const int kSecurityDescFieldNumber = 12;
  inline const ::std::string& security_desc() const;
  inline void set_security_desc(const ::std::string& value);
  inline void set_security_desc(const char* value);
  inline void set_security_desc(const char* value, size_t size);
  inline ::std::string* mutable_security_desc();
  inline ::std::string* release_security_desc();
  
  // optional string security_exchange = 13;
  inline bool has_security_exchange() const;
  inline void clear_security_exchange();
  static const int kSecurityExchangeFieldNumber = 13;
  inline const ::std::string& security_exchange() const;
  inline void set_security_exchange(const ::std::string& value);
  inline void set_security_exchange(const char* value);
  inline void set_security_exchange(const char* value, size_t size);
  inline ::std::string* mutable_security_exchange();
  inline ::std::string* release_security_exchange();
  
  // optional string maturity_month_year = 14;
  inline bool has_maturity_month_year() const;
  inline void clear_maturity_month_year();
  static const int kMaturityMonthYearFieldNumber = 14;
  inline const ::std::string& maturity_month_year() const;
  inline void set_maturity_month_year(const ::std::string& value);
  inline void set_maturity_month_year(const char* value);
  inline void set_maturity_month_year(const char* value, size_t size);
  inline ::std::string* mutable_maturity_month_year();
  inline ::std::string* release_maturity_month_year();
  
  // optional string base_ccy = 15;
  inline bool has_base_ccy() const;
  inline void clear_base_ccy();
  static const int kBaseCcyFieldNumber = 15;
  inline const ::std::string& base_ccy() const;
  inline void set_base_ccy(const ::std::string& value);
  inline void set_base_ccy(const char* value);
  inline void set_base_ccy(const char* value, size_t size);
  inline ::std::string* mutable_base_ccy();
  inline ::std::string* release_base_ccy();
  
  // optional string last_prc = 16 [default = "0"];
  inline bool has_last_prc() const;
  inline void clear_last_prc();
  static const int kLastPrcFieldNumber = 16;
  inline const ::std::string& last_prc() const;
  inline void set_last_prc(const ::std::string& value);
  inline void set_last_prc(const char* value);
  inline void set_last_prc(const char* value, size_t size);
  inline ::std::string* mutable_last_prc();
  inline ::std::string* release_last_prc();
  
  // optional string mark_prc = 17 [default = "0"];
  inline bool has_mark_prc() const;
  inline void clear_mark_prc();
  static const int kMarkPrcFieldNumber = 17;
  inline const ::std::string& mark_prc() const;
  inline void set_mark_prc(const ::std::string& value);
  inline void set_mark_prc(const char* value);
  inline void set_mark_prc(const char* value, size_t size);
  inline ::std::string* mutable_mark_prc();
  inline ::std::string* release_mark_prc();
  
  // optional string mark_datetime = 18;
  inline bool has_mark_datetime() const;
  inline void clear_mark_datetime();
  static const int kMarkDatetimeFieldNumber = 18;
  inline const ::std::string& mark_datetime() const;
  inline void set_mark_datetime(const ::std::string& value);
  inline void set_mark_datetime(const char* value);
  inline void set_mark_datetime(const char* value, size_t size);
  inline ::std::string* mutable_mark_datetime();
  inline ::std::string* release_mark_datetime();
  
  // optional string multiplier = 19;
  inline bool has_multiplier() const;
  inline void clear_multiplier();
  static const int kMultiplierFieldNumber = 19;
  inline const ::std::string& multiplier() const;
  inline void set_multiplier(const ::std::string& value);
  inline void set_multiplier(const char* value);
  inline void set_multiplier(const char* value, size_t size);
  inline ::std::string* mutable_multiplier();
  inline ::std::string* release_multiplier();
  
  // optional string exchange_price_factor = 20;
  inline bool has_exchange_price_factor() const;
  inline void clear_exchange_price_factor();
  static const int kExchangePriceFactorFieldNumber = 20;
  inline const ::std::string& exchange_price_factor() const;
  inline void set_exchange_price_factor(const ::std::string& value);
  inline void set_exchange_price_factor(const char* value);
  inline void set_exchange_price_factor(const char* value, size_t size);
  inline ::std::string* mutable_exchange_price_factor();
  inline ::std::string* release_exchange_price_factor();
  
  // optional string rollover_datetime = 21;
  inline bool has_rollover_datetime() const;
  inline void clear_rollover_datetime();
  static const int kRolloverDatetimeFieldNumber = 21;
  inline const ::std::string& rollover_datetime() const;
  inline void set_rollover_datetime(const ::std::string& value);
  inline void set_rollover_datetime(const char* value);
  inline void set_rollover_datetime(const char* value, size_t size);
  inline ::std::string* mutable_rollover_datetime();
  inline ::std::string* release_rollover_datetime();
  
  // optional string is_active = 22;
  inline bool has_is_active() const;
  inline void clear_is_active();
  static const int kIsActiveFieldNumber = 22;
  inline const ::std::string& is_active() const;
  inline void set_is_active(const ::std::string& value);
  inline void set_is_active(const char* value);
  inline void set_is_active(const char* value, size_t size);
  inline ::std::string* mutable_is_active();
  inline ::std::string* release_is_active();
  
  // optional string added_datetime = 23;
  inline bool has_added_datetime() const;
  inline void clear_added_datetime();
  static const int kAddedDatetimeFieldNumber = 23;
  inline const ::std::string& added_datetime() const;
  inline void set_added_datetime(const ::std::string& value);
  inline void set_added_datetime(const char* value);
  inline void set_added_datetime(const char* value, size_t size);
  inline ::std::string* mutable_added_datetime();
  inline ::std::string* release_added_datetime();
  
  // optional string added_by = 24;
  inline bool has_added_by() const;
  inline void clear_added_by();
  static const int kAddedByFieldNumber = 24;
  inline const ::std::string& added_by() const;
  inline void set_added_by(const ::std::string& value);
  inline void set_added_by(const char* value);
  inline void set_added_by(const char* value, size_t size);
  inline ::std::string* mutable_added_by();
  inline ::std::string* release_added_by();
  
  // optional string updated_datetime = 25;
  inline bool has_updated_datetime() const;
  inline void clear_updated_datetime();
  static const int kUpdatedDatetimeFieldNumber = 25;
  inline const ::std::string& updated_datetime() const;
  inline void set_updated_datetime(const ::std::string& value);
  inline void set_updated_datetime(const char* value);
  inline void set_updated_datetime(const char* value, size_t size);
  inline ::std::string* mutable_updated_datetime();
  inline ::std::string* release_updated_datetime();
  
  // optional string updated_by = 26;
  inline bool has_updated_by() const;
  inline void clear_updated_by();
  static const int kUpdatedByFieldNumber = 26;
  inline const ::std::string& updated_by() const;
  inline void set_updated_by(const ::std::string& value);
  inline void set_updated_by(const char* value);
  inline void set_updated_by(const char* value, size_t size);
  inline ::std::string* mutable_updated_by();
  inline ::std::string* release_updated_by();
  
  // @@protoc_insertion_point(class_scope:quantmodel.InstrumentData)
 private:
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_instrument_type();
  inline void clear_has_instrument_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_cusip();
  inline void clear_has_cusip();
  inline void set_has_sedol();
  inline void clear_has_sedol();
  inline void set_has_isin();
  inline void clear_has_isin();
  inline void set_has_ric();
  inline void clear_has_ric();
  inline void set_has_cfi_code();
  inline void clear_has_cfi_code();
  inline void set_has_security_id();
  inline void clear_has_security_id();
  inline void set_has_security_type();
  inline void clear_has_security_type();
  inline void set_has_security_desc();
  inline void clear_has_security_desc();
  inline void set_has_security_exchange();
  inline void clear_has_security_exchange();
  inline void set_has_maturity_month_year();
  inline void clear_has_maturity_month_year();
  inline void set_has_base_ccy();
  inline void clear_has_base_ccy();
  inline void set_has_last_prc();
  inline void clear_has_last_prc();
  inline void set_has_mark_prc();
  inline void clear_has_mark_prc();
  inline void set_has_mark_datetime();
  inline void clear_has_mark_datetime();
  inline void set_has_multiplier();
  inline void clear_has_multiplier();
  inline void set_has_exchange_price_factor();
  inline void clear_has_exchange_price_factor();
  inline void set_has_rollover_datetime();
  inline void clear_has_rollover_datetime();
  inline void set_has_is_active();
  inline void clear_has_is_active();
  inline void set_has_added_datetime();
  inline void clear_has_added_datetime();
  inline void set_has_added_by();
  inline void clear_has_added_by();
  inline void set_has_updated_datetime();
  inline void clear_has_updated_datetime();
  inline void set_has_updated_by();
  inline void clear_has_updated_by();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* instrument_id_;
  ::std::string* instrument_type_;
  ::std::string* name_;
  ::std::string* symbol_;
  ::std::string* cusip_;
  ::std::string* sedol_;
  ::std::string* isin_;
  ::std::string* ric_;
  ::std::string* cfi_code_;
  ::std::string* security_id_;
  ::std::string* security_type_;
  ::std::string* security_desc_;
  ::std::string* security_exchange_;
  ::std::string* maturity_month_year_;
  ::std::string* base_ccy_;
  ::std::string* last_prc_;
  static const ::std::string _default_last_prc_;
  ::std::string* mark_prc_;
  static const ::std::string _default_mark_prc_;
  ::std::string* mark_datetime_;
  ::std::string* multiplier_;
  ::std::string* exchange_price_factor_;
  ::std::string* rollover_datetime_;
  ::std::string* is_active_;
  ::std::string* added_datetime_;
  ::std::string* added_by_;
  ::std::string* updated_datetime_;
  ::std::string* updated_by_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static InstrumentData* default_instance_;
};
// -------------------------------------------------------------------

class SignalData : public ::google::protobuf::Message {
 public:
  SignalData();
  virtual ~SignalData();
  
  SignalData(const SignalData& from);
  
  inline SignalData& operator=(const SignalData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalData& default_instance();
  
  void Swap(SignalData* other);
  
  // implements Message ----------------------------------------------
  
  SignalData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignalData& from);
  void MergeFrom(const SignalData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string external_order_id = 1;
  inline bool has_external_order_id() const;
  inline void clear_external_order_id();
  static const int kExternalOrderIdFieldNumber = 1;
  inline const ::std::string& external_order_id() const;
  inline void set_external_order_id(const ::std::string& value);
  inline void set_external_order_id(const char* value);
  inline void set_external_order_id(const char* value, size_t size);
  inline ::std::string* mutable_external_order_id();
  inline ::std::string* release_external_order_id();
  
  // optional string investment_system_id = 2;
  inline bool has_investment_system_id() const;
  inline void clear_investment_system_id();
  static const int kInvestmentSystemIdFieldNumber = 2;
  inline const ::std::string& investment_system_id() const;
  inline void set_investment_system_id(const ::std::string& value);
  inline void set_investment_system_id(const char* value);
  inline void set_investment_system_id(const char* value, size_t size);
  inline ::std::string* mutable_investment_system_id();
  inline ::std::string* release_investment_system_id();
  
  // optional string signal_id = 3;
  inline bool has_signal_id() const;
  inline void clear_signal_id();
  static const int kSignalIdFieldNumber = 3;
  inline const ::std::string& signal_id() const;
  inline void set_signal_id(const ::std::string& value);
  inline void set_signal_id(const char* value);
  inline void set_signal_id(const char* value, size_t size);
  inline ::std::string* mutable_signal_id();
  inline ::std::string* release_signal_id();
  
  // optional string instrument_id = 4;
  inline bool has_instrument_id() const;
  inline void clear_instrument_id();
  static const int kInstrumentIdFieldNumber = 4;
  inline const ::std::string& instrument_id() const;
  inline void set_instrument_id(const ::std::string& value);
  inline void set_instrument_id(const char* value);
  inline void set_instrument_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_id();
  inline ::std::string* release_instrument_id();
  
  // optional string side_code = 5;
  inline bool has_side_code() const;
  inline void clear_side_code();
  static const int kSideCodeFieldNumber = 5;
  inline const ::std::string& side_code() const;
  inline void set_side_code(const ::std::string& value);
  inline void set_side_code(const char* value);
  inline void set_side_code(const char* value, size_t size);
  inline ::std::string* mutable_side_code();
  inline ::std::string* release_side_code();
  
  // optional string signal_qty = 6;
  inline bool has_signal_qty() const;
  inline void clear_signal_qty();
  static const int kSignalQtyFieldNumber = 6;
  inline const ::std::string& signal_qty() const;
  inline void set_signal_qty(const ::std::string& value);
  inline void set_signal_qty(const char* value);
  inline void set_signal_qty(const char* value, size_t size);
  inline ::std::string* mutable_signal_qty();
  inline ::std::string* release_signal_qty();
  
  // optional string order_type = 7;
  inline bool has_order_type() const;
  inline void clear_order_type();
  static const int kOrderTypeFieldNumber = 7;
  inline const ::std::string& order_type() const;
  inline void set_order_type(const ::std::string& value);
  inline void set_order_type(const char* value);
  inline void set_order_type(const char* value, size_t size);
  inline ::std::string* mutable_order_type();
  inline ::std::string* release_order_type();
  
  // optional string limit_prc = 8 [default = "0"];
  inline bool has_limit_prc() const;
  inline void clear_limit_prc();
  static const int kLimitPrcFieldNumber = 8;
  inline const ::std::string& limit_prc() const;
  inline void set_limit_prc(const ::std::string& value);
  inline void set_limit_prc(const char* value);
  inline void set_limit_prc(const char* value, size_t size);
  inline ::std::string* mutable_limit_prc();
  inline ::std::string* release_limit_prc();
  
  // optional string stop_prc = 9 [default = "0"];
  inline bool has_stop_prc() const;
  inline void clear_stop_prc();
  static const int kStopPrcFieldNumber = 9;
  inline const ::std::string& stop_prc() const;
  inline void set_stop_prc(const ::std::string& value);
  inline void set_stop_prc(const char* value);
  inline void set_stop_prc(const char* value, size_t size);
  inline ::std::string* mutable_stop_prc();
  inline ::std::string* release_stop_prc();
  
  // @@protoc_insertion_point(class_scope:quantmodel.SignalData)
 private:
  inline void set_has_external_order_id();
  inline void clear_has_external_order_id();
  inline void set_has_investment_system_id();
  inline void clear_has_investment_system_id();
  inline void set_has_signal_id();
  inline void clear_has_signal_id();
  inline void set_has_instrument_id();
  inline void clear_has_instrument_id();
  inline void set_has_side_code();
  inline void clear_has_side_code();
  inline void set_has_signal_qty();
  inline void clear_has_signal_qty();
  inline void set_has_order_type();
  inline void clear_has_order_type();
  inline void set_has_limit_prc();
  inline void clear_has_limit_prc();
  inline void set_has_stop_prc();
  inline void clear_has_stop_prc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* external_order_id_;
  ::std::string* investment_system_id_;
  ::std::string* signal_id_;
  ::std::string* instrument_id_;
  ::std::string* side_code_;
  ::std::string* signal_qty_;
  ::std::string* order_type_;
  ::std::string* limit_prc_;
  static const ::std::string _default_limit_prc_;
  ::std::string* stop_prc_;
  static const ::std::string _default_stop_prc_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static SignalData* default_instance_;
};
// -------------------------------------------------------------------

class InvestmentSystemData : public ::google::protobuf::Message {
 public:
  InvestmentSystemData();
  virtual ~InvestmentSystemData();
  
  InvestmentSystemData(const InvestmentSystemData& from);
  
  inline InvestmentSystemData& operator=(const InvestmentSystemData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvestmentSystemData& default_instance();
  
  void Swap(InvestmentSystemData* other);
  
  // implements Message ----------------------------------------------
  
  InvestmentSystemData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvestmentSystemData& from);
  void MergeFrom(const InvestmentSystemData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string investment_system_id = 1;
  inline bool has_investment_system_id() const;
  inline void clear_investment_system_id();
  static const int kInvestmentSystemIdFieldNumber = 1;
  inline const ::std::string& investment_system_id() const;
  inline void set_investment_system_id(const ::std::string& value);
  inline void set_investment_system_id(const char* value);
  inline void set_investment_system_id(const char* value, size_t size);
  inline ::std::string* mutable_investment_system_id();
  inline ::std::string* release_investment_system_id();
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string is_active = 3;
  inline bool has_is_active() const;
  inline void clear_is_active();
  static const int kIsActiveFieldNumber = 3;
  inline const ::std::string& is_active() const;
  inline void set_is_active(const ::std::string& value);
  inline void set_is_active(const char* value);
  inline void set_is_active(const char* value, size_t size);
  inline ::std::string* mutable_is_active();
  inline ::std::string* release_is_active();
  
  // @@protoc_insertion_point(class_scope:quantmodel.InvestmentSystemData)
 private:
  inline void set_has_investment_system_id();
  inline void clear_has_investment_system_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_is_active();
  inline void clear_has_is_active();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* investment_system_id_;
  ::std::string* name_;
  ::std::string* is_active_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static InvestmentSystemData* default_instance_;
};
// -------------------------------------------------------------------

class StrategyData : public ::google::protobuf::Message {
 public:
  StrategyData();
  virtual ~StrategyData();
  
  StrategyData(const StrategyData& from);
  
  inline StrategyData& operator=(const StrategyData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StrategyData& default_instance();
  
  void Swap(StrategyData* other);
  
  // implements Message ----------------------------------------------
  
  StrategyData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StrategyData& from);
  void MergeFrom(const StrategyData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string strategy_id = 1;
  inline bool has_strategy_id() const;
  inline void clear_strategy_id();
  static const int kStrategyIdFieldNumber = 1;
  inline const ::std::string& strategy_id() const;
  inline void set_strategy_id(const ::std::string& value);
  inline void set_strategy_id(const char* value);
  inline void set_strategy_id(const char* value, size_t size);
  inline ::std::string* mutable_strategy_id();
  inline ::std::string* release_strategy_id();
  
  // optional string investment_system_id = 2;
  inline bool has_investment_system_id() const;
  inline void clear_investment_system_id();
  static const int kInvestmentSystemIdFieldNumber = 2;
  inline const ::std::string& investment_system_id() const;
  inline void set_investment_system_id(const ::std::string& value);
  inline void set_investment_system_id(const char* value);
  inline void set_investment_system_id(const char* value, size_t size);
  inline ::std::string* mutable_investment_system_id();
  inline ::std::string* release_investment_system_id();
  
  // optional string signal_id = 3;
  inline bool has_signal_id() const;
  inline void clear_signal_id();
  static const int kSignalIdFieldNumber = 3;
  inline const ::std::string& signal_id() const;
  inline void set_signal_id(const ::std::string& value);
  inline void set_signal_id(const char* value);
  inline void set_signal_id(const char* value, size_t size);
  inline ::std::string* mutable_signal_id();
  inline ::std::string* release_signal_id();
  
  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string default_weight = 5;
  inline bool has_default_weight() const;
  inline void clear_default_weight();
  static const int kDefaultWeightFieldNumber = 5;
  inline const ::std::string& default_weight() const;
  inline void set_default_weight(const ::std::string& value);
  inline void set_default_weight(const char* value);
  inline void set_default_weight(const char* value, size_t size);
  inline ::std::string* mutable_default_weight();
  inline ::std::string* release_default_weight();
  
  // optional string is_active = 6;
  inline bool has_is_active() const;
  inline void clear_is_active();
  static const int kIsActiveFieldNumber = 6;
  inline const ::std::string& is_active() const;
  inline void set_is_active(const ::std::string& value);
  inline void set_is_active(const char* value);
  inline void set_is_active(const char* value, size_t size);
  inline ::std::string* mutable_is_active();
  inline ::std::string* release_is_active();
  
  // @@protoc_insertion_point(class_scope:quantmodel.StrategyData)
 private:
  inline void set_has_strategy_id();
  inline void clear_has_strategy_id();
  inline void set_has_investment_system_id();
  inline void clear_has_investment_system_id();
  inline void set_has_signal_id();
  inline void clear_has_signal_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_default_weight();
  inline void clear_has_default_weight();
  inline void set_has_is_active();
  inline void clear_has_is_active();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* strategy_id_;
  ::std::string* investment_system_id_;
  ::std::string* signal_id_;
  ::std::string* name_;
  ::std::string* default_weight_;
  ::std::string* is_active_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static StrategyData* default_instance_;
};
// -------------------------------------------------------------------

class AccountStrategyData : public ::google::protobuf::Message {
 public:
  AccountStrategyData();
  virtual ~AccountStrategyData();
  
  AccountStrategyData(const AccountStrategyData& from);
  
  inline AccountStrategyData& operator=(const AccountStrategyData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountStrategyData& default_instance();
  
  void Swap(AccountStrategyData* other);
  
  // implements Message ----------------------------------------------
  
  AccountStrategyData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountStrategyData& from);
  void MergeFrom(const AccountStrategyData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline const ::std::string& account_id() const;
  inline void set_account_id(const ::std::string& value);
  inline void set_account_id(const char* value);
  inline void set_account_id(const char* value, size_t size);
  inline ::std::string* mutable_account_id();
  inline ::std::string* release_account_id();
  
  // optional string strategy_id = 2;
  inline bool has_strategy_id() const;
  inline void clear_strategy_id();
  static const int kStrategyIdFieldNumber = 2;
  inline const ::std::string& strategy_id() const;
  inline void set_strategy_id(const ::std::string& value);
  inline void set_strategy_id(const char* value);
  inline void set_strategy_id(const char* value, size_t size);
  inline ::std::string* mutable_strategy_id();
  inline ::std::string* release_strategy_id();
  
  // optional string weight = 3;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 3;
  inline const ::std::string& weight() const;
  inline void set_weight(const ::std::string& value);
  inline void set_weight(const char* value);
  inline void set_weight(const char* value, size_t size);
  inline ::std::string* mutable_weight();
  inline ::std::string* release_weight();
  
  // optional string is_enabled = 4;
  inline bool has_is_enabled() const;
  inline void clear_is_enabled();
  static const int kIsEnabledFieldNumber = 4;
  inline const ::std::string& is_enabled() const;
  inline void set_is_enabled(const ::std::string& value);
  inline void set_is_enabled(const char* value);
  inline void set_is_enabled(const char* value, size_t size);
  inline ::std::string* mutable_is_enabled();
  inline ::std::string* release_is_enabled();
  
  // @@protoc_insertion_point(class_scope:quantmodel.AccountStrategyData)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_strategy_id();
  inline void clear_has_strategy_id();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_is_enabled();
  inline void clear_has_is_enabled();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* account_id_;
  ::std::string* strategy_id_;
  ::std::string* weight_;
  ::std::string* is_enabled_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static AccountStrategyData* default_instance_;
};
// -------------------------------------------------------------------

class ExecutionReportData : public ::google::protobuf::Message {
 public:
  ExecutionReportData();
  virtual ~ExecutionReportData();
  
  ExecutionReportData(const ExecutionReportData& from);
  
  inline ExecutionReportData& operator=(const ExecutionReportData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutionReportData& default_instance();
  
  void Swap(ExecutionReportData* other);
  
  // implements Message ----------------------------------------------
  
  ExecutionReportData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutionReportData& from);
  void MergeFrom(const ExecutionReportData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string release_id = 1;
  inline bool has_release_id() const;
  inline void clear_release_id();
  static const int kReleaseIdFieldNumber = 1;
  inline const ::std::string& release_id() const;
  inline void set_release_id(const ::std::string& value);
  inline void set_release_id(const char* value);
  inline void set_release_id(const char* value, size_t size);
  inline ::std::string* mutable_release_id();
  inline ::std::string* release_release_id();
  
  // optional string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional string sending_tm = 3;
  inline bool has_sending_tm() const;
  inline void clear_sending_tm();
  static const int kSendingTmFieldNumber = 3;
  inline const ::std::string& sending_tm() const;
  inline void set_sending_tm(const ::std::string& value);
  inline void set_sending_tm(const char* value);
  inline void set_sending_tm(const char* value, size_t size);
  inline ::std::string* mutable_sending_tm();
  inline ::std::string* release_sending_tm();
  
  // optional string ExecID = 4;
  inline bool has_execid() const;
  inline void clear_execid();
  static const int kExecIDFieldNumber = 4;
  inline const ::std::string& execid() const;
  inline void set_execid(const ::std::string& value);
  inline void set_execid(const char* value);
  inline void set_execid(const char* value, size_t size);
  inline ::std::string* mutable_execid();
  inline ::std::string* release_execid();
  
  // optional string OrderID = 5;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIDFieldNumber = 5;
  inline const ::std::string& orderid() const;
  inline void set_orderid(const ::std::string& value);
  inline void set_orderid(const char* value);
  inline void set_orderid(const char* value, size_t size);
  inline ::std::string* mutable_orderid();
  inline ::std::string* release_orderid();
  
  // optional string ClOrdID = 6;
  inline bool has_clordid() const;
  inline void clear_clordid();
  static const int kClOrdIDFieldNumber = 6;
  inline const ::std::string& clordid() const;
  inline void set_clordid(const ::std::string& value);
  inline void set_clordid(const char* value);
  inline void set_clordid(const char* value, size_t size);
  inline ::std::string* mutable_clordid();
  inline ::std::string* release_clordid();
  
  // optional string OrigClOrdID = 7;
  inline bool has_origclordid() const;
  inline void clear_origclordid();
  static const int kOrigClOrdIDFieldNumber = 7;
  inline const ::std::string& origclordid() const;
  inline void set_origclordid(const ::std::string& value);
  inline void set_origclordid(const char* value);
  inline void set_origclordid(const char* value, size_t size);
  inline ::std::string* mutable_origclordid();
  inline ::std::string* release_origclordid();
  
  // optional string ExecRefID = 8;
  inline bool has_execrefid() const;
  inline void clear_execrefid();
  static const int kExecRefIDFieldNumber = 8;
  inline const ::std::string& execrefid() const;
  inline void set_execrefid(const ::std::string& value);
  inline void set_execrefid(const char* value);
  inline void set_execrefid(const char* value, size_t size);
  inline ::std::string* mutable_execrefid();
  inline ::std::string* release_execrefid();
  
  // optional string OrdType = 9;
  inline bool has_ordtype() const;
  inline void clear_ordtype();
  static const int kOrdTypeFieldNumber = 9;
  inline const ::std::string& ordtype() const;
  inline void set_ordtype(const ::std::string& value);
  inline void set_ordtype(const char* value);
  inline void set_ordtype(const char* value, size_t size);
  inline ::std::string* mutable_ordtype();
  inline ::std::string* release_ordtype();
  
  // optional string ExecType = 10;
  inline bool has_exectype() const;
  inline void clear_exectype();
  static const int kExecTypeFieldNumber = 10;
  inline const ::std::string& exectype() const;
  inline void set_exectype(const ::std::string& value);
  inline void set_exectype(const char* value);
  inline void set_exectype(const char* value, size_t size);
  inline ::std::string* mutable_exectype();
  inline ::std::string* release_exectype();
  
  // optional string ExecTransType = 11;
  inline bool has_exectranstype() const;
  inline void clear_exectranstype();
  static const int kExecTransTypeFieldNumber = 11;
  inline const ::std::string& exectranstype() const;
  inline void set_exectranstype(const ::std::string& value);
  inline void set_exectranstype(const char* value);
  inline void set_exectranstype(const char* value, size_t size);
  inline ::std::string* mutable_exectranstype();
  inline ::std::string* release_exectranstype();
  
  // optional string MultiLegReportingType = 12 [default = "1"];
  inline bool has_multilegreportingtype() const;
  inline void clear_multilegreportingtype();
  static const int kMultiLegReportingTypeFieldNumber = 12;
  inline const ::std::string& multilegreportingtype() const;
  inline void set_multilegreportingtype(const ::std::string& value);
  inline void set_multilegreportingtype(const char* value);
  inline void set_multilegreportingtype(const char* value, size_t size);
  inline ::std::string* mutable_multilegreportingtype();
  inline ::std::string* release_multilegreportingtype();
  
  // optional string SecurityID = 13;
  inline bool has_securityid() const;
  inline void clear_securityid();
  static const int kSecurityIDFieldNumber = 13;
  inline const ::std::string& securityid() const;
  inline void set_securityid(const ::std::string& value);
  inline void set_securityid(const char* value);
  inline void set_securityid(const char* value, size_t size);
  inline ::std::string* mutable_securityid();
  inline ::std::string* release_securityid();
  
  // optional string SecurityType = 14;
  inline bool has_securitytype() const;
  inline void clear_securitytype();
  static const int kSecurityTypeFieldNumber = 14;
  inline const ::std::string& securitytype() const;
  inline void set_securitytype(const ::std::string& value);
  inline void set_securitytype(const char* value);
  inline void set_securitytype(const char* value, size_t size);
  inline ::std::string* mutable_securitytype();
  inline ::std::string* release_securitytype();
  
  // optional string IDSource = 15;
  inline bool has_idsource() const;
  inline void clear_idsource();
  static const int kIDSourceFieldNumber = 15;
  inline const ::std::string& idsource() const;
  inline void set_idsource(const ::std::string& value);
  inline void set_idsource(const char* value);
  inline void set_idsource(const char* value, size_t size);
  inline ::std::string* mutable_idsource();
  inline ::std::string* release_idsource();
  
  // optional string Account = 16;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 16;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  
  // optional string OrdStatus = 17;
  inline bool has_ordstatus() const;
  inline void clear_ordstatus();
  static const int kOrdStatusFieldNumber = 17;
  inline const ::std::string& ordstatus() const;
  inline void set_ordstatus(const ::std::string& value);
  inline void set_ordstatus(const char* value);
  inline void set_ordstatus(const char* value, size_t size);
  inline ::std::string* mutable_ordstatus();
  inline ::std::string* release_ordstatus();
  
  // optional string Symbol = 18;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 18;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  
  // optional string Side = 19;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 19;
  inline const ::std::string& side() const;
  inline void set_side(const ::std::string& value);
  inline void set_side(const char* value);
  inline void set_side(const char* value, size_t size);
  inline ::std::string* mutable_side();
  inline ::std::string* release_side();
  
  // optional string TimeInForce = 20;
  inline bool has_timeinforce() const;
  inline void clear_timeinforce();
  static const int kTimeInForceFieldNumber = 20;
  inline const ::std::string& timeinforce() const;
  inline void set_timeinforce(const ::std::string& value);
  inline void set_timeinforce(const char* value);
  inline void set_timeinforce(const char* value, size_t size);
  inline ::std::string* mutable_timeinforce();
  inline ::std::string* release_timeinforce();
  
  // optional string MaturityMonthYear = 21;
  inline bool has_maturitymonthyear() const;
  inline void clear_maturitymonthyear();
  static const int kMaturityMonthYearFieldNumber = 21;
  inline const ::std::string& maturitymonthyear() const;
  inline void set_maturitymonthyear(const ::std::string& value);
  inline void set_maturitymonthyear(const char* value);
  inline void set_maturitymonthyear(const char* value, size_t size);
  inline ::std::string* mutable_maturitymonthyear();
  inline ::std::string* release_maturitymonthyear();
  
  // optional string TransactTime = 22;
  inline bool has_transacttime() const;
  inline void clear_transacttime();
  static const int kTransactTimeFieldNumber = 22;
  inline const ::std::string& transacttime() const;
  inline void set_transacttime(const ::std::string& value);
  inline void set_transacttime(const char* value);
  inline void set_transacttime(const char* value, size_t size);
  inline ::std::string* mutable_transacttime();
  inline ::std::string* release_transacttime();
  
  // optional string Text = 23;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 23;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // optional string CumQty = 24 [default = "0"];
  inline bool has_cumqty() const;
  inline void clear_cumqty();
  static const int kCumQtyFieldNumber = 24;
  inline const ::std::string& cumqty() const;
  inline void set_cumqty(const ::std::string& value);
  inline void set_cumqty(const char* value);
  inline void set_cumqty(const char* value, size_t size);
  inline ::std::string* mutable_cumqty();
  inline ::std::string* release_cumqty();
  
  // optional string OrderQty = 25 [default = "0"];
  inline bool has_orderqty() const;
  inline void clear_orderqty();
  static const int kOrderQtyFieldNumber = 25;
  inline const ::std::string& orderqty() const;
  inline void set_orderqty(const ::std::string& value);
  inline void set_orderqty(const char* value);
  inline void set_orderqty(const char* value, size_t size);
  inline ::std::string* mutable_orderqty();
  inline ::std::string* release_orderqty();
  
  // optional string LeavesQty = 26 [default = "0"];
  inline bool has_leavesqty() const;
  inline void clear_leavesqty();
  static const int kLeavesQtyFieldNumber = 26;
  inline const ::std::string& leavesqty() const;
  inline void set_leavesqty(const ::std::string& value);
  inline void set_leavesqty(const char* value);
  inline void set_leavesqty(const char* value, size_t size);
  inline ::std::string* mutable_leavesqty();
  inline ::std::string* release_leavesqty();
  
  // optional string LastShares = 27 [default = "0"];
  inline bool has_lastshares() const;
  inline void clear_lastshares();
  static const int kLastSharesFieldNumber = 27;
  inline const ::std::string& lastshares() const;
  inline void set_lastshares(const ::std::string& value);
  inline void set_lastshares(const char* value);
  inline void set_lastshares(const char* value, size_t size);
  inline ::std::string* mutable_lastshares();
  inline ::std::string* release_lastshares();
  
  // optional string Price = 28 [default = "0"];
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 28;
  inline const ::std::string& price() const;
  inline void set_price(const ::std::string& value);
  inline void set_price(const char* value);
  inline void set_price(const char* value, size_t size);
  inline ::std::string* mutable_price();
  inline ::std::string* release_price();
  
  // optional string AvgPx = 29 [default = "0"];
  inline bool has_avgpx() const;
  inline void clear_avgpx();
  static const int kAvgPxFieldNumber = 29;
  inline const ::std::string& avgpx() const;
  inline void set_avgpx(const ::std::string& value);
  inline void set_avgpx(const char* value);
  inline void set_avgpx(const char* value, size_t size);
  inline ::std::string* mutable_avgpx();
  inline ::std::string* release_avgpx();
  
  // optional string LastPx = 30 [default = "0"];
  inline bool has_lastpx() const;
  inline void clear_lastpx();
  static const int kLastPxFieldNumber = 30;
  inline const ::std::string& lastpx() const;
  inline void set_lastpx(const ::std::string& value);
  inline void set_lastpx(const char* value);
  inline void set_lastpx(const char* value, size_t size);
  inline ::std::string* mutable_lastpx();
  inline ::std::string* release_lastpx();
  
  // optional string StopPx = 31 [default = "0"];
  inline bool has_stoppx() const;
  inline void clear_stoppx();
  static const int kStopPxFieldNumber = 31;
  inline const ::std::string& stoppx() const;
  inline void set_stoppx(const ::std::string& value);
  inline void set_stoppx(const char* value);
  inline void set_stoppx(const char* value, size_t size);
  inline ::std::string* mutable_stoppx();
  inline ::std::string* release_stoppx();
  
  // @@protoc_insertion_point(class_scope:quantmodel.ExecutionReportData)
 private:
  inline void set_has_release_id();
  inline void clear_has_release_id();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_sending_tm();
  inline void clear_has_sending_tm();
  inline void set_has_execid();
  inline void clear_has_execid();
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_clordid();
  inline void clear_has_clordid();
  inline void set_has_origclordid();
  inline void clear_has_origclordid();
  inline void set_has_execrefid();
  inline void clear_has_execrefid();
  inline void set_has_ordtype();
  inline void clear_has_ordtype();
  inline void set_has_exectype();
  inline void clear_has_exectype();
  inline void set_has_exectranstype();
  inline void clear_has_exectranstype();
  inline void set_has_multilegreportingtype();
  inline void clear_has_multilegreportingtype();
  inline void set_has_securityid();
  inline void clear_has_securityid();
  inline void set_has_securitytype();
  inline void clear_has_securitytype();
  inline void set_has_idsource();
  inline void clear_has_idsource();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_ordstatus();
  inline void clear_has_ordstatus();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_timeinforce();
  inline void clear_has_timeinforce();
  inline void set_has_maturitymonthyear();
  inline void clear_has_maturitymonthyear();
  inline void set_has_transacttime();
  inline void clear_has_transacttime();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_cumqty();
  inline void clear_has_cumqty();
  inline void set_has_orderqty();
  inline void clear_has_orderqty();
  inline void set_has_leavesqty();
  inline void clear_has_leavesqty();
  inline void set_has_lastshares();
  inline void clear_has_lastshares();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_avgpx();
  inline void clear_has_avgpx();
  inline void set_has_lastpx();
  inline void clear_has_lastpx();
  inline void set_has_stoppx();
  inline void clear_has_stoppx();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* release_id_;
  ::std::string* session_id_;
  ::std::string* sending_tm_;
  ::std::string* execid_;
  ::std::string* orderid_;
  ::std::string* clordid_;
  ::std::string* origclordid_;
  ::std::string* execrefid_;
  ::std::string* ordtype_;
  ::std::string* exectype_;
  ::std::string* exectranstype_;
  ::std::string* multilegreportingtype_;
  static const ::std::string _default_multilegreportingtype_;
  ::std::string* securityid_;
  ::std::string* securitytype_;
  ::std::string* idsource_;
  ::std::string* account_;
  ::std::string* ordstatus_;
  ::std::string* symbol_;
  ::std::string* side_;
  ::std::string* timeinforce_;
  ::std::string* maturitymonthyear_;
  ::std::string* transacttime_;
  ::std::string* text_;
  ::std::string* cumqty_;
  static const ::std::string _default_cumqty_;
  ::std::string* orderqty_;
  static const ::std::string _default_orderqty_;
  ::std::string* leavesqty_;
  static const ::std::string _default_leavesqty_;
  ::std::string* lastshares_;
  static const ::std::string _default_lastshares_;
  ::std::string* price_;
  static const ::std::string _default_price_;
  ::std::string* avgpx_;
  static const ::std::string _default_avgpx_;
  ::std::string* lastpx_;
  static const ::std::string _default_lastpx_;
  ::std::string* stoppx_;
  static const ::std::string _default_stoppx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static ExecutionReportData* default_instance_;
};
// -------------------------------------------------------------------

class DraftOrderMessage : public ::google::protobuf::Message {
 public:
  DraftOrderMessage();
  virtual ~DraftOrderMessage();
  
  DraftOrderMessage(const DraftOrderMessage& from);
  
  inline DraftOrderMessage& operator=(const DraftOrderMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DraftOrderMessage& default_instance();
  
  void Swap(DraftOrderMessage* other);
  
  // implements Message ----------------------------------------------
  
  DraftOrderMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DraftOrderMessage& from);
  void MergeFrom(const DraftOrderMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .quantmodel.DraftOrderData draft_order_data = 1;
  inline bool has_draft_order_data() const;
  inline void clear_draft_order_data();
  static const int kDraftOrderDataFieldNumber = 1;
  inline const ::quantmodel::DraftOrderData& draft_order_data() const;
  inline ::quantmodel::DraftOrderData* mutable_draft_order_data();
  inline ::quantmodel::DraftOrderData* release_draft_order_data();
  
  // repeated .quantmodel.DraftAllocationData draft_allocation_data = 2;
  inline int draft_allocation_data_size() const;
  inline void clear_draft_allocation_data();
  static const int kDraftAllocationDataFieldNumber = 2;
  inline const ::quantmodel::DraftAllocationData& draft_allocation_data(int index) const;
  inline ::quantmodel::DraftAllocationData* mutable_draft_allocation_data(int index);
  inline ::quantmodel::DraftAllocationData* add_draft_allocation_data();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::DraftAllocationData >&
      draft_allocation_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::DraftAllocationData >*
      mutable_draft_allocation_data();
  
  // @@protoc_insertion_point(class_scope:quantmodel.DraftOrderMessage)
 private:
  inline void set_has_draft_order_data();
  inline void clear_has_draft_order_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::quantmodel::DraftOrderData* draft_order_data_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::DraftAllocationData > draft_allocation_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static DraftOrderMessage* default_instance_;
};
// -------------------------------------------------------------------

class OrderMessage : public ::google::protobuf::Message {
 public:
  OrderMessage();
  virtual ~OrderMessage();
  
  OrderMessage(const OrderMessage& from);
  
  inline OrderMessage& operator=(const OrderMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderMessage& default_instance();
  
  void Swap(OrderMessage* other);
  
  // implements Message ----------------------------------------------
  
  OrderMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderMessage& from);
  void MergeFrom(const OrderMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .quantmodel.OrderData order_data = 1;
  inline bool has_order_data() const;
  inline void clear_order_data();
  static const int kOrderDataFieldNumber = 1;
  inline const ::quantmodel::OrderData& order_data() const;
  inline ::quantmodel::OrderData* mutable_order_data();
  inline ::quantmodel::OrderData* release_order_data();
  
  // repeated .quantmodel.AllocationData allocation_data = 2;
  inline int allocation_data_size() const;
  inline void clear_allocation_data();
  static const int kAllocationDataFieldNumber = 2;
  inline const ::quantmodel::AllocationData& allocation_data(int index) const;
  inline ::quantmodel::AllocationData* mutable_allocation_data(int index);
  inline ::quantmodel::AllocationData* add_allocation_data();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::AllocationData >&
      allocation_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::AllocationData >*
      mutable_allocation_data();
  
  // repeated .quantmodel.ReleaseData release_data = 3;
  inline int release_data_size() const;
  inline void clear_release_data();
  static const int kReleaseDataFieldNumber = 3;
  inline const ::quantmodel::ReleaseData& release_data(int index) const;
  inline ::quantmodel::ReleaseData* mutable_release_data(int index);
  inline ::quantmodel::ReleaseData* add_release_data();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::ReleaseData >&
      release_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::ReleaseData >*
      mutable_release_data();
  
  // repeated .quantmodel.ExecutionData execution_data = 4;
  inline int execution_data_size() const;
  inline void clear_execution_data();
  static const int kExecutionDataFieldNumber = 4;
  inline const ::quantmodel::ExecutionData& execution_data(int index) const;
  inline ::quantmodel::ExecutionData* mutable_execution_data(int index);
  inline ::quantmodel::ExecutionData* add_execution_data();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::ExecutionData >&
      execution_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::ExecutionData >*
      mutable_execution_data();
  
  // @@protoc_insertion_point(class_scope:quantmodel.OrderMessage)
 private:
  inline void set_has_order_data();
  inline void clear_has_order_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::quantmodel::OrderData* order_data_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::AllocationData > allocation_data_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::ReleaseData > release_data_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::ExecutionData > execution_data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static OrderMessage* default_instance_;
};
// -------------------------------------------------------------------

class DatabaseEngineRequest_Query : public ::google::protobuf::Message {
 public:
  DatabaseEngineRequest_Query();
  virtual ~DatabaseEngineRequest_Query();
  
  DatabaseEngineRequest_Query(const DatabaseEngineRequest_Query& from);
  
  inline DatabaseEngineRequest_Query& operator=(const DatabaseEngineRequest_Query& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DatabaseEngineRequest_Query& default_instance();
  
  void Swap(DatabaseEngineRequest_Query* other);
  
  // implements Message ----------------------------------------------
  
  DatabaseEngineRequest_Query* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatabaseEngineRequest_Query& from);
  void MergeFrom(const DatabaseEngineRequest_Query& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .quantmodel.DatabaseEngineRequest.QueryType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::quantmodel::DatabaseEngineRequest_QueryType type() const;
  inline void set_type(::quantmodel::DatabaseEngineRequest_QueryType value);
  
  // optional string query_id = 2;
  inline bool has_query_id() const;
  inline void clear_query_id();
  static const int kQueryIdFieldNumber = 2;
  inline const ::std::string& query_id() const;
  inline void set_query_id(const ::std::string& value);
  inline void set_query_id(const char* value);
  inline void set_query_id(const char* value, size_t size);
  inline ::std::string* mutable_query_id();
  inline ::std::string* release_query_id();
  
  // optional string query_str = 3;
  inline bool has_query_str() const;
  inline void clear_query_str();
  static const int kQueryStrFieldNumber = 3;
  inline const ::std::string& query_str() const;
  inline void set_query_str(const ::std::string& value);
  inline void set_query_str(const char* value);
  inline void set_query_str(const char* value, size_t size);
  inline ::std::string* mutable_query_str();
  inline ::std::string* release_query_str();
  
  // @@protoc_insertion_point(class_scope:quantmodel.DatabaseEngineRequest.Query)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_query_id();
  inline void clear_has_query_id();
  inline void set_has_query_str();
  inline void clear_has_query_str();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* query_id_;
  ::std::string* query_str_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static DatabaseEngineRequest_Query* default_instance_;
};
// -------------------------------------------------------------------

class DatabaseEngineRequest : public ::google::protobuf::Message {
 public:
  DatabaseEngineRequest();
  virtual ~DatabaseEngineRequest();
  
  DatabaseEngineRequest(const DatabaseEngineRequest& from);
  
  inline DatabaseEngineRequest& operator=(const DatabaseEngineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DatabaseEngineRequest& default_instance();
  
  void Swap(DatabaseEngineRequest* other);
  
  // implements Message ----------------------------------------------
  
  DatabaseEngineRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatabaseEngineRequest& from);
  void MergeFrom(const DatabaseEngineRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef DatabaseEngineRequest_Query Query;
  
  typedef DatabaseEngineRequest_QueryType QueryType;
  static const QueryType SELECT = DatabaseEngineRequest_QueryType_SELECT;
  static const QueryType UPDATE = DatabaseEngineRequest_QueryType_UPDATE;
  static inline bool QueryType_IsValid(int value) {
    return DatabaseEngineRequest_QueryType_IsValid(value);
  }
  static const QueryType QueryType_MIN =
    DatabaseEngineRequest_QueryType_QueryType_MIN;
  static const QueryType QueryType_MAX =
    DatabaseEngineRequest_QueryType_QueryType_MAX;
  static const int QueryType_ARRAYSIZE =
    DatabaseEngineRequest_QueryType_QueryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  QueryType_descriptor() {
    return DatabaseEngineRequest_QueryType_descriptor();
  }
  static inline const ::std::string& QueryType_Name(QueryType value) {
    return DatabaseEngineRequest_QueryType_Name(value);
  }
  static inline bool QueryType_Parse(const ::std::string& name,
      QueryType* value) {
    return DatabaseEngineRequest_QueryType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  
  // optional string timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // repeated .quantmodel.DatabaseEngineRequest.Query query = 3;
  inline int query_size() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 3;
  inline const ::quantmodel::DatabaseEngineRequest_Query& query(int index) const;
  inline ::quantmodel::DatabaseEngineRequest_Query* mutable_query(int index);
  inline ::quantmodel::DatabaseEngineRequest_Query* add_query();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineRequest_Query >&
      query() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineRequest_Query >*
      mutable_query();
  
  // @@protoc_insertion_point(class_scope:quantmodel.DatabaseEngineRequest)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* request_id_;
  ::std::string* timestamp_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineRequest_Query > query_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static DatabaseEngineRequest* default_instance_;
};
// -------------------------------------------------------------------

class DatabaseEngineResponse_ResultSet_Row_Column : public ::google::protobuf::Message {
 public:
  DatabaseEngineResponse_ResultSet_Row_Column();
  virtual ~DatabaseEngineResponse_ResultSet_Row_Column();
  
  DatabaseEngineResponse_ResultSet_Row_Column(const DatabaseEngineResponse_ResultSet_Row_Column& from);
  
  inline DatabaseEngineResponse_ResultSet_Row_Column& operator=(const DatabaseEngineResponse_ResultSet_Row_Column& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DatabaseEngineResponse_ResultSet_Row_Column& default_instance();
  
  void Swap(DatabaseEngineResponse_ResultSet_Row_Column* other);
  
  // implements Message ----------------------------------------------
  
  DatabaseEngineResponse_ResultSet_Row_Column* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatabaseEngineResponse_ResultSet_Row_Column& from);
  void MergeFrom(const DatabaseEngineResponse_ResultSet_Row_Column& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 column_id = 1;
  inline bool has_column_id() const;
  inline void clear_column_id();
  static const int kColumnIdFieldNumber = 1;
  inline ::google::protobuf::int32 column_id() const;
  inline void set_column_id(::google::protobuf::int32 value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:quantmodel.DatabaseEngineResponse.ResultSet.Row.Column)
 private:
  inline void set_has_column_id();
  inline void clear_has_column_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* value_;
  ::google::protobuf::int32 column_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static DatabaseEngineResponse_ResultSet_Row_Column* default_instance_;
};
// -------------------------------------------------------------------

class DatabaseEngineResponse_ResultSet_Row : public ::google::protobuf::Message {
 public:
  DatabaseEngineResponse_ResultSet_Row();
  virtual ~DatabaseEngineResponse_ResultSet_Row();
  
  DatabaseEngineResponse_ResultSet_Row(const DatabaseEngineResponse_ResultSet_Row& from);
  
  inline DatabaseEngineResponse_ResultSet_Row& operator=(const DatabaseEngineResponse_ResultSet_Row& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DatabaseEngineResponse_ResultSet_Row& default_instance();
  
  void Swap(DatabaseEngineResponse_ResultSet_Row* other);
  
  // implements Message ----------------------------------------------
  
  DatabaseEngineResponse_ResultSet_Row* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatabaseEngineResponse_ResultSet_Row& from);
  void MergeFrom(const DatabaseEngineResponse_ResultSet_Row& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef DatabaseEngineResponse_ResultSet_Row_Column Column;
  
  // accessors -------------------------------------------------------
  
  // optional int32 row_id = 1;
  inline bool has_row_id() const;
  inline void clear_row_id();
  static const int kRowIdFieldNumber = 1;
  inline ::google::protobuf::int32 row_id() const;
  inline void set_row_id(::google::protobuf::int32 value);
  
  // repeated .quantmodel.DatabaseEngineResponse.ResultSet.Row.Column column = 2;
  inline int column_size() const;
  inline void clear_column();
  static const int kColumnFieldNumber = 2;
  inline const ::quantmodel::DatabaseEngineResponse_ResultSet_Row_Column& column(int index) const;
  inline ::quantmodel::DatabaseEngineResponse_ResultSet_Row_Column* mutable_column(int index);
  inline ::quantmodel::DatabaseEngineResponse_ResultSet_Row_Column* add_column();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet_Row_Column >&
      column() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet_Row_Column >*
      mutable_column();
  
  // @@protoc_insertion_point(class_scope:quantmodel.DatabaseEngineResponse.ResultSet.Row)
 private:
  inline void set_has_row_id();
  inline void clear_has_row_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet_Row_Column > column_;
  ::google::protobuf::int32 row_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static DatabaseEngineResponse_ResultSet_Row* default_instance_;
};
// -------------------------------------------------------------------

class DatabaseEngineResponse_ResultSet : public ::google::protobuf::Message {
 public:
  DatabaseEngineResponse_ResultSet();
  virtual ~DatabaseEngineResponse_ResultSet();
  
  DatabaseEngineResponse_ResultSet(const DatabaseEngineResponse_ResultSet& from);
  
  inline DatabaseEngineResponse_ResultSet& operator=(const DatabaseEngineResponse_ResultSet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DatabaseEngineResponse_ResultSet& default_instance();
  
  void Swap(DatabaseEngineResponse_ResultSet* other);
  
  // implements Message ----------------------------------------------
  
  DatabaseEngineResponse_ResultSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatabaseEngineResponse_ResultSet& from);
  void MergeFrom(const DatabaseEngineResponse_ResultSet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef DatabaseEngineResponse_ResultSet_Row Row;
  
  // accessors -------------------------------------------------------
  
  // optional string query_id = 1;
  inline bool has_query_id() const;
  inline void clear_query_id();
  static const int kQueryIdFieldNumber = 1;
  inline const ::std::string& query_id() const;
  inline void set_query_id(const ::std::string& value);
  inline void set_query_id(const char* value);
  inline void set_query_id(const char* value, size_t size);
  inline ::std::string* mutable_query_id();
  inline ::std::string* release_query_id();
  
  // repeated .quantmodel.DatabaseEngineResponse.ResultSet.Row row = 2;
  inline int row_size() const;
  inline void clear_row();
  static const int kRowFieldNumber = 2;
  inline const ::quantmodel::DatabaseEngineResponse_ResultSet_Row& row(int index) const;
  inline ::quantmodel::DatabaseEngineResponse_ResultSet_Row* mutable_row(int index);
  inline ::quantmodel::DatabaseEngineResponse_ResultSet_Row* add_row();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet_Row >&
      row() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet_Row >*
      mutable_row();
  
  // @@protoc_insertion_point(class_scope:quantmodel.DatabaseEngineResponse.ResultSet)
 private:
  inline void set_has_query_id();
  inline void clear_has_query_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* query_id_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet_Row > row_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static DatabaseEngineResponse_ResultSet* default_instance_;
};
// -------------------------------------------------------------------

class DatabaseEngineResponse : public ::google::protobuf::Message {
 public:
  DatabaseEngineResponse();
  virtual ~DatabaseEngineResponse();
  
  DatabaseEngineResponse(const DatabaseEngineResponse& from);
  
  inline DatabaseEngineResponse& operator=(const DatabaseEngineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DatabaseEngineResponse& default_instance();
  
  void Swap(DatabaseEngineResponse* other);
  
  // implements Message ----------------------------------------------
  
  DatabaseEngineResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DatabaseEngineResponse& from);
  void MergeFrom(const DatabaseEngineResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef DatabaseEngineResponse_ResultSet ResultSet;
  
  // accessors -------------------------------------------------------
  
  // optional string response_id = 1;
  inline bool has_response_id() const;
  inline void clear_response_id();
  static const int kResponseIdFieldNumber = 1;
  inline const ::std::string& response_id() const;
  inline void set_response_id(const ::std::string& value);
  inline void set_response_id(const char* value);
  inline void set_response_id(const char* value, size_t size);
  inline ::std::string* mutable_response_id();
  inline ::std::string* release_response_id();
  
  // optional string request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  
  // optional string timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // repeated .quantmodel.DatabaseEngineResponse.ResultSet result_set = 4;
  inline int result_set_size() const;
  inline void clear_result_set();
  static const int kResultSetFieldNumber = 4;
  inline const ::quantmodel::DatabaseEngineResponse_ResultSet& result_set(int index) const;
  inline ::quantmodel::DatabaseEngineResponse_ResultSet* mutable_result_set(int index);
  inline ::quantmodel::DatabaseEngineResponse_ResultSet* add_result_set();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet >&
      result_set() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet >*
      mutable_result_set();
  
  // @@protoc_insertion_point(class_scope:quantmodel.DatabaseEngineResponse)
 private:
  inline void set_has_response_id();
  inline void clear_has_response_id();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* response_id_;
  ::std::string* request_id_;
  ::std::string* timestamp_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet > result_set_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static DatabaseEngineResponse* default_instance_;
};
// -------------------------------------------------------------------

class DealingEngineRequest : public ::google::protobuf::Message {
 public:
  DealingEngineRequest();
  virtual ~DealingEngineRequest();
  
  DealingEngineRequest(const DealingEngineRequest& from);
  
  inline DealingEngineRequest& operator=(const DealingEngineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DealingEngineRequest& default_instance();
  
  void Swap(DealingEngineRequest* other);
  
  // implements Message ----------------------------------------------
  
  DealingEngineRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DealingEngineRequest& from);
  void MergeFrom(const DealingEngineRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef DealingEngineRequest_RequestType RequestType;
  static const RequestType EXECUTE_SIGNAL = DealingEngineRequest_RequestType_EXECUTE_SIGNAL;
  static const RequestType EXECUTE_DRAFT_ORDER = DealingEngineRequest_RequestType_EXECUTE_DRAFT_ORDER;
  static const RequestType CREATE_DRAFT_ORDER = DealingEngineRequest_RequestType_CREATE_DRAFT_ORDER;
  static const RequestType CREATE_ORDER = DealingEngineRequest_RequestType_CREATE_ORDER;
  static const RequestType UPDATE_ORDER = DealingEngineRequest_RequestType_UPDATE_ORDER;
  static const RequestType CANCEL_ORDER = DealingEngineRequest_RequestType_CANCEL_ORDER;
  static const RequestType RELEASE_ORDER = DealingEngineRequest_RequestType_RELEASE_ORDER;
  static const RequestType CREATE_RELEASE = DealingEngineRequest_RequestType_CREATE_RELEASE;
  static const RequestType VALIDATE_RELEASE = DealingEngineRequest_RequestType_VALIDATE_RELEASE;
  static const RequestType CANCEL_RELEASE = DealingEngineRequest_RequestType_CANCEL_RELEASE;
  static const RequestType REPLACE_RELEASE = DealingEngineRequest_RequestType_REPLACE_RELEASE;
  static const RequestType RELEASE_REJECTED = DealingEngineRequest_RequestType_RELEASE_REJECTED;
  static const RequestType CANCEL_REJECTED = DealingEngineRequest_RequestType_CANCEL_REJECTED;
  static const RequestType RELEASE_RESTATED = DealingEngineRequest_RequestType_RELEASE_RESTATED;
  static const RequestType RELEASE_CANCELED = DealingEngineRequest_RequestType_RELEASE_CANCELED;
  static const RequestType RELEASE_REPLACED = DealingEngineRequest_RequestType_RELEASE_REPLACED;
  static const RequestType CREATE_EXECUTION = DealingEngineRequest_RequestType_CREATE_EXECUTION;
  static const RequestType EXECUTION_CANCELED = DealingEngineRequest_RequestType_EXECUTION_CANCELED;
  static const RequestType BROADCAST_DATA = DealingEngineRequest_RequestType_BROADCAST_DATA;
  static const RequestType ACTIVE_SET = DealingEngineRequest_RequestType_ACTIVE_SET;
  static const RequestType QUERY_ORDER = DealingEngineRequest_RequestType_QUERY_ORDER;
  static const RequestType QUERY_RELEASE = DealingEngineRequest_RequestType_QUERY_RELEASE;
  static const RequestType QUERY_EXECUTION = DealingEngineRequest_RequestType_QUERY_EXECUTION;
  static const RequestType ROLLOVER = DealingEngineRequest_RequestType_ROLLOVER;
  static const RequestType CURRENT_STATUS = DealingEngineRequest_RequestType_CURRENT_STATUS;
  static const RequestType UPDATE_STATUS = DealingEngineRequest_RequestType_UPDATE_STATUS;
  static const RequestType MARKETDATA_SUBSCRIBE = DealingEngineRequest_RequestType_MARKETDATA_SUBSCRIBE;
  static const RequestType MARKETDATA_UNSUBSCRIBE = DealingEngineRequest_RequestType_MARKETDATA_UNSUBSCRIBE;
  static const RequestType FIXENGINE_LOGIN = DealingEngineRequest_RequestType_FIXENGINE_LOGIN;
  static const RequestType FIXENGINE_LOGOUT = DealingEngineRequest_RequestType_FIXENGINE_LOGOUT;
  static const RequestType LOGOUT_FIXENGINE = DealingEngineRequest_RequestType_LOGOUT_FIXENGINE;
  static const RequestType LOGIN_FIXENGINE = DealingEngineRequest_RequestType_LOGIN_FIXENGINE;
  static const RequestType RELOAD_STATIC_DATA = DealingEngineRequest_RequestType_RELOAD_STATIC_DATA;
  static const RequestType SHUTDOWN = DealingEngineRequest_RequestType_SHUTDOWN;
  static inline bool RequestType_IsValid(int value) {
    return DealingEngineRequest_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    DealingEngineRequest_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    DealingEngineRequest_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    DealingEngineRequest_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return DealingEngineRequest_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return DealingEngineRequest_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return DealingEngineRequest_RequestType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  
  // optional string timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // optional .quantmodel.DealingEngineRequest.RequestType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::quantmodel::DealingEngineRequest_RequestType type() const;
  inline void set_type(::quantmodel::DealingEngineRequest_RequestType value);
  
  // optional .quantmodel.DraftOrderMessage draft_order = 4;
  inline bool has_draft_order() const;
  inline void clear_draft_order();
  static const int kDraftOrderFieldNumber = 4;
  inline const ::quantmodel::DraftOrderMessage& draft_order() const;
  inline ::quantmodel::DraftOrderMessage* mutable_draft_order();
  inline ::quantmodel::DraftOrderMessage* release_draft_order();
  
  // optional .quantmodel.OrderMessage order = 5;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 5;
  inline const ::quantmodel::OrderMessage& order() const;
  inline ::quantmodel::OrderMessage* mutable_order();
  inline ::quantmodel::OrderMessage* release_order();
  
  // optional .quantmodel.ExecutionReportData execution_report_data = 6;
  inline bool has_execution_report_data() const;
  inline void clear_execution_report_data();
  static const int kExecutionReportDataFieldNumber = 6;
  inline const ::quantmodel::ExecutionReportData& execution_report_data() const;
  inline ::quantmodel::ExecutionReportData* mutable_execution_report_data();
  inline ::quantmodel::ExecutionReportData* release_execution_report_data();
  
  // optional .quantmodel.FixEngineData fix_engine_data = 7;
  inline bool has_fix_engine_data() const;
  inline void clear_fix_engine_data();
  static const int kFixEngineDataFieldNumber = 7;
  inline const ::quantmodel::FixEngineData& fix_engine_data() const;
  inline ::quantmodel::FixEngineData* mutable_fix_engine_data();
  inline ::quantmodel::FixEngineData* release_fix_engine_data();
  
  // repeated .quantmodel.InstrumentData instrument_data = 8;
  inline int instrument_data_size() const;
  inline void clear_instrument_data();
  static const int kInstrumentDataFieldNumber = 8;
  inline const ::quantmodel::InstrumentData& instrument_data(int index) const;
  inline ::quantmodel::InstrumentData* mutable_instrument_data(int index);
  inline ::quantmodel::InstrumentData* add_instrument_data();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::InstrumentData >&
      instrument_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::InstrumentData >*
      mutable_instrument_data();
  
  // repeated .quantmodel.AccountData account_data = 9;
  inline int account_data_size() const;
  inline void clear_account_data();
  static const int kAccountDataFieldNumber = 9;
  inline const ::quantmodel::AccountData& account_data(int index) const;
  inline ::quantmodel::AccountData* mutable_account_data(int index);
  inline ::quantmodel::AccountData* add_account_data();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::AccountData >&
      account_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::AccountData >*
      mutable_account_data();
  
  // repeated .quantmodel.InvestmentSystemData investment_system_data = 10;
  inline int investment_system_data_size() const;
  inline void clear_investment_system_data();
  static const int kInvestmentSystemDataFieldNumber = 10;
  inline const ::quantmodel::InvestmentSystemData& investment_system_data(int index) const;
  inline ::quantmodel::InvestmentSystemData* mutable_investment_system_data(int index);
  inline ::quantmodel::InvestmentSystemData* add_investment_system_data();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::InvestmentSystemData >&
      investment_system_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::InvestmentSystemData >*
      mutable_investment_system_data();
  
  // repeated .quantmodel.SignalData signal_data = 11;
  inline int signal_data_size() const;
  inline void clear_signal_data();
  static const int kSignalDataFieldNumber = 11;
  inline const ::quantmodel::SignalData& signal_data(int index) const;
  inline ::quantmodel::SignalData* mutable_signal_data(int index);
  inline ::quantmodel::SignalData* add_signal_data();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::SignalData >&
      signal_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::SignalData >*
      mutable_signal_data();
  
  // optional .quantmodel.SystemParameterData system_parameter_data = 12;
  inline bool has_system_parameter_data() const;
  inline void clear_system_parameter_data();
  static const int kSystemParameterDataFieldNumber = 12;
  inline const ::quantmodel::SystemParameterData& system_parameter_data() const;
  inline ::quantmodel::SystemParameterData* mutable_system_parameter_data();
  inline ::quantmodel::SystemParameterData* release_system_parameter_data();
  
  // @@protoc_insertion_point(class_scope:quantmodel.DealingEngineRequest)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_draft_order();
  inline void clear_has_draft_order();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_execution_report_data();
  inline void clear_has_execution_report_data();
  inline void set_has_fix_engine_data();
  inline void clear_has_fix_engine_data();
  inline void set_has_system_parameter_data();
  inline void clear_has_system_parameter_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* request_id_;
  ::std::string* timestamp_;
  ::quantmodel::DraftOrderMessage* draft_order_;
  ::quantmodel::OrderMessage* order_;
  ::quantmodel::ExecutionReportData* execution_report_data_;
  ::quantmodel::FixEngineData* fix_engine_data_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::InstrumentData > instrument_data_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::AccountData > account_data_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::InvestmentSystemData > investment_system_data_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::SignalData > signal_data_;
  ::quantmodel::SystemParameterData* system_parameter_data_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static DealingEngineRequest* default_instance_;
};
// -------------------------------------------------------------------

class DealingEngineResponse : public ::google::protobuf::Message {
 public:
  DealingEngineResponse();
  virtual ~DealingEngineResponse();
  
  DealingEngineResponse(const DealingEngineResponse& from);
  
  inline DealingEngineResponse& operator=(const DealingEngineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DealingEngineResponse& default_instance();
  
  void Swap(DealingEngineResponse* other);
  
  // implements Message ----------------------------------------------
  
  DealingEngineResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DealingEngineResponse& from);
  void MergeFrom(const DealingEngineResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef DealingEngineResponse_ResponseType ResponseType;
  static const ResponseType ACKNOWLEDGEMENT = DealingEngineResponse_ResponseType_ACKNOWLEDGEMENT;
  static const ResponseType REJECT = DealingEngineResponse_ResponseType_REJECT;
  static const ResponseType ERROR = DealingEngineResponse_ResponseType_ERROR;
  static inline bool ResponseType_IsValid(int value) {
    return DealingEngineResponse_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    DealingEngineResponse_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    DealingEngineResponse_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    DealingEngineResponse_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return DealingEngineResponse_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return DealingEngineResponse_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return DealingEngineResponse_ResponseType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string response_id = 1;
  inline bool has_response_id() const;
  inline void clear_response_id();
  static const int kResponseIdFieldNumber = 1;
  inline const ::std::string& response_id() const;
  inline void set_response_id(const ::std::string& value);
  inline void set_response_id(const char* value);
  inline void set_response_id(const char* value, size_t size);
  inline ::std::string* mutable_response_id();
  inline ::std::string* release_response_id();
  
  // optional string request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  
  // optional string timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // optional .quantmodel.DealingEngineResponse.ResponseType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::quantmodel::DealingEngineResponse_ResponseType type() const;
  inline void set_type(::quantmodel::DealingEngineResponse_ResponseType value);
  
  // optional string error_msg = 5;
  inline bool has_error_msg() const;
  inline void clear_error_msg();
  static const int kErrorMsgFieldNumber = 5;
  inline const ::std::string& error_msg() const;
  inline void set_error_msg(const ::std::string& value);
  inline void set_error_msg(const char* value);
  inline void set_error_msg(const char* value, size_t size);
  inline ::std::string* mutable_error_msg();
  inline ::std::string* release_error_msg();
  
  // repeated .quantmodel.DraftOrderMessage draft_order = 6;
  inline int draft_order_size() const;
  inline void clear_draft_order();
  static const int kDraftOrderFieldNumber = 6;
  inline const ::quantmodel::DraftOrderMessage& draft_order(int index) const;
  inline ::quantmodel::DraftOrderMessage* mutable_draft_order(int index);
  inline ::quantmodel::DraftOrderMessage* add_draft_order();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::DraftOrderMessage >&
      draft_order() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::DraftOrderMessage >*
      mutable_draft_order();
  
  // repeated .quantmodel.OrderMessage order = 7;
  inline int order_size() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 7;
  inline const ::quantmodel::OrderMessage& order(int index) const;
  inline ::quantmodel::OrderMessage* mutable_order(int index);
  inline ::quantmodel::OrderMessage* add_order();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::OrderMessage >&
      order() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::OrderMessage >*
      mutable_order();
  
  // repeated .quantmodel.PositionOvernightData position = 8;
  inline int position_size() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 8;
  inline const ::quantmodel::PositionOvernightData& position(int index) const;
  inline ::quantmodel::PositionOvernightData* mutable_position(int index);
  inline ::quantmodel::PositionOvernightData* add_position();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::PositionOvernightData >&
      position() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::PositionOvernightData >*
      mutable_position();
  
  // repeated .quantmodel.SystemParameterData system_parameter = 9;
  inline int system_parameter_size() const;
  inline void clear_system_parameter();
  static const int kSystemParameterFieldNumber = 9;
  inline const ::quantmodel::SystemParameterData& system_parameter(int index) const;
  inline ::quantmodel::SystemParameterData* mutable_system_parameter(int index);
  inline ::quantmodel::SystemParameterData* add_system_parameter();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::SystemParameterData >&
      system_parameter() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::SystemParameterData >*
      mutable_system_parameter();
  
  // optional .quantmodel.AccountLimitData account_limit = 10;
  inline bool has_account_limit() const;
  inline void clear_account_limit();
  static const int kAccountLimitFieldNumber = 10;
  inline const ::quantmodel::AccountLimitData& account_limit() const;
  inline ::quantmodel::AccountLimitData* mutable_account_limit();
  inline ::quantmodel::AccountLimitData* release_account_limit();
  
  // @@protoc_insertion_point(class_scope:quantmodel.DealingEngineResponse)
 private:
  inline void set_has_response_id();
  inline void clear_has_response_id();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();
  inline void set_has_account_limit();
  inline void clear_has_account_limit();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* response_id_;
  ::std::string* request_id_;
  ::std::string* timestamp_;
  ::std::string* error_msg_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::DraftOrderMessage > draft_order_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::OrderMessage > order_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::PositionOvernightData > position_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::SystemParameterData > system_parameter_;
  ::quantmodel::AccountLimitData* account_limit_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static DealingEngineResponse* default_instance_;
};
// -------------------------------------------------------------------

class DealingEngineBroadcast : public ::google::protobuf::Message {
 public:
  DealingEngineBroadcast();
  virtual ~DealingEngineBroadcast();
  
  DealingEngineBroadcast(const DealingEngineBroadcast& from);
  
  inline DealingEngineBroadcast& operator=(const DealingEngineBroadcast& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DealingEngineBroadcast& default_instance();
  
  void Swap(DealingEngineBroadcast* other);
  
  // implements Message ----------------------------------------------
  
  DealingEngineBroadcast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DealingEngineBroadcast& from);
  void MergeFrom(const DealingEngineBroadcast& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef DealingEngineBroadcast_BroadcastType BroadcastType;
  static const BroadcastType EXECUTE_SIGNAL = DealingEngineBroadcast_BroadcastType_EXECUTE_SIGNAL;
  static const BroadcastType EXECUTE_DRAFT_ORDER = DealingEngineBroadcast_BroadcastType_EXECUTE_DRAFT_ORDER;
  static const BroadcastType CREATE_DRAFT_ORDER = DealingEngineBroadcast_BroadcastType_CREATE_DRAFT_ORDER;
  static const BroadcastType CREATE_ORDER = DealingEngineBroadcast_BroadcastType_CREATE_ORDER;
  static const BroadcastType UPDATE_ORDER = DealingEngineBroadcast_BroadcastType_UPDATE_ORDER;
  static const BroadcastType CANCEL_ORDER = DealingEngineBroadcast_BroadcastType_CANCEL_ORDER;
  static const BroadcastType RELEASE_ORDER = DealingEngineBroadcast_BroadcastType_RELEASE_ORDER;
  static const BroadcastType CREATE_RELEASE = DealingEngineBroadcast_BroadcastType_CREATE_RELEASE;
  static const BroadcastType VALIDATE_RELEASE = DealingEngineBroadcast_BroadcastType_VALIDATE_RELEASE;
  static const BroadcastType CANCEL_RELEASE = DealingEngineBroadcast_BroadcastType_CANCEL_RELEASE;
  static const BroadcastType REPLACE_RELEASE = DealingEngineBroadcast_BroadcastType_REPLACE_RELEASE;
  static const BroadcastType RELEASE_REJECTED = DealingEngineBroadcast_BroadcastType_RELEASE_REJECTED;
  static const BroadcastType CANCEL_REJECTED = DealingEngineBroadcast_BroadcastType_CANCEL_REJECTED;
  static const BroadcastType RELEASE_RESTATED = DealingEngineBroadcast_BroadcastType_RELEASE_RESTATED;
  static const BroadcastType RELEASE_CANCELED = DealingEngineBroadcast_BroadcastType_RELEASE_CANCELED;
  static const BroadcastType RELEASE_REPLACED = DealingEngineBroadcast_BroadcastType_RELEASE_REPLACED;
  static const BroadcastType CREATE_EXECUTION = DealingEngineBroadcast_BroadcastType_CREATE_EXECUTION;
  static const BroadcastType EXECUTION_CANCELED = DealingEngineBroadcast_BroadcastType_EXECUTION_CANCELED;
  static const BroadcastType BROADCAST_DATA = DealingEngineBroadcast_BroadcastType_BROADCAST_DATA;
  static const BroadcastType ACTIVE_SET = DealingEngineBroadcast_BroadcastType_ACTIVE_SET;
  static const BroadcastType QUERY_ORDER = DealingEngineBroadcast_BroadcastType_QUERY_ORDER;
  static const BroadcastType QUERY_RELEASE = DealingEngineBroadcast_BroadcastType_QUERY_RELEASE;
  static const BroadcastType QUERY_EXECUTION = DealingEngineBroadcast_BroadcastType_QUERY_EXECUTION;
  static const BroadcastType ROLLOVER = DealingEngineBroadcast_BroadcastType_ROLLOVER;
  static const BroadcastType CURRENT_STATUS = DealingEngineBroadcast_BroadcastType_CURRENT_STATUS;
  static const BroadcastType UPDATE_STATUS = DealingEngineBroadcast_BroadcastType_UPDATE_STATUS;
  static const BroadcastType MARKETDATA_SUBSCRIBE = DealingEngineBroadcast_BroadcastType_MARKETDATA_SUBSCRIBE;
  static const BroadcastType MARKETDATA_UNSUBSCRIBE = DealingEngineBroadcast_BroadcastType_MARKETDATA_UNSUBSCRIBE;
  static const BroadcastType FIXENGINE_LOGIN = DealingEngineBroadcast_BroadcastType_FIXENGINE_LOGIN;
  static const BroadcastType FIXENGINE_LOGOUT = DealingEngineBroadcast_BroadcastType_FIXENGINE_LOGOUT;
  static const BroadcastType LOGOUT_FIXENGINE = DealingEngineBroadcast_BroadcastType_LOGOUT_FIXENGINE;
  static const BroadcastType LOGIN_FIXENGINE = DealingEngineBroadcast_BroadcastType_LOGIN_FIXENGINE;
  static const BroadcastType RELOAD_STATIC_DATA = DealingEngineBroadcast_BroadcastType_RELOAD_STATIC_DATA;
  static const BroadcastType SHUTDOWN = DealingEngineBroadcast_BroadcastType_SHUTDOWN;
  static inline bool BroadcastType_IsValid(int value) {
    return DealingEngineBroadcast_BroadcastType_IsValid(value);
  }
  static const BroadcastType BroadcastType_MIN =
    DealingEngineBroadcast_BroadcastType_BroadcastType_MIN;
  static const BroadcastType BroadcastType_MAX =
    DealingEngineBroadcast_BroadcastType_BroadcastType_MAX;
  static const int BroadcastType_ARRAYSIZE =
    DealingEngineBroadcast_BroadcastType_BroadcastType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BroadcastType_descriptor() {
    return DealingEngineBroadcast_BroadcastType_descriptor();
  }
  static inline const ::std::string& BroadcastType_Name(BroadcastType value) {
    return DealingEngineBroadcast_BroadcastType_Name(value);
  }
  static inline bool BroadcastType_Parse(const ::std::string& name,
      BroadcastType* value) {
    return DealingEngineBroadcast_BroadcastType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string broadcast_id = 1;
  inline bool has_broadcast_id() const;
  inline void clear_broadcast_id();
  static const int kBroadcastIdFieldNumber = 1;
  inline const ::std::string& broadcast_id() const;
  inline void set_broadcast_id(const ::std::string& value);
  inline void set_broadcast_id(const char* value);
  inline void set_broadcast_id(const char* value, size_t size);
  inline ::std::string* mutable_broadcast_id();
  inline ::std::string* release_broadcast_id();
  
  // optional .quantmodel.DealingEngineBroadcast.BroadcastType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::quantmodel::DealingEngineBroadcast_BroadcastType type() const;
  inline void set_type(::quantmodel::DealingEngineBroadcast_BroadcastType value);
  
  // optional string timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // repeated .quantmodel.OrderMessage order = 4;
  inline int order_size() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 4;
  inline const ::quantmodel::OrderMessage& order(int index) const;
  inline ::quantmodel::OrderMessage* mutable_order(int index);
  inline ::quantmodel::OrderMessage* add_order();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::OrderMessage >&
      order() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::OrderMessage >*
      mutable_order();
  
  // repeated .quantmodel.FixEngineData fix_engine_data = 5;
  inline int fix_engine_data_size() const;
  inline void clear_fix_engine_data();
  static const int kFixEngineDataFieldNumber = 5;
  inline const ::quantmodel::FixEngineData& fix_engine_data(int index) const;
  inline ::quantmodel::FixEngineData* mutable_fix_engine_data(int index);
  inline ::quantmodel::FixEngineData* add_fix_engine_data();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::FixEngineData >&
      fix_engine_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::FixEngineData >*
      mutable_fix_engine_data();
  
  // repeated .quantmodel.PositionOvernightData position = 6;
  inline int position_size() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 6;
  inline const ::quantmodel::PositionOvernightData& position(int index) const;
  inline ::quantmodel::PositionOvernightData* mutable_position(int index);
  inline ::quantmodel::PositionOvernightData* add_position();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::PositionOvernightData >&
      position() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::PositionOvernightData >*
      mutable_position();
  
  // repeated .quantmodel.SystemParameterData system_parameter = 7;
  inline int system_parameter_size() const;
  inline void clear_system_parameter();
  static const int kSystemParameterFieldNumber = 7;
  inline const ::quantmodel::SystemParameterData& system_parameter(int index) const;
  inline ::quantmodel::SystemParameterData* mutable_system_parameter(int index);
  inline ::quantmodel::SystemParameterData* add_system_parameter();
  inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::SystemParameterData >&
      system_parameter() const;
  inline ::google::protobuf::RepeatedPtrField< ::quantmodel::SystemParameterData >*
      mutable_system_parameter();
  
  // @@protoc_insertion_point(class_scope:quantmodel.DealingEngineBroadcast)
 private:
  inline void set_has_broadcast_id();
  inline void clear_has_broadcast_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* broadcast_id_;
  ::std::string* timestamp_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::OrderMessage > order_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::FixEngineData > fix_engine_data_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::PositionOvernightData > position_;
  ::google::protobuf::RepeatedPtrField< ::quantmodel::SystemParameterData > system_parameter_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static DealingEngineBroadcast* default_instance_;
};
// -------------------------------------------------------------------

class FixEngineRequest : public ::google::protobuf::Message {
 public:
  FixEngineRequest();
  virtual ~FixEngineRequest();
  
  FixEngineRequest(const FixEngineRequest& from);
  
  inline FixEngineRequest& operator=(const FixEngineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FixEngineRequest& default_instance();
  
  void Swap(FixEngineRequest* other);
  
  // implements Message ----------------------------------------------
  
  FixEngineRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FixEngineRequest& from);
  void MergeFrom(const FixEngineRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FixEngineRequest_RequestType RequestType;
  static const RequestType CREATE_RELEASE = FixEngineRequest_RequestType_CREATE_RELEASE;
  static const RequestType CANCEL_RELEASE = FixEngineRequest_RequestType_CANCEL_RELEASE;
  static const RequestType REPLACE_RELEASE = FixEngineRequest_RequestType_REPLACE_RELEASE;
  static const RequestType DEFINE_SECURITY = FixEngineRequest_RequestType_DEFINE_SECURITY;
  static const RequestType MARKETDATA_SUBSCRIBE = FixEngineRequest_RequestType_MARKETDATA_SUBSCRIBE;
  static const RequestType FIXENGINE_LOGOUT = FixEngineRequest_RequestType_FIXENGINE_LOGOUT;
  static const RequestType FIXENGINE_LOGIN = FixEngineRequest_RequestType_FIXENGINE_LOGIN;
  static const RequestType SEQUENCE_RESET = FixEngineRequest_RequestType_SEQUENCE_RESET;
  static const RequestType RESEND_REQUEST = FixEngineRequest_RequestType_RESEND_REQUEST;
  static const RequestType TEST_REQUEST = FixEngineRequest_RequestType_TEST_REQUEST;
  static const RequestType SHUTDOWN = FixEngineRequest_RequestType_SHUTDOWN;
  static inline bool RequestType_IsValid(int value) {
    return FixEngineRequest_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    FixEngineRequest_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    FixEngineRequest_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    FixEngineRequest_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return FixEngineRequest_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return FixEngineRequest_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return FixEngineRequest_RequestType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  
  // optional string timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // optional .quantmodel.FixEngineRequest.RequestType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::quantmodel::FixEngineRequest_RequestType type() const;
  inline void set_type(::quantmodel::FixEngineRequest_RequestType value);
  
  // optional string session_id = 4;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 4;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional .quantmodel.ReleaseData release_data = 5;
  inline bool has_release_data() const;
  inline void clear_release_data();
  static const int kReleaseDataFieldNumber = 5;
  inline const ::quantmodel::ReleaseData& release_data() const;
  inline ::quantmodel::ReleaseData* mutable_release_data();
  inline ::quantmodel::ReleaseData* release_release_data();
  
  // optional .quantmodel.InstrumentData instrument_data = 6;
  inline bool has_instrument_data() const;
  inline void clear_instrument_data();
  static const int kInstrumentDataFieldNumber = 6;
  inline const ::quantmodel::InstrumentData& instrument_data() const;
  inline ::quantmodel::InstrumentData* mutable_instrument_data();
  inline ::quantmodel::InstrumentData* release_instrument_data();
  
  // optional .quantmodel.AccountData account_data = 7;
  inline bool has_account_data() const;
  inline void clear_account_data();
  static const int kAccountDataFieldNumber = 7;
  inline const ::quantmodel::AccountData& account_data() const;
  inline ::quantmodel::AccountData* mutable_account_data();
  inline ::quantmodel::AccountData* release_account_data();
  
  // @@protoc_insertion_point(class_scope:quantmodel.FixEngineRequest)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_release_data();
  inline void clear_has_release_data();
  inline void set_has_instrument_data();
  inline void clear_has_instrument_data();
  inline void set_has_account_data();
  inline void clear_has_account_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* request_id_;
  ::std::string* timestamp_;
  ::std::string* session_id_;
  ::quantmodel::ReleaseData* release_data_;
  ::quantmodel::InstrumentData* instrument_data_;
  ::quantmodel::AccountData* account_data_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static FixEngineRequest* default_instance_;
};
// -------------------------------------------------------------------

class FixEngineResponse : public ::google::protobuf::Message {
 public:
  FixEngineResponse();
  virtual ~FixEngineResponse();
  
  FixEngineResponse(const FixEngineResponse& from);
  
  inline FixEngineResponse& operator=(const FixEngineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FixEngineResponse& default_instance();
  
  void Swap(FixEngineResponse* other);
  
  // implements Message ----------------------------------------------
  
  FixEngineResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FixEngineResponse& from);
  void MergeFrom(const FixEngineResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FixEngineResponse_ResponseType ResponseType;
  static const ResponseType ACKNOWLEDGEMENT = FixEngineResponse_ResponseType_ACKNOWLEDGEMENT;
  static const ResponseType REJECT = FixEngineResponse_ResponseType_REJECT;
  static const ResponseType ERROR = FixEngineResponse_ResponseType_ERROR;
  static inline bool ResponseType_IsValid(int value) {
    return FixEngineResponse_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    FixEngineResponse_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    FixEngineResponse_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    FixEngineResponse_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return FixEngineResponse_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return FixEngineResponse_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return FixEngineResponse_ResponseType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string response_id = 1;
  inline bool has_response_id() const;
  inline void clear_response_id();
  static const int kResponseIdFieldNumber = 1;
  inline const ::std::string& response_id() const;
  inline void set_response_id(const ::std::string& value);
  inline void set_response_id(const char* value);
  inline void set_response_id(const char* value, size_t size);
  inline ::std::string* mutable_response_id();
  inline ::std::string* release_response_id();
  
  // optional string request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  
  // optional string timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // optional .quantmodel.FixEngineResponse.ResponseType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::quantmodel::FixEngineResponse_ResponseType type() const;
  inline void set_type(::quantmodel::FixEngineResponse_ResponseType value);
  
  // optional string error_msg = 5;
  inline bool has_error_msg() const;
  inline void clear_error_msg();
  static const int kErrorMsgFieldNumber = 5;
  inline const ::std::string& error_msg() const;
  inline void set_error_msg(const ::std::string& value);
  inline void set_error_msg(const char* value);
  inline void set_error_msg(const char* value, size_t size);
  inline ::std::string* mutable_error_msg();
  inline ::std::string* release_error_msg();
  
  // @@protoc_insertion_point(class_scope:quantmodel.FixEngineResponse)
 private:
  inline void set_has_response_id();
  inline void clear_has_response_id();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* response_id_;
  ::std::string* request_id_;
  ::std::string* timestamp_;
  ::std::string* error_msg_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static FixEngineResponse* default_instance_;
};
// -------------------------------------------------------------------

class ClientAdapterRequest : public ::google::protobuf::Message {
 public:
  ClientAdapterRequest();
  virtual ~ClientAdapterRequest();
  
  ClientAdapterRequest(const ClientAdapterRequest& from);
  
  inline ClientAdapterRequest& operator=(const ClientAdapterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientAdapterRequest& default_instance();
  
  void Swap(ClientAdapterRequest* other);
  
  // implements Message ----------------------------------------------
  
  ClientAdapterRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientAdapterRequest& from);
  void MergeFrom(const ClientAdapterRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientAdapterRequest_RequestType RequestType;
  static const RequestType HEARTBEAT = ClientAdapterRequest_RequestType_HEARTBEAT;
  static const RequestType DATABASE = ClientAdapterRequest_RequestType_DATABASE;
  static const RequestType DEALING = ClientAdapterRequest_RequestType_DEALING;
  static const RequestType SHUTDOWN = ClientAdapterRequest_RequestType_SHUTDOWN;
  static inline bool RequestType_IsValid(int value) {
    return ClientAdapterRequest_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    ClientAdapterRequest_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    ClientAdapterRequest_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    ClientAdapterRequest_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return ClientAdapterRequest_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return ClientAdapterRequest_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return ClientAdapterRequest_RequestType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  
  // optional string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional string timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // optional .quantmodel.ClientAdapterRequest.RequestType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::quantmodel::ClientAdapterRequest_RequestType type() const;
  inline void set_type(::quantmodel::ClientAdapterRequest_RequestType value);
  
  // optional .quantmodel.DealingEngineRequest dealing_request = 5;
  inline bool has_dealing_request() const;
  inline void clear_dealing_request();
  static const int kDealingRequestFieldNumber = 5;
  inline const ::quantmodel::DealingEngineRequest& dealing_request() const;
  inline ::quantmodel::DealingEngineRequest* mutable_dealing_request();
  inline ::quantmodel::DealingEngineRequest* release_dealing_request();
  
  // optional .quantmodel.DatabaseEngineRequest database_request = 6;
  inline bool has_database_request() const;
  inline void clear_database_request();
  static const int kDatabaseRequestFieldNumber = 6;
  inline const ::quantmodel::DatabaseEngineRequest& database_request() const;
  inline ::quantmodel::DatabaseEngineRequest* mutable_database_request();
  inline ::quantmodel::DatabaseEngineRequest* release_database_request();
  
  // @@protoc_insertion_point(class_scope:quantmodel.ClientAdapterRequest)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_dealing_request();
  inline void clear_has_dealing_request();
  inline void set_has_database_request();
  inline void clear_has_database_request();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* request_id_;
  ::std::string* session_id_;
  ::std::string* timestamp_;
  ::quantmodel::DealingEngineRequest* dealing_request_;
  ::quantmodel::DatabaseEngineRequest* database_request_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static ClientAdapterRequest* default_instance_;
};
// -------------------------------------------------------------------

class ClientAdapterResponse : public ::google::protobuf::Message {
 public:
  ClientAdapterResponse();
  virtual ~ClientAdapterResponse();
  
  ClientAdapterResponse(const ClientAdapterResponse& from);
  
  inline ClientAdapterResponse& operator=(const ClientAdapterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientAdapterResponse& default_instance();
  
  void Swap(ClientAdapterResponse* other);
  
  // implements Message ----------------------------------------------
  
  ClientAdapterResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientAdapterResponse& from);
  void MergeFrom(const ClientAdapterResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientAdapterResponse_ResponseType ResponseType;
  static const ResponseType ACKNOWLEDGEMENT = ClientAdapterResponse_ResponseType_ACKNOWLEDGEMENT;
  static const ResponseType REJECT = ClientAdapterResponse_ResponseType_REJECT;
  static const ResponseType ERROR = ClientAdapterResponse_ResponseType_ERROR;
  static inline bool ResponseType_IsValid(int value) {
    return ClientAdapterResponse_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    ClientAdapterResponse_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    ClientAdapterResponse_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    ClientAdapterResponse_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return ClientAdapterResponse_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return ClientAdapterResponse_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return ClientAdapterResponse_ResponseType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string response_id = 1;
  inline bool has_response_id() const;
  inline void clear_response_id();
  static const int kResponseIdFieldNumber = 1;
  inline const ::std::string& response_id() const;
  inline void set_response_id(const ::std::string& value);
  inline void set_response_id(const char* value);
  inline void set_response_id(const char* value, size_t size);
  inline ::std::string* mutable_response_id();
  inline ::std::string* release_response_id();
  
  // optional string request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  
  // optional string session_id = 3;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional string timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // optional .quantmodel.ClientAdapterResponse.ResponseType type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::quantmodel::ClientAdapterResponse_ResponseType type() const;
  inline void set_type(::quantmodel::ClientAdapterResponse_ResponseType value);
  
  // optional string error_msg = 6;
  inline bool has_error_msg() const;
  inline void clear_error_msg();
  static const int kErrorMsgFieldNumber = 6;
  inline const ::std::string& error_msg() const;
  inline void set_error_msg(const ::std::string& value);
  inline void set_error_msg(const char* value);
  inline void set_error_msg(const char* value, size_t size);
  inline ::std::string* mutable_error_msg();
  inline ::std::string* release_error_msg();
  
  // optional .quantmodel.DealingEngineResponse dealing_response = 7;
  inline bool has_dealing_response() const;
  inline void clear_dealing_response();
  static const int kDealingResponseFieldNumber = 7;
  inline const ::quantmodel::DealingEngineResponse& dealing_response() const;
  inline ::quantmodel::DealingEngineResponse* mutable_dealing_response();
  inline ::quantmodel::DealingEngineResponse* release_dealing_response();
  
  // optional .quantmodel.DatabaseEngineResponse database_response = 8;
  inline bool has_database_response() const;
  inline void clear_database_response();
  static const int kDatabaseResponseFieldNumber = 8;
  inline const ::quantmodel::DatabaseEngineResponse& database_response() const;
  inline ::quantmodel::DatabaseEngineResponse* mutable_database_response();
  inline ::quantmodel::DatabaseEngineResponse* release_database_response();
  
  // @@protoc_insertion_point(class_scope:quantmodel.ClientAdapterResponse)
 private:
  inline void set_has_response_id();
  inline void clear_has_response_id();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();
  inline void set_has_dealing_response();
  inline void clear_has_dealing_response();
  inline void set_has_database_response();
  inline void clear_has_database_response();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* response_id_;
  ::std::string* request_id_;
  ::std::string* session_id_;
  ::std::string* timestamp_;
  ::std::string* error_msg_;
  ::quantmodel::DealingEngineResponse* dealing_response_;
  ::quantmodel::DatabaseEngineResponse* database_response_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static ClientAdapterResponse* default_instance_;
};
// -------------------------------------------------------------------

class ClientAdapterBroadcast : public ::google::protobuf::Message {
 public:
  ClientAdapterBroadcast();
  virtual ~ClientAdapterBroadcast();
  
  ClientAdapterBroadcast(const ClientAdapterBroadcast& from);
  
  inline ClientAdapterBroadcast& operator=(const ClientAdapterBroadcast& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientAdapterBroadcast& default_instance();
  
  void Swap(ClientAdapterBroadcast* other);
  
  // implements Message ----------------------------------------------
  
  ClientAdapterBroadcast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientAdapterBroadcast& from);
  void MergeFrom(const ClientAdapterBroadcast& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef ClientAdapterBroadcast_BroadcastType BroadcastType;
  static const BroadcastType HEARTBEAT = ClientAdapterBroadcast_BroadcastType_HEARTBEAT;
  static const BroadcastType DATABASE = ClientAdapterBroadcast_BroadcastType_DATABASE;
  static const BroadcastType DEALING = ClientAdapterBroadcast_BroadcastType_DEALING;
  static const BroadcastType MARKETDATA = ClientAdapterBroadcast_BroadcastType_MARKETDATA;
  static const BroadcastType SHUTDOWN = ClientAdapterBroadcast_BroadcastType_SHUTDOWN;
  static inline bool BroadcastType_IsValid(int value) {
    return ClientAdapterBroadcast_BroadcastType_IsValid(value);
  }
  static const BroadcastType BroadcastType_MIN =
    ClientAdapterBroadcast_BroadcastType_BroadcastType_MIN;
  static const BroadcastType BroadcastType_MAX =
    ClientAdapterBroadcast_BroadcastType_BroadcastType_MAX;
  static const int BroadcastType_ARRAYSIZE =
    ClientAdapterBroadcast_BroadcastType_BroadcastType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BroadcastType_descriptor() {
    return ClientAdapterBroadcast_BroadcastType_descriptor();
  }
  static inline const ::std::string& BroadcastType_Name(BroadcastType value) {
    return ClientAdapterBroadcast_BroadcastType_Name(value);
  }
  static inline bool BroadcastType_Parse(const ::std::string& name,
      BroadcastType* value) {
    return ClientAdapterBroadcast_BroadcastType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string broadcast_id = 1;
  inline bool has_broadcast_id() const;
  inline void clear_broadcast_id();
  static const int kBroadcastIdFieldNumber = 1;
  inline const ::std::string& broadcast_id() const;
  inline void set_broadcast_id(const ::std::string& value);
  inline void set_broadcast_id(const char* value);
  inline void set_broadcast_id(const char* value, size_t size);
  inline ::std::string* mutable_broadcast_id();
  inline ::std::string* release_broadcast_id();
  
  // optional string timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // optional .quantmodel.ClientAdapterBroadcast.BroadcastType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::quantmodel::ClientAdapterBroadcast_BroadcastType type() const;
  inline void set_type(::quantmodel::ClientAdapterBroadcast_BroadcastType value);
  
  // optional .quantmodel.DealingEngineBroadcast dealing_broadcast = 4;
  inline bool has_dealing_broadcast() const;
  inline void clear_dealing_broadcast();
  static const int kDealingBroadcastFieldNumber = 4;
  inline const ::quantmodel::DealingEngineBroadcast& dealing_broadcast() const;
  inline ::quantmodel::DealingEngineBroadcast* mutable_dealing_broadcast();
  inline ::quantmodel::DealingEngineBroadcast* release_dealing_broadcast();
  
  // optional .quantmodel.MarketDataBroadcast marketdata_broadcast = 5;
  inline bool has_marketdata_broadcast() const;
  inline void clear_marketdata_broadcast();
  static const int kMarketdataBroadcastFieldNumber = 5;
  inline const ::quantmodel::MarketDataBroadcast& marketdata_broadcast() const;
  inline ::quantmodel::MarketDataBroadcast* mutable_marketdata_broadcast();
  inline ::quantmodel::MarketDataBroadcast* release_marketdata_broadcast();
  
  // optional .quantmodel.HeartbeatData heartbeat_data = 6;
  inline bool has_heartbeat_data() const;
  inline void clear_heartbeat_data();
  static const int kHeartbeatDataFieldNumber = 6;
  inline const ::quantmodel::HeartbeatData& heartbeat_data() const;
  inline ::quantmodel::HeartbeatData* mutable_heartbeat_data();
  inline ::quantmodel::HeartbeatData* release_heartbeat_data();
  
  // @@protoc_insertion_point(class_scope:quantmodel.ClientAdapterBroadcast)
 private:
  inline void set_has_broadcast_id();
  inline void clear_has_broadcast_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_dealing_broadcast();
  inline void clear_has_dealing_broadcast();
  inline void set_has_marketdata_broadcast();
  inline void clear_has_marketdata_broadcast();
  inline void set_has_heartbeat_data();
  inline void clear_has_heartbeat_data();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* broadcast_id_;
  ::std::string* timestamp_;
  ::quantmodel::DealingEngineBroadcast* dealing_broadcast_;
  ::quantmodel::MarketDataBroadcast* marketdata_broadcast_;
  ::quantmodel::HeartbeatData* heartbeat_data_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static ClientAdapterBroadcast* default_instance_;
};
// -------------------------------------------------------------------

class InvestmentSystemRequest : public ::google::protobuf::Message {
 public:
  InvestmentSystemRequest();
  virtual ~InvestmentSystemRequest();
  
  InvestmentSystemRequest(const InvestmentSystemRequest& from);
  
  inline InvestmentSystemRequest& operator=(const InvestmentSystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvestmentSystemRequest& default_instance();
  
  void Swap(InvestmentSystemRequest* other);
  
  // implements Message ----------------------------------------------
  
  InvestmentSystemRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvestmentSystemRequest& from);
  void MergeFrom(const InvestmentSystemRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef InvestmentSystemRequest_RequestType RequestType;
  static const RequestType HEARTBEAT = InvestmentSystemRequest_RequestType_HEARTBEAT;
  static const RequestType COMMAND = InvestmentSystemRequest_RequestType_COMMAND;
  static inline bool RequestType_IsValid(int value) {
    return InvestmentSystemRequest_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    InvestmentSystemRequest_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    InvestmentSystemRequest_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    InvestmentSystemRequest_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return InvestmentSystemRequest_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return InvestmentSystemRequest_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return InvestmentSystemRequest_RequestType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  
  // optional string session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional string timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // optional .quantmodel.InvestmentSystemRequest.RequestType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::quantmodel::InvestmentSystemRequest_RequestType type() const;
  inline void set_type(::quantmodel::InvestmentSystemRequest_RequestType value);
  
  // optional string delegate = 5;
  inline bool has_delegate() const;
  inline void clear_delegate();
  static const int kDelegateFieldNumber = 5;
  inline const ::std::string& delegate() const;
  inline void set_delegate(const ::std::string& value);
  inline void set_delegate(const char* value);
  inline void set_delegate(const char* value, size_t size);
  inline ::std::string* mutable_delegate();
  inline ::std::string* release_delegate();
  
  // @@protoc_insertion_point(class_scope:quantmodel.InvestmentSystemRequest)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_delegate();
  inline void clear_has_delegate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* request_id_;
  ::std::string* session_id_;
  ::std::string* timestamp_;
  ::std::string* delegate_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static InvestmentSystemRequest* default_instance_;
};
// -------------------------------------------------------------------

class InvestmentSystemResponse : public ::google::protobuf::Message {
 public:
  InvestmentSystemResponse();
  virtual ~InvestmentSystemResponse();
  
  InvestmentSystemResponse(const InvestmentSystemResponse& from);
  
  inline InvestmentSystemResponse& operator=(const InvestmentSystemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvestmentSystemResponse& default_instance();
  
  void Swap(InvestmentSystemResponse* other);
  
  // implements Message ----------------------------------------------
  
  InvestmentSystemResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvestmentSystemResponse& from);
  void MergeFrom(const InvestmentSystemResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef InvestmentSystemResponse_ResponseType ResponseType;
  static const ResponseType ACKNOWLEDGEMENT = InvestmentSystemResponse_ResponseType_ACKNOWLEDGEMENT;
  static const ResponseType REJECT = InvestmentSystemResponse_ResponseType_REJECT;
  static const ResponseType ERROR = InvestmentSystemResponse_ResponseType_ERROR;
  static inline bool ResponseType_IsValid(int value) {
    return InvestmentSystemResponse_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    InvestmentSystemResponse_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    InvestmentSystemResponse_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    InvestmentSystemResponse_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return InvestmentSystemResponse_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return InvestmentSystemResponse_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return InvestmentSystemResponse_ResponseType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string response_id = 1;
  inline bool has_response_id() const;
  inline void clear_response_id();
  static const int kResponseIdFieldNumber = 1;
  inline const ::std::string& response_id() const;
  inline void set_response_id(const ::std::string& value);
  inline void set_response_id(const char* value);
  inline void set_response_id(const char* value, size_t size);
  inline ::std::string* mutable_response_id();
  inline ::std::string* release_response_id();
  
  // optional string request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  
  // optional string timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // optional .quantmodel.InvestmentSystemResponse.ResponseType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::quantmodel::InvestmentSystemResponse_ResponseType type() const;
  inline void set_type(::quantmodel::InvestmentSystemResponse_ResponseType value);
  
  // optional string error_msg = 5;
  inline bool has_error_msg() const;
  inline void clear_error_msg();
  static const int kErrorMsgFieldNumber = 5;
  inline const ::std::string& error_msg() const;
  inline void set_error_msg(const ::std::string& value);
  inline void set_error_msg(const char* value);
  inline void set_error_msg(const char* value, size_t size);
  inline ::std::string* mutable_error_msg();
  inline ::std::string* release_error_msg();
  
  // optional string session_id = 6;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 6;
  inline const ::std::string& session_id() const;
  inline void set_session_id(const ::std::string& value);
  inline void set_session_id(const char* value);
  inline void set_session_id(const char* value, size_t size);
  inline ::std::string* mutable_session_id();
  inline ::std::string* release_session_id();
  
  // optional bytes delegate = 7;
  inline bool has_delegate() const;
  inline void clear_delegate();
  static const int kDelegateFieldNumber = 7;
  inline const ::std::string& delegate() const;
  inline void set_delegate(const ::std::string& value);
  inline void set_delegate(const char* value);
  inline void set_delegate(const void* value, size_t size);
  inline ::std::string* mutable_delegate();
  inline ::std::string* release_delegate();
  
  // @@protoc_insertion_point(class_scope:quantmodel.InvestmentSystemResponse)
 private:
  inline void set_has_response_id();
  inline void clear_has_response_id();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_delegate();
  inline void clear_has_delegate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* response_id_;
  ::std::string* request_id_;
  ::std::string* timestamp_;
  ::std::string* error_msg_;
  ::std::string* session_id_;
  ::std::string* delegate_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static InvestmentSystemResponse* default_instance_;
};
// -------------------------------------------------------------------

class InvestmentSystemBroadcast : public ::google::protobuf::Message {
 public:
  InvestmentSystemBroadcast();
  virtual ~InvestmentSystemBroadcast();
  
  InvestmentSystemBroadcast(const InvestmentSystemBroadcast& from);
  
  inline InvestmentSystemBroadcast& operator=(const InvestmentSystemBroadcast& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvestmentSystemBroadcast& default_instance();
  
  void Swap(InvestmentSystemBroadcast* other);
  
  // implements Message ----------------------------------------------
  
  InvestmentSystemBroadcast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvestmentSystemBroadcast& from);
  void MergeFrom(const InvestmentSystemBroadcast& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef InvestmentSystemBroadcast_BroadcastType BroadcastType;
  static const BroadcastType PRICE = InvestmentSystemBroadcast_BroadcastType_PRICE;
  static const BroadcastType TRADE = InvestmentSystemBroadcast_BroadcastType_TRADE;
  static const BroadcastType DATA = InvestmentSystemBroadcast_BroadcastType_DATA;
  static const BroadcastType HEARTBEAT = InvestmentSystemBroadcast_BroadcastType_HEARTBEAT;
  static inline bool BroadcastType_IsValid(int value) {
    return InvestmentSystemBroadcast_BroadcastType_IsValid(value);
  }
  static const BroadcastType BroadcastType_MIN =
    InvestmentSystemBroadcast_BroadcastType_BroadcastType_MIN;
  static const BroadcastType BroadcastType_MAX =
    InvestmentSystemBroadcast_BroadcastType_BroadcastType_MAX;
  static const int BroadcastType_ARRAYSIZE =
    InvestmentSystemBroadcast_BroadcastType_BroadcastType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BroadcastType_descriptor() {
    return InvestmentSystemBroadcast_BroadcastType_descriptor();
  }
  static inline const ::std::string& BroadcastType_Name(BroadcastType value) {
    return InvestmentSystemBroadcast_BroadcastType_Name(value);
  }
  static inline bool BroadcastType_Parse(const ::std::string& name,
      BroadcastType* value) {
    return InvestmentSystemBroadcast_BroadcastType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string broadcast_id = 1;
  inline bool has_broadcast_id() const;
  inline void clear_broadcast_id();
  static const int kBroadcastIdFieldNumber = 1;
  inline const ::std::string& broadcast_id() const;
  inline void set_broadcast_id(const ::std::string& value);
  inline void set_broadcast_id(const char* value);
  inline void set_broadcast_id(const char* value, size_t size);
  inline ::std::string* mutable_broadcast_id();
  inline ::std::string* release_broadcast_id();
  
  // optional string timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // optional .quantmodel.InvestmentSystemBroadcast.BroadcastType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::quantmodel::InvestmentSystemBroadcast_BroadcastType type() const;
  inline void set_type(::quantmodel::InvestmentSystemBroadcast_BroadcastType value);
  
  // optional bytes delegate = 4;
  inline bool has_delegate() const;
  inline void clear_delegate();
  static const int kDelegateFieldNumber = 4;
  inline const ::std::string& delegate() const;
  inline void set_delegate(const ::std::string& value);
  inline void set_delegate(const char* value);
  inline void set_delegate(const void* value, size_t size);
  inline ::std::string* mutable_delegate();
  inline ::std::string* release_delegate();
  
  // @@protoc_insertion_point(class_scope:quantmodel.InvestmentSystemBroadcast)
 private:
  inline void set_has_broadcast_id();
  inline void clear_has_broadcast_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_delegate();
  inline void clear_has_delegate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* broadcast_id_;
  ::std::string* timestamp_;
  ::std::string* delegate_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_quantmodel_2eproto();
  friend void protobuf_AssignDesc_quantmodel_2eproto();
  friend void protobuf_ShutdownFile_quantmodel_2eproto();
  
  void InitAsDefaultInstance();
  static InvestmentSystemBroadcast* default_instance_;
};
// ===================================================================


// ===================================================================

// FixMarketData

// optional string instrument_id = 1;
inline bool FixMarketData::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FixMarketData::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FixMarketData::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FixMarketData::clear_instrument_id() {
  if (instrument_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_id_->clear();
  }
  clear_has_instrument_id();
}
inline const ::std::string& FixMarketData::instrument_id() const {
  return *instrument_id_;
}
inline void FixMarketData::set_instrument_id(const ::std::string& value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void FixMarketData::set_instrument_id(const char* value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void FixMarketData::set_instrument_id(const char* value, size_t size) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixMarketData::mutable_instrument_id() {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  return instrument_id_;
}
inline ::std::string* FixMarketData::release_instrument_id() {
  clear_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_id_;
    instrument_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sending_tm = 2;
inline bool FixMarketData::has_sending_tm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FixMarketData::set_has_sending_tm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FixMarketData::clear_has_sending_tm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FixMarketData::clear_sending_tm() {
  if (sending_tm_ != &::google::protobuf::internal::kEmptyString) {
    sending_tm_->clear();
  }
  clear_has_sending_tm();
}
inline const ::std::string& FixMarketData::sending_tm() const {
  return *sending_tm_;
}
inline void FixMarketData::set_sending_tm(const ::std::string& value) {
  set_has_sending_tm();
  if (sending_tm_ == &::google::protobuf::internal::kEmptyString) {
    sending_tm_ = new ::std::string;
  }
  sending_tm_->assign(value);
}
inline void FixMarketData::set_sending_tm(const char* value) {
  set_has_sending_tm();
  if (sending_tm_ == &::google::protobuf::internal::kEmptyString) {
    sending_tm_ = new ::std::string;
  }
  sending_tm_->assign(value);
}
inline void FixMarketData::set_sending_tm(const char* value, size_t size) {
  set_has_sending_tm();
  if (sending_tm_ == &::google::protobuf::internal::kEmptyString) {
    sending_tm_ = new ::std::string;
  }
  sending_tm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixMarketData::mutable_sending_tm() {
  set_has_sending_tm();
  if (sending_tm_ == &::google::protobuf::internal::kEmptyString) {
    sending_tm_ = new ::std::string;
  }
  return sending_tm_;
}
inline ::std::string* FixMarketData::release_sending_tm() {
  clear_has_sending_tm();
  if (sending_tm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sending_tm_;
    sending_tm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.FixMarketData.EntryType entry_type = 3;
inline bool FixMarketData::has_entry_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FixMarketData::set_has_entry_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FixMarketData::clear_has_entry_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FixMarketData::clear_entry_type() {
  entry_type_ = 1;
  clear_has_entry_type();
}
inline ::quantmodel::FixMarketData_EntryType FixMarketData::entry_type() const {
  return static_cast< ::quantmodel::FixMarketData_EntryType >(entry_type_);
}
inline void FixMarketData::set_entry_type(::quantmodel::FixMarketData_EntryType value) {
  GOOGLE_DCHECK(::quantmodel::FixMarketData_EntryType_IsValid(value));
  set_has_entry_type();
  entry_type_ = value;
}

// optional string update_action = 4;
inline bool FixMarketData::has_update_action() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FixMarketData::set_has_update_action() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FixMarketData::clear_has_update_action() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FixMarketData::clear_update_action() {
  if (update_action_ != &::google::protobuf::internal::kEmptyString) {
    update_action_->clear();
  }
  clear_has_update_action();
}
inline const ::std::string& FixMarketData::update_action() const {
  return *update_action_;
}
inline void FixMarketData::set_update_action(const ::std::string& value) {
  set_has_update_action();
  if (update_action_ == &::google::protobuf::internal::kEmptyString) {
    update_action_ = new ::std::string;
  }
  update_action_->assign(value);
}
inline void FixMarketData::set_update_action(const char* value) {
  set_has_update_action();
  if (update_action_ == &::google::protobuf::internal::kEmptyString) {
    update_action_ = new ::std::string;
  }
  update_action_->assign(value);
}
inline void FixMarketData::set_update_action(const char* value, size_t size) {
  set_has_update_action();
  if (update_action_ == &::google::protobuf::internal::kEmptyString) {
    update_action_ = new ::std::string;
  }
  update_action_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixMarketData::mutable_update_action() {
  set_has_update_action();
  if (update_action_ == &::google::protobuf::internal::kEmptyString) {
    update_action_ = new ::std::string;
  }
  return update_action_;
}
inline ::std::string* FixMarketData::release_update_action() {
  clear_has_update_action();
  if (update_action_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = update_action_;
    update_action_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string entry_px = 5 [default = "0"];
inline bool FixMarketData::has_entry_px() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FixMarketData::set_has_entry_px() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FixMarketData::clear_has_entry_px() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FixMarketData::clear_entry_px() {
  if (entry_px_ != &_default_entry_px_) {
    entry_px_->assign(_default_entry_px_);
  }
  clear_has_entry_px();
}
inline const ::std::string& FixMarketData::entry_px() const {
  return *entry_px_;
}
inline void FixMarketData::set_entry_px(const ::std::string& value) {
  set_has_entry_px();
  if (entry_px_ == &_default_entry_px_) {
    entry_px_ = new ::std::string;
  }
  entry_px_->assign(value);
}
inline void FixMarketData::set_entry_px(const char* value) {
  set_has_entry_px();
  if (entry_px_ == &_default_entry_px_) {
    entry_px_ = new ::std::string;
  }
  entry_px_->assign(value);
}
inline void FixMarketData::set_entry_px(const char* value, size_t size) {
  set_has_entry_px();
  if (entry_px_ == &_default_entry_px_) {
    entry_px_ = new ::std::string;
  }
  entry_px_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixMarketData::mutable_entry_px() {
  set_has_entry_px();
  if (entry_px_ == &_default_entry_px_) {
    entry_px_ = new ::std::string(_default_entry_px_);
  }
  return entry_px_;
}
inline ::std::string* FixMarketData::release_entry_px() {
  clear_has_entry_px();
  if (entry_px_ == &_default_entry_px_) {
    return NULL;
  } else {
    ::std::string* temp = entry_px_;
    entry_px_ = const_cast< ::std::string*>(&_default_entry_px_);
    return temp;
  }
}

// optional string entry_size = 6 [default = "0"];
inline bool FixMarketData::has_entry_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FixMarketData::set_has_entry_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FixMarketData::clear_has_entry_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FixMarketData::clear_entry_size() {
  if (entry_size_ != &_default_entry_size_) {
    entry_size_->assign(_default_entry_size_);
  }
  clear_has_entry_size();
}
inline const ::std::string& FixMarketData::entry_size() const {
  return *entry_size_;
}
inline void FixMarketData::set_entry_size(const ::std::string& value) {
  set_has_entry_size();
  if (entry_size_ == &_default_entry_size_) {
    entry_size_ = new ::std::string;
  }
  entry_size_->assign(value);
}
inline void FixMarketData::set_entry_size(const char* value) {
  set_has_entry_size();
  if (entry_size_ == &_default_entry_size_) {
    entry_size_ = new ::std::string;
  }
  entry_size_->assign(value);
}
inline void FixMarketData::set_entry_size(const char* value, size_t size) {
  set_has_entry_size();
  if (entry_size_ == &_default_entry_size_) {
    entry_size_ = new ::std::string;
  }
  entry_size_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixMarketData::mutable_entry_size() {
  set_has_entry_size();
  if (entry_size_ == &_default_entry_size_) {
    entry_size_ = new ::std::string(_default_entry_size_);
  }
  return entry_size_;
}
inline ::std::string* FixMarketData::release_entry_size() {
  clear_has_entry_size();
  if (entry_size_ == &_default_entry_size_) {
    return NULL;
  } else {
    ::std::string* temp = entry_size_;
    entry_size_ = const_cast< ::std::string*>(&_default_entry_size_);
    return temp;
  }
}

// -------------------------------------------------------------------

// CMEMarketData

// required uint64 sending_tm = 1;
inline bool CMEMarketData::has_sending_tm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMEMarketData::set_has_sending_tm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMEMarketData::clear_has_sending_tm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMEMarketData::clear_sending_tm() {
  sending_tm_ = GOOGLE_ULONGLONG(0);
  clear_has_sending_tm();
}
inline ::google::protobuf::uint64 CMEMarketData::sending_tm() const {
  return sending_tm_;
}
inline void CMEMarketData::set_sending_tm(::google::protobuf::uint64 value) {
  set_has_sending_tm();
  sending_tm_ = value;
}

// required uint32 security_id = 2;
inline bool CMEMarketData::has_security_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMEMarketData::set_has_security_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMEMarketData::clear_has_security_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMEMarketData::clear_security_id() {
  security_id_ = 0u;
  clear_has_security_id();
}
inline ::google::protobuf::uint32 CMEMarketData::security_id() const {
  return security_id_;
}
inline void CMEMarketData::set_security_id(::google::protobuf::uint32 value) {
  set_has_security_id();
  security_id_ = value;
}

// required .quantmodel.CMEMarketData.UpdateAction update_action = 3;
inline bool CMEMarketData::has_update_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CMEMarketData::set_has_update_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CMEMarketData::clear_has_update_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CMEMarketData::clear_update_action() {
  update_action_ = 0;
  clear_has_update_action();
}
inline ::quantmodel::CMEMarketData_UpdateAction CMEMarketData::update_action() const {
  return static_cast< ::quantmodel::CMEMarketData_UpdateAction >(update_action_);
}
inline void CMEMarketData::set_update_action(::quantmodel::CMEMarketData_UpdateAction value) {
  GOOGLE_DCHECK(::quantmodel::CMEMarketData_UpdateAction_IsValid(value));
  set_has_update_action();
  update_action_ = value;
}

// required .quantmodel.CMEMarketData.EntryType entry_type = 4;
inline bool CMEMarketData::has_entry_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CMEMarketData::set_has_entry_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CMEMarketData::clear_has_entry_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CMEMarketData::clear_entry_type() {
  entry_type_ = 0;
  clear_has_entry_type();
}
inline ::quantmodel::CMEMarketData_EntryType CMEMarketData::entry_type() const {
  return static_cast< ::quantmodel::CMEMarketData_EntryType >(entry_type_);
}
inline void CMEMarketData::set_entry_type(::quantmodel::CMEMarketData_EntryType value) {
  GOOGLE_DCHECK(::quantmodel::CMEMarketData_EntryType_IsValid(value));
  set_has_entry_type();
  entry_type_ = value;
}

// required bool is_implied = 5;
inline bool CMEMarketData::has_is_implied() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CMEMarketData::set_has_is_implied() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CMEMarketData::clear_has_is_implied() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CMEMarketData::clear_is_implied() {
  is_implied_ = false;
  clear_has_is_implied();
}
inline bool CMEMarketData::is_implied() const {
  return is_implied_;
}
inline void CMEMarketData::set_is_implied(bool value) {
  set_has_is_implied();
  is_implied_ = value;
}

// optional int32 entry_size = 6 [default = 0];
inline bool CMEMarketData::has_entry_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CMEMarketData::set_has_entry_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CMEMarketData::clear_has_entry_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CMEMarketData::clear_entry_size() {
  entry_size_ = 0;
  clear_has_entry_size();
}
inline ::google::protobuf::int32 CMEMarketData::entry_size() const {
  return entry_size_;
}
inline void CMEMarketData::set_entry_size(::google::protobuf::int32 value) {
  set_has_entry_size();
  entry_size_ = value;
}

// optional string entry_px = 7 [default = "0", deprecated = true];
inline bool CMEMarketData::has_entry_px() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CMEMarketData::set_has_entry_px() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CMEMarketData::clear_has_entry_px() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CMEMarketData::clear_entry_px() {
  if (entry_px_ != &_default_entry_px_) {
    entry_px_->assign(_default_entry_px_);
  }
  clear_has_entry_px();
}
inline const ::std::string& CMEMarketData::entry_px() const {
  return *entry_px_;
}
inline void CMEMarketData::set_entry_px(const ::std::string& value) {
  set_has_entry_px();
  if (entry_px_ == &_default_entry_px_) {
    entry_px_ = new ::std::string;
  }
  entry_px_->assign(value);
}
inline void CMEMarketData::set_entry_px(const char* value) {
  set_has_entry_px();
  if (entry_px_ == &_default_entry_px_) {
    entry_px_ = new ::std::string;
  }
  entry_px_->assign(value);
}
inline void CMEMarketData::set_entry_px(const char* value, size_t size) {
  set_has_entry_px();
  if (entry_px_ == &_default_entry_px_) {
    entry_px_ = new ::std::string;
  }
  entry_px_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMEMarketData::mutable_entry_px() {
  set_has_entry_px();
  if (entry_px_ == &_default_entry_px_) {
    entry_px_ = new ::std::string(_default_entry_px_);
  }
  return entry_px_;
}
inline ::std::string* CMEMarketData::release_entry_px() {
  clear_has_entry_px();
  if (entry_px_ == &_default_entry_px_) {
    return NULL;
  } else {
    ::std::string* temp = entry_px_;
    entry_px_ = const_cast< ::std::string*>(&_default_entry_px_);
    return temp;
  }
}

// optional uint32 orders = 8 [default = 0];
inline bool CMEMarketData::has_orders() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CMEMarketData::set_has_orders() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CMEMarketData::clear_has_orders() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CMEMarketData::clear_orders() {
  orders_ = 0u;
  clear_has_orders();
}
inline ::google::protobuf::uint32 CMEMarketData::orders() const {
  return orders_;
}
inline void CMEMarketData::set_orders(::google::protobuf::uint32 value) {
  set_has_orders();
  orders_ = value;
}

// optional uint32 price_level = 9 [default = 0];
inline bool CMEMarketData::has_price_level() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CMEMarketData::set_has_price_level() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CMEMarketData::clear_has_price_level() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CMEMarketData::clear_price_level() {
  price_level_ = 0u;
  clear_has_price_level();
}
inline ::google::protobuf::uint32 CMEMarketData::price_level() const {
  return price_level_;
}
inline void CMEMarketData::set_price_level(::google::protobuf::uint32 value) {
  set_has_price_level();
  price_level_ = value;
}

// optional uint32 entry_tm = 10 [default = 0];
inline bool CMEMarketData::has_entry_tm() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CMEMarketData::set_has_entry_tm() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CMEMarketData::clear_has_entry_tm() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CMEMarketData::clear_entry_tm() {
  entry_tm_ = 0u;
  clear_has_entry_tm();
}
inline ::google::protobuf::uint32 CMEMarketData::entry_tm() const {
  return entry_tm_;
}
inline void CMEMarketData::set_entry_tm(::google::protobuf::uint32 value) {
  set_has_entry_tm();
  entry_tm_ = value;
}

// optional .quantmodel.CMEMarketData.AggressorType aggressor = 11 [default = UNKNOWN];
inline bool CMEMarketData::has_aggressor() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CMEMarketData::set_has_aggressor() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CMEMarketData::clear_has_aggressor() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CMEMarketData::clear_aggressor() {
  aggressor_ = 0;
  clear_has_aggressor();
}
inline ::quantmodel::CMEMarketData_AggressorType CMEMarketData::aggressor() const {
  return static_cast< ::quantmodel::CMEMarketData_AggressorType >(aggressor_);
}
inline void CMEMarketData::set_aggressor(::quantmodel::CMEMarketData_AggressorType value) {
  GOOGLE_DCHECK(::quantmodel::CMEMarketData_AggressorType_IsValid(value));
  set_has_aggressor();
  aggressor_ = value;
}

// optional int64 mantissa = 12 [default = 0];
inline bool CMEMarketData::has_mantissa() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CMEMarketData::set_has_mantissa() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CMEMarketData::clear_has_mantissa() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CMEMarketData::clear_mantissa() {
  mantissa_ = GOOGLE_LONGLONG(0);
  clear_has_mantissa();
}
inline ::google::protobuf::int64 CMEMarketData::mantissa() const {
  return mantissa_;
}
inline void CMEMarketData::set_mantissa(::google::protobuf::int64 value) {
  set_has_mantissa();
  mantissa_ = value;
}

// optional int32 exponent = 13 [default = 0];
inline bool CMEMarketData::has_exponent() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CMEMarketData::set_has_exponent() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CMEMarketData::clear_has_exponent() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CMEMarketData::clear_exponent() {
  exponent_ = 0;
  clear_has_exponent();
}
inline ::google::protobuf::int32 CMEMarketData::exponent() const {
  return exponent_;
}
inline void CMEMarketData::set_exponent(::google::protobuf::int32 value) {
  set_has_exponent();
  exponent_ = value;
}

// -------------------------------------------------------------------

// FastEngineBroadcast

// required string timestamp = 1;
inline bool FastEngineBroadcast::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FastEngineBroadcast::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FastEngineBroadcast::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FastEngineBroadcast::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& FastEngineBroadcast::timestamp() const {
  return *timestamp_;
}
inline void FastEngineBroadcast::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void FastEngineBroadcast::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void FastEngineBroadcast::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FastEngineBroadcast::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* FastEngineBroadcast::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .quantmodel.FastEngineBroadcast.BroadcastType broadcast_type = 2;
inline bool FastEngineBroadcast::has_broadcast_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FastEngineBroadcast::set_has_broadcast_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FastEngineBroadcast::clear_has_broadcast_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FastEngineBroadcast::clear_broadcast_type() {
  broadcast_type_ = 1;
  clear_has_broadcast_type();
}
inline ::quantmodel::FastEngineBroadcast_BroadcastType FastEngineBroadcast::broadcast_type() const {
  return static_cast< ::quantmodel::FastEngineBroadcast_BroadcastType >(broadcast_type_);
}
inline void FastEngineBroadcast::set_broadcast_type(::quantmodel::FastEngineBroadcast_BroadcastType value) {
  GOOGLE_DCHECK(::quantmodel::FastEngineBroadcast_BroadcastType_IsValid(value));
  set_has_broadcast_type();
  broadcast_type_ = value;
}

// repeated .quantmodel.CMEMarketData cme_market_data = 3;
inline int FastEngineBroadcast::cme_market_data_size() const {
  return cme_market_data_.size();
}
inline void FastEngineBroadcast::clear_cme_market_data() {
  cme_market_data_.Clear();
}
inline const ::quantmodel::CMEMarketData& FastEngineBroadcast::cme_market_data(int index) const {
  return cme_market_data_.Get(index);
}
inline ::quantmodel::CMEMarketData* FastEngineBroadcast::mutable_cme_market_data(int index) {
  return cme_market_data_.Mutable(index);
}
inline ::quantmodel::CMEMarketData* FastEngineBroadcast::add_cme_market_data() {
  return cme_market_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::CMEMarketData >&
FastEngineBroadcast::cme_market_data() const {
  return cme_market_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::CMEMarketData >*
FastEngineBroadcast::mutable_cme_market_data() {
  return &cme_market_data_;
}

// -------------------------------------------------------------------

// FixEngineBroadcast

// optional string timestamp = 1;
inline bool FixEngineBroadcast::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FixEngineBroadcast::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FixEngineBroadcast::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FixEngineBroadcast::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& FixEngineBroadcast::timestamp() const {
  return *timestamp_;
}
inline void FixEngineBroadcast::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void FixEngineBroadcast::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void FixEngineBroadcast::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixEngineBroadcast::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* FixEngineBroadcast::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string instrument_id = 2;
inline bool FixEngineBroadcast::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FixEngineBroadcast::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FixEngineBroadcast::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FixEngineBroadcast::clear_instrument_id() {
  if (instrument_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_id_->clear();
  }
  clear_has_instrument_id();
}
inline const ::std::string& FixEngineBroadcast::instrument_id() const {
  return *instrument_id_;
}
inline void FixEngineBroadcast::set_instrument_id(const ::std::string& value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void FixEngineBroadcast::set_instrument_id(const char* value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void FixEngineBroadcast::set_instrument_id(const char* value, size_t size) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixEngineBroadcast::mutable_instrument_id() {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  return instrument_id_;
}
inline ::std::string* FixEngineBroadcast::release_instrument_id() {
  clear_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_id_;
    instrument_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .quantmodel.FixMarketData fix_market_data = 3;
inline int FixEngineBroadcast::fix_market_data_size() const {
  return fix_market_data_.size();
}
inline void FixEngineBroadcast::clear_fix_market_data() {
  fix_market_data_.Clear();
}
inline const ::quantmodel::FixMarketData& FixEngineBroadcast::fix_market_data(int index) const {
  return fix_market_data_.Get(index);
}
inline ::quantmodel::FixMarketData* FixEngineBroadcast::mutable_fix_market_data(int index) {
  return fix_market_data_.Mutable(index);
}
inline ::quantmodel::FixMarketData* FixEngineBroadcast::add_fix_market_data() {
  return fix_market_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::FixMarketData >&
FixEngineBroadcast::fix_market_data() const {
  return fix_market_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::FixMarketData >*
FixEngineBroadcast::mutable_fix_market_data() {
  return &fix_market_data_;
}

// -------------------------------------------------------------------

// MarketDataPriceData

// optional string instrument_id = 1;
inline bool MarketDataPriceData::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataPriceData::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataPriceData::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataPriceData::clear_instrument_id() {
  if (instrument_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_id_->clear();
  }
  clear_has_instrument_id();
}
inline const ::std::string& MarketDataPriceData::instrument_id() const {
  return *instrument_id_;
}
inline void MarketDataPriceData::set_instrument_id(const ::std::string& value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void MarketDataPriceData::set_instrument_id(const char* value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void MarketDataPriceData::set_instrument_id(const char* value, size_t size) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketDataPriceData::mutable_instrument_id() {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  return instrument_id_;
}
inline ::std::string* MarketDataPriceData::release_instrument_id() {
  clear_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_id_;
    instrument_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string last_prc = 2 [default = "0.0"];
inline bool MarketDataPriceData::has_last_prc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataPriceData::set_has_last_prc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataPriceData::clear_has_last_prc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataPriceData::clear_last_prc() {
  if (last_prc_ != &_default_last_prc_) {
    last_prc_->assign(_default_last_prc_);
  }
  clear_has_last_prc();
}
inline const ::std::string& MarketDataPriceData::last_prc() const {
  return *last_prc_;
}
inline void MarketDataPriceData::set_last_prc(const ::std::string& value) {
  set_has_last_prc();
  if (last_prc_ == &_default_last_prc_) {
    last_prc_ = new ::std::string;
  }
  last_prc_->assign(value);
}
inline void MarketDataPriceData::set_last_prc(const char* value) {
  set_has_last_prc();
  if (last_prc_ == &_default_last_prc_) {
    last_prc_ = new ::std::string;
  }
  last_prc_->assign(value);
}
inline void MarketDataPriceData::set_last_prc(const char* value, size_t size) {
  set_has_last_prc();
  if (last_prc_ == &_default_last_prc_) {
    last_prc_ = new ::std::string;
  }
  last_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketDataPriceData::mutable_last_prc() {
  set_has_last_prc();
  if (last_prc_ == &_default_last_prc_) {
    last_prc_ = new ::std::string(_default_last_prc_);
  }
  return last_prc_;
}
inline ::std::string* MarketDataPriceData::release_last_prc() {
  clear_has_last_prc();
  if (last_prc_ == &_default_last_prc_) {
    return NULL;
  } else {
    ::std::string* temp = last_prc_;
    last_prc_ = const_cast< ::std::string*>(&_default_last_prc_);
    return temp;
  }
}

// -------------------------------------------------------------------

// MarketDataTradeData

// optional string instrument_id = 1;
inline bool MarketDataTradeData::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataTradeData::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataTradeData::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataTradeData::clear_instrument_id() {
  if (instrument_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_id_->clear();
  }
  clear_has_instrument_id();
}
inline const ::std::string& MarketDataTradeData::instrument_id() const {
  return *instrument_id_;
}
inline void MarketDataTradeData::set_instrument_id(const ::std::string& value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void MarketDataTradeData::set_instrument_id(const char* value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void MarketDataTradeData::set_instrument_id(const char* value, size_t size) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketDataTradeData::mutable_instrument_id() {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  return instrument_id_;
}
inline ::std::string* MarketDataTradeData::release_instrument_id() {
  clear_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_id_;
    instrument_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.MarketDataTradeData.AggressorType aggressor = 2 [default = UNKNOWN];
inline bool MarketDataTradeData::has_aggressor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataTradeData::set_has_aggressor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataTradeData::clear_has_aggressor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataTradeData::clear_aggressor() {
  aggressor_ = 0;
  clear_has_aggressor();
}
inline ::quantmodel::MarketDataTradeData_AggressorType MarketDataTradeData::aggressor() const {
  return static_cast< ::quantmodel::MarketDataTradeData_AggressorType >(aggressor_);
}
inline void MarketDataTradeData::set_aggressor(::quantmodel::MarketDataTradeData_AggressorType value) {
  GOOGLE_DCHECK(::quantmodel::MarketDataTradeData_AggressorType_IsValid(value));
  set_has_aggressor();
  aggressor_ = value;
}

// optional string trade_prc = 3 [default = "0.0"];
inline bool MarketDataTradeData::has_trade_prc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataTradeData::set_has_trade_prc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataTradeData::clear_has_trade_prc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataTradeData::clear_trade_prc() {
  if (trade_prc_ != &_default_trade_prc_) {
    trade_prc_->assign(_default_trade_prc_);
  }
  clear_has_trade_prc();
}
inline const ::std::string& MarketDataTradeData::trade_prc() const {
  return *trade_prc_;
}
inline void MarketDataTradeData::set_trade_prc(const ::std::string& value) {
  set_has_trade_prc();
  if (trade_prc_ == &_default_trade_prc_) {
    trade_prc_ = new ::std::string;
  }
  trade_prc_->assign(value);
}
inline void MarketDataTradeData::set_trade_prc(const char* value) {
  set_has_trade_prc();
  if (trade_prc_ == &_default_trade_prc_) {
    trade_prc_ = new ::std::string;
  }
  trade_prc_->assign(value);
}
inline void MarketDataTradeData::set_trade_prc(const char* value, size_t size) {
  set_has_trade_prc();
  if (trade_prc_ == &_default_trade_prc_) {
    trade_prc_ = new ::std::string;
  }
  trade_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketDataTradeData::mutable_trade_prc() {
  set_has_trade_prc();
  if (trade_prc_ == &_default_trade_prc_) {
    trade_prc_ = new ::std::string(_default_trade_prc_);
  }
  return trade_prc_;
}
inline ::std::string* MarketDataTradeData::release_trade_prc() {
  clear_has_trade_prc();
  if (trade_prc_ == &_default_trade_prc_) {
    return NULL;
  } else {
    ::std::string* temp = trade_prc_;
    trade_prc_ = const_cast< ::std::string*>(&_default_trade_prc_);
    return temp;
  }
}

// optional int32 trade_qty = 4 [default = 0];
inline bool MarketDataTradeData::has_trade_qty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataTradeData::set_has_trade_qty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataTradeData::clear_has_trade_qty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataTradeData::clear_trade_qty() {
  trade_qty_ = 0;
  clear_has_trade_qty();
}
inline ::google::protobuf::int32 MarketDataTradeData::trade_qty() const {
  return trade_qty_;
}
inline void MarketDataTradeData::set_trade_qty(::google::protobuf::int32 value) {
  set_has_trade_qty();
  trade_qty_ = value;
}

// optional uint32 entry_tm = 5;
inline bool MarketDataTradeData::has_entry_tm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataTradeData::set_has_entry_tm() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataTradeData::clear_has_entry_tm() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataTradeData::clear_entry_tm() {
  entry_tm_ = 0u;
  clear_has_entry_tm();
}
inline ::google::protobuf::uint32 MarketDataTradeData::entry_tm() const {
  return entry_tm_;
}
inline void MarketDataTradeData::set_entry_tm(::google::protobuf::uint32 value) {
  set_has_entry_tm();
  entry_tm_ = value;
}

// -------------------------------------------------------------------

// MarketDataQuoteData

// optional string instrument_id = 1;
inline bool MarketDataQuoteData::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataQuoteData::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataQuoteData::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataQuoteData::clear_instrument_id() {
  if (instrument_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_id_->clear();
  }
  clear_has_instrument_id();
}
inline const ::std::string& MarketDataQuoteData::instrument_id() const {
  return *instrument_id_;
}
inline void MarketDataQuoteData::set_instrument_id(const ::std::string& value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void MarketDataQuoteData::set_instrument_id(const char* value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void MarketDataQuoteData::set_instrument_id(const char* value, size_t size) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketDataQuoteData::mutable_instrument_id() {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  return instrument_id_;
}
inline ::std::string* MarketDataQuoteData::release_instrument_id() {
  clear_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_id_;
    instrument_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.MarketDataQuoteData.QuoteType type = 2;
inline bool MarketDataQuoteData::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataQuoteData::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataQuoteData::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataQuoteData::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::quantmodel::MarketDataQuoteData_QuoteType MarketDataQuoteData::type() const {
  return static_cast< ::quantmodel::MarketDataQuoteData_QuoteType >(type_);
}
inline void MarketDataQuoteData::set_type(::quantmodel::MarketDataQuoteData_QuoteType value) {
  GOOGLE_DCHECK(::quantmodel::MarketDataQuoteData_QuoteType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string quote_prc = 3 [default = "0.0"];
inline bool MarketDataQuoteData::has_quote_prc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataQuoteData::set_has_quote_prc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataQuoteData::clear_has_quote_prc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataQuoteData::clear_quote_prc() {
  if (quote_prc_ != &_default_quote_prc_) {
    quote_prc_->assign(_default_quote_prc_);
  }
  clear_has_quote_prc();
}
inline const ::std::string& MarketDataQuoteData::quote_prc() const {
  return *quote_prc_;
}
inline void MarketDataQuoteData::set_quote_prc(const ::std::string& value) {
  set_has_quote_prc();
  if (quote_prc_ == &_default_quote_prc_) {
    quote_prc_ = new ::std::string;
  }
  quote_prc_->assign(value);
}
inline void MarketDataQuoteData::set_quote_prc(const char* value) {
  set_has_quote_prc();
  if (quote_prc_ == &_default_quote_prc_) {
    quote_prc_ = new ::std::string;
  }
  quote_prc_->assign(value);
}
inline void MarketDataQuoteData::set_quote_prc(const char* value, size_t size) {
  set_has_quote_prc();
  if (quote_prc_ == &_default_quote_prc_) {
    quote_prc_ = new ::std::string;
  }
  quote_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketDataQuoteData::mutable_quote_prc() {
  set_has_quote_prc();
  if (quote_prc_ == &_default_quote_prc_) {
    quote_prc_ = new ::std::string(_default_quote_prc_);
  }
  return quote_prc_;
}
inline ::std::string* MarketDataQuoteData::release_quote_prc() {
  clear_has_quote_prc();
  if (quote_prc_ == &_default_quote_prc_) {
    return NULL;
  } else {
    ::std::string* temp = quote_prc_;
    quote_prc_ = const_cast< ::std::string*>(&_default_quote_prc_);
    return temp;
  }
}

// optional int32 quote_qty = 4 [default = 0];
inline bool MarketDataQuoteData::has_quote_qty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketDataQuoteData::set_has_quote_qty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketDataQuoteData::clear_has_quote_qty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketDataQuoteData::clear_quote_qty() {
  quote_qty_ = 0;
  clear_has_quote_qty();
}
inline ::google::protobuf::int32 MarketDataQuoteData::quote_qty() const {
  return quote_qty_;
}
inline void MarketDataQuoteData::set_quote_qty(::google::protobuf::int32 value) {
  set_has_quote_qty();
  quote_qty_ = value;
}

// optional int32 level = 5 [default = 0];
inline bool MarketDataQuoteData::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketDataQuoteData::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketDataQuoteData::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketDataQuoteData::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 MarketDataQuoteData::level() const {
  return level_;
}
inline void MarketDataQuoteData::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// MarketDataBroadcast

// optional string broadcast_id = 1;
inline bool MarketDataBroadcast::has_broadcast_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataBroadcast::set_has_broadcast_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataBroadcast::clear_has_broadcast_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataBroadcast::clear_broadcast_id() {
  if (broadcast_id_ != &::google::protobuf::internal::kEmptyString) {
    broadcast_id_->clear();
  }
  clear_has_broadcast_id();
}
inline const ::std::string& MarketDataBroadcast::broadcast_id() const {
  return *broadcast_id_;
}
inline void MarketDataBroadcast::set_broadcast_id(const ::std::string& value) {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  broadcast_id_->assign(value);
}
inline void MarketDataBroadcast::set_broadcast_id(const char* value) {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  broadcast_id_->assign(value);
}
inline void MarketDataBroadcast::set_broadcast_id(const char* value, size_t size) {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  broadcast_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketDataBroadcast::mutable_broadcast_id() {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  return broadcast_id_;
}
inline ::std::string* MarketDataBroadcast::release_broadcast_id() {
  clear_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = broadcast_id_;
    broadcast_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 2;
inline bool MarketDataBroadcast::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataBroadcast::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataBroadcast::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataBroadcast::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& MarketDataBroadcast::timestamp() const {
  return *timestamp_;
}
inline void MarketDataBroadcast::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void MarketDataBroadcast::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void MarketDataBroadcast::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketDataBroadcast::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* MarketDataBroadcast::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.MarketDataBroadcast.BroadcastType type = 3;
inline bool MarketDataBroadcast::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataBroadcast::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataBroadcast::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataBroadcast::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::quantmodel::MarketDataBroadcast_BroadcastType MarketDataBroadcast::type() const {
  return static_cast< ::quantmodel::MarketDataBroadcast_BroadcastType >(type_);
}
inline void MarketDataBroadcast::set_type(::quantmodel::MarketDataBroadcast_BroadcastType value) {
  GOOGLE_DCHECK(::quantmodel::MarketDataBroadcast_BroadcastType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .quantmodel.MarketDataPriceData price_data = 5;
inline int MarketDataBroadcast::price_data_size() const {
  return price_data_.size();
}
inline void MarketDataBroadcast::clear_price_data() {
  price_data_.Clear();
}
inline const ::quantmodel::MarketDataPriceData& MarketDataBroadcast::price_data(int index) const {
  return price_data_.Get(index);
}
inline ::quantmodel::MarketDataPriceData* MarketDataBroadcast::mutable_price_data(int index) {
  return price_data_.Mutable(index);
}
inline ::quantmodel::MarketDataPriceData* MarketDataBroadcast::add_price_data() {
  return price_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataPriceData >&
MarketDataBroadcast::price_data() const {
  return price_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataPriceData >*
MarketDataBroadcast::mutable_price_data() {
  return &price_data_;
}

// repeated .quantmodel.MarketDataTradeData trade_data = 6;
inline int MarketDataBroadcast::trade_data_size() const {
  return trade_data_.size();
}
inline void MarketDataBroadcast::clear_trade_data() {
  trade_data_.Clear();
}
inline const ::quantmodel::MarketDataTradeData& MarketDataBroadcast::trade_data(int index) const {
  return trade_data_.Get(index);
}
inline ::quantmodel::MarketDataTradeData* MarketDataBroadcast::mutable_trade_data(int index) {
  return trade_data_.Mutable(index);
}
inline ::quantmodel::MarketDataTradeData* MarketDataBroadcast::add_trade_data() {
  return trade_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataTradeData >&
MarketDataBroadcast::trade_data() const {
  return trade_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataTradeData >*
MarketDataBroadcast::mutable_trade_data() {
  return &trade_data_;
}

// repeated .quantmodel.MarketDataQuoteData quote_data = 7;
inline int MarketDataBroadcast::quote_data_size() const {
  return quote_data_.size();
}
inline void MarketDataBroadcast::clear_quote_data() {
  quote_data_.Clear();
}
inline const ::quantmodel::MarketDataQuoteData& MarketDataBroadcast::quote_data(int index) const {
  return quote_data_.Get(index);
}
inline ::quantmodel::MarketDataQuoteData* MarketDataBroadcast::mutable_quote_data(int index) {
  return quote_data_.Mutable(index);
}
inline ::quantmodel::MarketDataQuoteData* MarketDataBroadcast::add_quote_data() {
  return quote_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataQuoteData >&
MarketDataBroadcast::quote_data() const {
  return quote_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::MarketDataQuoteData >*
MarketDataBroadcast::mutable_quote_data() {
  return &quote_data_;
}

// -------------------------------------------------------------------

// HeartbeatData

// optional string heartbeat_id = 1;
inline bool HeartbeatData::has_heartbeat_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatData::set_has_heartbeat_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatData::clear_has_heartbeat_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatData::clear_heartbeat_id() {
  if (heartbeat_id_ != &::google::protobuf::internal::kEmptyString) {
    heartbeat_id_->clear();
  }
  clear_has_heartbeat_id();
}
inline const ::std::string& HeartbeatData::heartbeat_id() const {
  return *heartbeat_id_;
}
inline void HeartbeatData::set_heartbeat_id(const ::std::string& value) {
  set_has_heartbeat_id();
  if (heartbeat_id_ == &::google::protobuf::internal::kEmptyString) {
    heartbeat_id_ = new ::std::string;
  }
  heartbeat_id_->assign(value);
}
inline void HeartbeatData::set_heartbeat_id(const char* value) {
  set_has_heartbeat_id();
  if (heartbeat_id_ == &::google::protobuf::internal::kEmptyString) {
    heartbeat_id_ = new ::std::string;
  }
  heartbeat_id_->assign(value);
}
inline void HeartbeatData::set_heartbeat_id(const char* value, size_t size) {
  set_has_heartbeat_id();
  if (heartbeat_id_ == &::google::protobuf::internal::kEmptyString) {
    heartbeat_id_ = new ::std::string;
  }
  heartbeat_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeartbeatData::mutable_heartbeat_id() {
  set_has_heartbeat_id();
  if (heartbeat_id_ == &::google::protobuf::internal::kEmptyString) {
    heartbeat_id_ = new ::std::string;
  }
  return heartbeat_id_;
}
inline ::std::string* HeartbeatData::release_heartbeat_id() {
  clear_has_heartbeat_id();
  if (heartbeat_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = heartbeat_id_;
    heartbeat_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 2;
inline bool HeartbeatData::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatData::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatData::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatData::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& HeartbeatData::timestamp() const {
  return *timestamp_;
}
inline void HeartbeatData::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void HeartbeatData::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void HeartbeatData::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeartbeatData::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* HeartbeatData::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FixEngineData

// optional string fix_engine_id = 1;
inline bool FixEngineData::has_fix_engine_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FixEngineData::set_has_fix_engine_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FixEngineData::clear_has_fix_engine_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FixEngineData::clear_fix_engine_id() {
  if (fix_engine_id_ != &::google::protobuf::internal::kEmptyString) {
    fix_engine_id_->clear();
  }
  clear_has_fix_engine_id();
}
inline const ::std::string& FixEngineData::fix_engine_id() const {
  return *fix_engine_id_;
}
inline void FixEngineData::set_fix_engine_id(const ::std::string& value) {
  set_has_fix_engine_id();
  if (fix_engine_id_ == &::google::protobuf::internal::kEmptyString) {
    fix_engine_id_ = new ::std::string;
  }
  fix_engine_id_->assign(value);
}
inline void FixEngineData::set_fix_engine_id(const char* value) {
  set_has_fix_engine_id();
  if (fix_engine_id_ == &::google::protobuf::internal::kEmptyString) {
    fix_engine_id_ = new ::std::string;
  }
  fix_engine_id_->assign(value);
}
inline void FixEngineData::set_fix_engine_id(const char* value, size_t size) {
  set_has_fix_engine_id();
  if (fix_engine_id_ == &::google::protobuf::internal::kEmptyString) {
    fix_engine_id_ = new ::std::string;
  }
  fix_engine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixEngineData::mutable_fix_engine_id() {
  set_has_fix_engine_id();
  if (fix_engine_id_ == &::google::protobuf::internal::kEmptyString) {
    fix_engine_id_ = new ::std::string;
  }
  return fix_engine_id_;
}
inline ::std::string* FixEngineData::release_fix_engine_id() {
  clear_has_fix_engine_id();
  if (fix_engine_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fix_engine_id_;
    fix_engine_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string session_id = 2;
inline bool FixEngineData::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FixEngineData::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FixEngineData::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FixEngineData::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& FixEngineData::session_id() const {
  return *session_id_;
}
inline void FixEngineData::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void FixEngineData::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void FixEngineData::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixEngineData::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* FixEngineData::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SystemParameterData

// optional string parameter_id = 1;
inline bool SystemParameterData::has_parameter_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemParameterData::set_has_parameter_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemParameterData::clear_has_parameter_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemParameterData::clear_parameter_id() {
  if (parameter_id_ != &::google::protobuf::internal::kEmptyString) {
    parameter_id_->clear();
  }
  clear_has_parameter_id();
}
inline const ::std::string& SystemParameterData::parameter_id() const {
  return *parameter_id_;
}
inline void SystemParameterData::set_parameter_id(const ::std::string& value) {
  set_has_parameter_id();
  if (parameter_id_ == &::google::protobuf::internal::kEmptyString) {
    parameter_id_ = new ::std::string;
  }
  parameter_id_->assign(value);
}
inline void SystemParameterData::set_parameter_id(const char* value) {
  set_has_parameter_id();
  if (parameter_id_ == &::google::protobuf::internal::kEmptyString) {
    parameter_id_ = new ::std::string;
  }
  parameter_id_->assign(value);
}
inline void SystemParameterData::set_parameter_id(const char* value, size_t size) {
  set_has_parameter_id();
  if (parameter_id_ == &::google::protobuf::internal::kEmptyString) {
    parameter_id_ = new ::std::string;
  }
  parameter_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemParameterData::mutable_parameter_id() {
  set_has_parameter_id();
  if (parameter_id_ == &::google::protobuf::internal::kEmptyString) {
    parameter_id_ = new ::std::string;
  }
  return parameter_id_;
}
inline ::std::string* SystemParameterData::release_parameter_id() {
  clear_has_parameter_id();
  if (parameter_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parameter_id_;
    parameter_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string category = 2;
inline bool SystemParameterData::has_category() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemParameterData::set_has_category() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemParameterData::clear_has_category() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemParameterData::clear_category() {
  if (category_ != &::google::protobuf::internal::kEmptyString) {
    category_->clear();
  }
  clear_has_category();
}
inline const ::std::string& SystemParameterData::category() const {
  return *category_;
}
inline void SystemParameterData::set_category(const ::std::string& value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void SystemParameterData::set_category(const char* value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void SystemParameterData::set_category(const char* value, size_t size) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemParameterData::mutable_category() {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  return category_;
}
inline ::std::string* SystemParameterData::release_category() {
  clear_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = category_;
    category_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string name = 3;
inline bool SystemParameterData::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemParameterData::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemParameterData::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemParameterData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SystemParameterData::name() const {
  return *name_;
}
inline void SystemParameterData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SystemParameterData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SystemParameterData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemParameterData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SystemParameterData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string value = 4;
inline bool SystemParameterData::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SystemParameterData::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SystemParameterData::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SystemParameterData::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& SystemParameterData::value() const {
  return *value_;
}
inline void SystemParameterData::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void SystemParameterData::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void SystemParameterData::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemParameterData::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* SystemParameterData::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PositionOvernightData

// optional string position_overnight_id = 1;
inline bool PositionOvernightData::has_position_overnight_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PositionOvernightData::set_has_position_overnight_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PositionOvernightData::clear_has_position_overnight_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PositionOvernightData::clear_position_overnight_id() {
  if (position_overnight_id_ != &::google::protobuf::internal::kEmptyString) {
    position_overnight_id_->clear();
  }
  clear_has_position_overnight_id();
}
inline const ::std::string& PositionOvernightData::position_overnight_id() const {
  return *position_overnight_id_;
}
inline void PositionOvernightData::set_position_overnight_id(const ::std::string& value) {
  set_has_position_overnight_id();
  if (position_overnight_id_ == &::google::protobuf::internal::kEmptyString) {
    position_overnight_id_ = new ::std::string;
  }
  position_overnight_id_->assign(value);
}
inline void PositionOvernightData::set_position_overnight_id(const char* value) {
  set_has_position_overnight_id();
  if (position_overnight_id_ == &::google::protobuf::internal::kEmptyString) {
    position_overnight_id_ = new ::std::string;
  }
  position_overnight_id_->assign(value);
}
inline void PositionOvernightData::set_position_overnight_id(const char* value, size_t size) {
  set_has_position_overnight_id();
  if (position_overnight_id_ == &::google::protobuf::internal::kEmptyString) {
    position_overnight_id_ = new ::std::string;
  }
  position_overnight_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionOvernightData::mutable_position_overnight_id() {
  set_has_position_overnight_id();
  if (position_overnight_id_ == &::google::protobuf::internal::kEmptyString) {
    position_overnight_id_ = new ::std::string;
  }
  return position_overnight_id_;
}
inline ::std::string* PositionOvernightData::release_position_overnight_id() {
  clear_has_position_overnight_id();
  if (position_overnight_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = position_overnight_id_;
    position_overnight_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string account_id = 2;
inline bool PositionOvernightData::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PositionOvernightData::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PositionOvernightData::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PositionOvernightData::clear_account_id() {
  if (account_id_ != &::google::protobuf::internal::kEmptyString) {
    account_id_->clear();
  }
  clear_has_account_id();
}
inline const ::std::string& PositionOvernightData::account_id() const {
  return *account_id_;
}
inline void PositionOvernightData::set_account_id(const ::std::string& value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void PositionOvernightData::set_account_id(const char* value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void PositionOvernightData::set_account_id(const char* value, size_t size) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionOvernightData::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  return account_id_;
}
inline ::std::string* PositionOvernightData::release_account_id() {
  clear_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_id_;
    account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string instrument_id = 3;
inline bool PositionOvernightData::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PositionOvernightData::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PositionOvernightData::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PositionOvernightData::clear_instrument_id() {
  if (instrument_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_id_->clear();
  }
  clear_has_instrument_id();
}
inline const ::std::string& PositionOvernightData::instrument_id() const {
  return *instrument_id_;
}
inline void PositionOvernightData::set_instrument_id(const ::std::string& value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void PositionOvernightData::set_instrument_id(const char* value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void PositionOvernightData::set_instrument_id(const char* value, size_t size) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionOvernightData::mutable_instrument_id() {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  return instrument_id_;
}
inline ::std::string* PositionOvernightData::release_instrument_id() {
  clear_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_id_;
    instrument_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string investment_system_id = 4;
inline bool PositionOvernightData::has_investment_system_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PositionOvernightData::set_has_investment_system_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PositionOvernightData::clear_has_investment_system_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PositionOvernightData::clear_investment_system_id() {
  if (investment_system_id_ != &::google::protobuf::internal::kEmptyString) {
    investment_system_id_->clear();
  }
  clear_has_investment_system_id();
}
inline const ::std::string& PositionOvernightData::investment_system_id() const {
  return *investment_system_id_;
}
inline void PositionOvernightData::set_investment_system_id(const ::std::string& value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void PositionOvernightData::set_investment_system_id(const char* value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void PositionOvernightData::set_investment_system_id(const char* value, size_t size) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionOvernightData::mutable_investment_system_id() {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  return investment_system_id_;
}
inline ::std::string* PositionOvernightData::release_investment_system_id() {
  clear_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = investment_system_id_;
    investment_system_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.PositionOvernightData.PositionType position_type = 5;
inline bool PositionOvernightData::has_position_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PositionOvernightData::set_has_position_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PositionOvernightData::clear_has_position_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PositionOvernightData::clear_position_type() {
  position_type_ = 0;
  clear_has_position_type();
}
inline ::quantmodel::PositionOvernightData_PositionType PositionOvernightData::position_type() const {
  return static_cast< ::quantmodel::PositionOvernightData_PositionType >(position_type_);
}
inline void PositionOvernightData::set_position_type(::quantmodel::PositionOvernightData_PositionType value) {
  GOOGLE_DCHECK(::quantmodel::PositionOvernightData_PositionType_IsValid(value));
  set_has_position_type();
  position_type_ = value;
}

// optional string open_pos = 6 [default = "0"];
inline bool PositionOvernightData::has_open_pos() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PositionOvernightData::set_has_open_pos() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PositionOvernightData::clear_has_open_pos() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PositionOvernightData::clear_open_pos() {
  if (open_pos_ != &_default_open_pos_) {
    open_pos_->assign(_default_open_pos_);
  }
  clear_has_open_pos();
}
inline const ::std::string& PositionOvernightData::open_pos() const {
  return *open_pos_;
}
inline void PositionOvernightData::set_open_pos(const ::std::string& value) {
  set_has_open_pos();
  if (open_pos_ == &_default_open_pos_) {
    open_pos_ = new ::std::string;
  }
  open_pos_->assign(value);
}
inline void PositionOvernightData::set_open_pos(const char* value) {
  set_has_open_pos();
  if (open_pos_ == &_default_open_pos_) {
    open_pos_ = new ::std::string;
  }
  open_pos_->assign(value);
}
inline void PositionOvernightData::set_open_pos(const char* value, size_t size) {
  set_has_open_pos();
  if (open_pos_ == &_default_open_pos_) {
    open_pos_ = new ::std::string;
  }
  open_pos_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionOvernightData::mutable_open_pos() {
  set_has_open_pos();
  if (open_pos_ == &_default_open_pos_) {
    open_pos_ = new ::std::string(_default_open_pos_);
  }
  return open_pos_;
}
inline ::std::string* PositionOvernightData::release_open_pos() {
  clear_has_open_pos();
  if (open_pos_ == &_default_open_pos_) {
    return NULL;
  } else {
    ::std::string* temp = open_pos_;
    open_pos_ = const_cast< ::std::string*>(&_default_open_pos_);
    return temp;
  }
}

// optional string open_prc = 7 [default = "0"];
inline bool PositionOvernightData::has_open_prc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PositionOvernightData::set_has_open_prc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PositionOvernightData::clear_has_open_prc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PositionOvernightData::clear_open_prc() {
  if (open_prc_ != &_default_open_prc_) {
    open_prc_->assign(_default_open_prc_);
  }
  clear_has_open_prc();
}
inline const ::std::string& PositionOvernightData::open_prc() const {
  return *open_prc_;
}
inline void PositionOvernightData::set_open_prc(const ::std::string& value) {
  set_has_open_prc();
  if (open_prc_ == &_default_open_prc_) {
    open_prc_ = new ::std::string;
  }
  open_prc_->assign(value);
}
inline void PositionOvernightData::set_open_prc(const char* value) {
  set_has_open_prc();
  if (open_prc_ == &_default_open_prc_) {
    open_prc_ = new ::std::string;
  }
  open_prc_->assign(value);
}
inline void PositionOvernightData::set_open_prc(const char* value, size_t size) {
  set_has_open_prc();
  if (open_prc_ == &_default_open_prc_) {
    open_prc_ = new ::std::string;
  }
  open_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionOvernightData::mutable_open_prc() {
  set_has_open_prc();
  if (open_prc_ == &_default_open_prc_) {
    open_prc_ = new ::std::string(_default_open_prc_);
  }
  return open_prc_;
}
inline ::std::string* PositionOvernightData::release_open_prc() {
  clear_has_open_prc();
  if (open_prc_ == &_default_open_prc_) {
    return NULL;
  } else {
    ::std::string* temp = open_prc_;
    open_prc_ = const_cast< ::std::string*>(&_default_open_prc_);
    return temp;
  }
}

// optional string is_active = 8;
inline bool PositionOvernightData::has_is_active() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PositionOvernightData::set_has_is_active() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PositionOvernightData::clear_has_is_active() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PositionOvernightData::clear_is_active() {
  if (is_active_ != &::google::protobuf::internal::kEmptyString) {
    is_active_->clear();
  }
  clear_has_is_active();
}
inline const ::std::string& PositionOvernightData::is_active() const {
  return *is_active_;
}
inline void PositionOvernightData::set_is_active(const ::std::string& value) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(value);
}
inline void PositionOvernightData::set_is_active(const char* value) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(value);
}
inline void PositionOvernightData::set_is_active(const char* value, size_t size) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionOvernightData::mutable_is_active() {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  return is_active_;
}
inline ::std::string* PositionOvernightData::release_is_active() {
  clear_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = is_active_;
    is_active_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string added_datetime = 9;
inline bool PositionOvernightData::has_added_datetime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PositionOvernightData::set_has_added_datetime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PositionOvernightData::clear_has_added_datetime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PositionOvernightData::clear_added_datetime() {
  if (added_datetime_ != &::google::protobuf::internal::kEmptyString) {
    added_datetime_->clear();
  }
  clear_has_added_datetime();
}
inline const ::std::string& PositionOvernightData::added_datetime() const {
  return *added_datetime_;
}
inline void PositionOvernightData::set_added_datetime(const ::std::string& value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void PositionOvernightData::set_added_datetime(const char* value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void PositionOvernightData::set_added_datetime(const char* value, size_t size) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionOvernightData::mutable_added_datetime() {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  return added_datetime_;
}
inline ::std::string* PositionOvernightData::release_added_datetime() {
  clear_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_datetime_;
    added_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string added_by = 10;
inline bool PositionOvernightData::has_added_by() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PositionOvernightData::set_has_added_by() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PositionOvernightData::clear_has_added_by() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PositionOvernightData::clear_added_by() {
  if (added_by_ != &::google::protobuf::internal::kEmptyString) {
    added_by_->clear();
  }
  clear_has_added_by();
}
inline const ::std::string& PositionOvernightData::added_by() const {
  return *added_by_;
}
inline void PositionOvernightData::set_added_by(const ::std::string& value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void PositionOvernightData::set_added_by(const char* value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void PositionOvernightData::set_added_by(const char* value, size_t size) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionOvernightData::mutable_added_by() {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  return added_by_;
}
inline ::std::string* PositionOvernightData::release_added_by() {
  clear_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_by_;
    added_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_datetime = 11;
inline bool PositionOvernightData::has_updated_datetime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PositionOvernightData::set_has_updated_datetime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PositionOvernightData::clear_has_updated_datetime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PositionOvernightData::clear_updated_datetime() {
  if (updated_datetime_ != &::google::protobuf::internal::kEmptyString) {
    updated_datetime_->clear();
  }
  clear_has_updated_datetime();
}
inline const ::std::string& PositionOvernightData::updated_datetime() const {
  return *updated_datetime_;
}
inline void PositionOvernightData::set_updated_datetime(const ::std::string& value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void PositionOvernightData::set_updated_datetime(const char* value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void PositionOvernightData::set_updated_datetime(const char* value, size_t size) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionOvernightData::mutable_updated_datetime() {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  return updated_datetime_;
}
inline ::std::string* PositionOvernightData::release_updated_datetime() {
  clear_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_datetime_;
    updated_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_by = 12;
inline bool PositionOvernightData::has_updated_by() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PositionOvernightData::set_has_updated_by() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PositionOvernightData::clear_has_updated_by() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PositionOvernightData::clear_updated_by() {
  if (updated_by_ != &::google::protobuf::internal::kEmptyString) {
    updated_by_->clear();
  }
  clear_has_updated_by();
}
inline const ::std::string& PositionOvernightData::updated_by() const {
  return *updated_by_;
}
inline void PositionOvernightData::set_updated_by(const ::std::string& value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void PositionOvernightData::set_updated_by(const char* value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void PositionOvernightData::set_updated_by(const char* value, size_t size) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PositionOvernightData::mutable_updated_by() {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  return updated_by_;
}
inline ::std::string* PositionOvernightData::release_updated_by() {
  clear_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_by_;
    updated_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AccountLimitData

// optional string account_id = 1;
inline bool AccountLimitData::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountLimitData::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountLimitData::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountLimitData::clear_account_id() {
  if (account_id_ != &::google::protobuf::internal::kEmptyString) {
    account_id_->clear();
  }
  clear_has_account_id();
}
inline const ::std::string& AccountLimitData::account_id() const {
  return *account_id_;
}
inline void AccountLimitData::set_account_id(const ::std::string& value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void AccountLimitData::set_account_id(const char* value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void AccountLimitData::set_account_id(const char* value, size_t size) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLimitData::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  return account_id_;
}
inline ::std::string* AccountLimitData::release_account_id() {
  clear_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_id_;
    account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string symbol = 2;
inline bool AccountLimitData::has_symbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountLimitData::set_has_symbol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountLimitData::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountLimitData::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& AccountLimitData::symbol() const {
  return *symbol_;
}
inline void AccountLimitData::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void AccountLimitData::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void AccountLimitData::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLimitData::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* AccountLimitData::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string security_exchange = 3;
inline bool AccountLimitData::has_security_exchange() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountLimitData::set_has_security_exchange() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountLimitData::clear_has_security_exchange() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountLimitData::clear_security_exchange() {
  if (security_exchange_ != &::google::protobuf::internal::kEmptyString) {
    security_exchange_->clear();
  }
  clear_has_security_exchange();
}
inline const ::std::string& AccountLimitData::security_exchange() const {
  return *security_exchange_;
}
inline void AccountLimitData::set_security_exchange(const ::std::string& value) {
  set_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    security_exchange_ = new ::std::string;
  }
  security_exchange_->assign(value);
}
inline void AccountLimitData::set_security_exchange(const char* value) {
  set_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    security_exchange_ = new ::std::string;
  }
  security_exchange_->assign(value);
}
inline void AccountLimitData::set_security_exchange(const char* value, size_t size) {
  set_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    security_exchange_ = new ::std::string;
  }
  security_exchange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLimitData::mutable_security_exchange() {
  set_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    security_exchange_ = new ::std::string;
  }
  return security_exchange_;
}
inline ::std::string* AccountLimitData::release_security_exchange() {
  clear_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_exchange_;
    security_exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string session_id = 4;
inline bool AccountLimitData::has_session_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountLimitData::set_has_session_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountLimitData::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountLimitData::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& AccountLimitData::session_id() const {
  return *session_id_;
}
inline void AccountLimitData::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void AccountLimitData::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void AccountLimitData::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLimitData::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* AccountLimitData::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string max_open_long_qty = 5 [default = "0"];
inline bool AccountLimitData::has_max_open_long_qty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountLimitData::set_has_max_open_long_qty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountLimitData::clear_has_max_open_long_qty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountLimitData::clear_max_open_long_qty() {
  if (max_open_long_qty_ != &_default_max_open_long_qty_) {
    max_open_long_qty_->assign(_default_max_open_long_qty_);
  }
  clear_has_max_open_long_qty();
}
inline const ::std::string& AccountLimitData::max_open_long_qty() const {
  return *max_open_long_qty_;
}
inline void AccountLimitData::set_max_open_long_qty(const ::std::string& value) {
  set_has_max_open_long_qty();
  if (max_open_long_qty_ == &_default_max_open_long_qty_) {
    max_open_long_qty_ = new ::std::string;
  }
  max_open_long_qty_->assign(value);
}
inline void AccountLimitData::set_max_open_long_qty(const char* value) {
  set_has_max_open_long_qty();
  if (max_open_long_qty_ == &_default_max_open_long_qty_) {
    max_open_long_qty_ = new ::std::string;
  }
  max_open_long_qty_->assign(value);
}
inline void AccountLimitData::set_max_open_long_qty(const char* value, size_t size) {
  set_has_max_open_long_qty();
  if (max_open_long_qty_ == &_default_max_open_long_qty_) {
    max_open_long_qty_ = new ::std::string;
  }
  max_open_long_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLimitData::mutable_max_open_long_qty() {
  set_has_max_open_long_qty();
  if (max_open_long_qty_ == &_default_max_open_long_qty_) {
    max_open_long_qty_ = new ::std::string(_default_max_open_long_qty_);
  }
  return max_open_long_qty_;
}
inline ::std::string* AccountLimitData::release_max_open_long_qty() {
  clear_has_max_open_long_qty();
  if (max_open_long_qty_ == &_default_max_open_long_qty_) {
    return NULL;
  } else {
    ::std::string* temp = max_open_long_qty_;
    max_open_long_qty_ = const_cast< ::std::string*>(&_default_max_open_long_qty_);
    return temp;
  }
}

// optional string max_open_short_qty = 6 [default = "0"];
inline bool AccountLimitData::has_max_open_short_qty() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AccountLimitData::set_has_max_open_short_qty() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AccountLimitData::clear_has_max_open_short_qty() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AccountLimitData::clear_max_open_short_qty() {
  if (max_open_short_qty_ != &_default_max_open_short_qty_) {
    max_open_short_qty_->assign(_default_max_open_short_qty_);
  }
  clear_has_max_open_short_qty();
}
inline const ::std::string& AccountLimitData::max_open_short_qty() const {
  return *max_open_short_qty_;
}
inline void AccountLimitData::set_max_open_short_qty(const ::std::string& value) {
  set_has_max_open_short_qty();
  if (max_open_short_qty_ == &_default_max_open_short_qty_) {
    max_open_short_qty_ = new ::std::string;
  }
  max_open_short_qty_->assign(value);
}
inline void AccountLimitData::set_max_open_short_qty(const char* value) {
  set_has_max_open_short_qty();
  if (max_open_short_qty_ == &_default_max_open_short_qty_) {
    max_open_short_qty_ = new ::std::string;
  }
  max_open_short_qty_->assign(value);
}
inline void AccountLimitData::set_max_open_short_qty(const char* value, size_t size) {
  set_has_max_open_short_qty();
  if (max_open_short_qty_ == &_default_max_open_short_qty_) {
    max_open_short_qty_ = new ::std::string;
  }
  max_open_short_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLimitData::mutable_max_open_short_qty() {
  set_has_max_open_short_qty();
  if (max_open_short_qty_ == &_default_max_open_short_qty_) {
    max_open_short_qty_ = new ::std::string(_default_max_open_short_qty_);
  }
  return max_open_short_qty_;
}
inline ::std::string* AccountLimitData::release_max_open_short_qty() {
  clear_has_max_open_short_qty();
  if (max_open_short_qty_ == &_default_max_open_short_qty_) {
    return NULL;
  } else {
    ::std::string* temp = max_open_short_qty_;
    max_open_short_qty_ = const_cast< ::std::string*>(&_default_max_open_short_qty_);
    return temp;
  }
}

// optional string max_release_qty = 7 [default = "0"];
inline bool AccountLimitData::has_max_release_qty() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AccountLimitData::set_has_max_release_qty() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AccountLimitData::clear_has_max_release_qty() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AccountLimitData::clear_max_release_qty() {
  if (max_release_qty_ != &_default_max_release_qty_) {
    max_release_qty_->assign(_default_max_release_qty_);
  }
  clear_has_max_release_qty();
}
inline const ::std::string& AccountLimitData::max_release_qty() const {
  return *max_release_qty_;
}
inline void AccountLimitData::set_max_release_qty(const ::std::string& value) {
  set_has_max_release_qty();
  if (max_release_qty_ == &_default_max_release_qty_) {
    max_release_qty_ = new ::std::string;
  }
  max_release_qty_->assign(value);
}
inline void AccountLimitData::set_max_release_qty(const char* value) {
  set_has_max_release_qty();
  if (max_release_qty_ == &_default_max_release_qty_) {
    max_release_qty_ = new ::std::string;
  }
  max_release_qty_->assign(value);
}
inline void AccountLimitData::set_max_release_qty(const char* value, size_t size) {
  set_has_max_release_qty();
  if (max_release_qty_ == &_default_max_release_qty_) {
    max_release_qty_ = new ::std::string;
  }
  max_release_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLimitData::mutable_max_release_qty() {
  set_has_max_release_qty();
  if (max_release_qty_ == &_default_max_release_qty_) {
    max_release_qty_ = new ::std::string(_default_max_release_qty_);
  }
  return max_release_qty_;
}
inline ::std::string* AccountLimitData::release_max_release_qty() {
  clear_has_max_release_qty();
  if (max_release_qty_ == &_default_max_release_qty_) {
    return NULL;
  } else {
    ::std::string* temp = max_release_qty_;
    max_release_qty_ = const_cast< ::std::string*>(&_default_max_release_qty_);
    return temp;
  }
}

// optional string is_active = 8 [default = "0"];
inline bool AccountLimitData::has_is_active() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AccountLimitData::set_has_is_active() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AccountLimitData::clear_has_is_active() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AccountLimitData::clear_is_active() {
  if (is_active_ != &_default_is_active_) {
    is_active_->assign(_default_is_active_);
  }
  clear_has_is_active();
}
inline const ::std::string& AccountLimitData::is_active() const {
  return *is_active_;
}
inline void AccountLimitData::set_is_active(const ::std::string& value) {
  set_has_is_active();
  if (is_active_ == &_default_is_active_) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(value);
}
inline void AccountLimitData::set_is_active(const char* value) {
  set_has_is_active();
  if (is_active_ == &_default_is_active_) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(value);
}
inline void AccountLimitData::set_is_active(const char* value, size_t size) {
  set_has_is_active();
  if (is_active_ == &_default_is_active_) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLimitData::mutable_is_active() {
  set_has_is_active();
  if (is_active_ == &_default_is_active_) {
    is_active_ = new ::std::string(_default_is_active_);
  }
  return is_active_;
}
inline ::std::string* AccountLimitData::release_is_active() {
  clear_has_is_active();
  if (is_active_ == &_default_is_active_) {
    return NULL;
  } else {
    ::std::string* temp = is_active_;
    is_active_ = const_cast< ::std::string*>(&_default_is_active_);
    return temp;
  }
}

// optional string added_datetime = 9;
inline bool AccountLimitData::has_added_datetime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AccountLimitData::set_has_added_datetime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AccountLimitData::clear_has_added_datetime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AccountLimitData::clear_added_datetime() {
  if (added_datetime_ != &::google::protobuf::internal::kEmptyString) {
    added_datetime_->clear();
  }
  clear_has_added_datetime();
}
inline const ::std::string& AccountLimitData::added_datetime() const {
  return *added_datetime_;
}
inline void AccountLimitData::set_added_datetime(const ::std::string& value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void AccountLimitData::set_added_datetime(const char* value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void AccountLimitData::set_added_datetime(const char* value, size_t size) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLimitData::mutable_added_datetime() {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  return added_datetime_;
}
inline ::std::string* AccountLimitData::release_added_datetime() {
  clear_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_datetime_;
    added_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string added_by = 10;
inline bool AccountLimitData::has_added_by() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AccountLimitData::set_has_added_by() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AccountLimitData::clear_has_added_by() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AccountLimitData::clear_added_by() {
  if (added_by_ != &::google::protobuf::internal::kEmptyString) {
    added_by_->clear();
  }
  clear_has_added_by();
}
inline const ::std::string& AccountLimitData::added_by() const {
  return *added_by_;
}
inline void AccountLimitData::set_added_by(const ::std::string& value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void AccountLimitData::set_added_by(const char* value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void AccountLimitData::set_added_by(const char* value, size_t size) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLimitData::mutable_added_by() {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  return added_by_;
}
inline ::std::string* AccountLimitData::release_added_by() {
  clear_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_by_;
    added_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_datetime = 11;
inline bool AccountLimitData::has_updated_datetime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AccountLimitData::set_has_updated_datetime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AccountLimitData::clear_has_updated_datetime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AccountLimitData::clear_updated_datetime() {
  if (updated_datetime_ != &::google::protobuf::internal::kEmptyString) {
    updated_datetime_->clear();
  }
  clear_has_updated_datetime();
}
inline const ::std::string& AccountLimitData::updated_datetime() const {
  return *updated_datetime_;
}
inline void AccountLimitData::set_updated_datetime(const ::std::string& value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void AccountLimitData::set_updated_datetime(const char* value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void AccountLimitData::set_updated_datetime(const char* value, size_t size) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLimitData::mutable_updated_datetime() {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  return updated_datetime_;
}
inline ::std::string* AccountLimitData::release_updated_datetime() {
  clear_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_datetime_;
    updated_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_by = 12;
inline bool AccountLimitData::has_updated_by() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AccountLimitData::set_has_updated_by() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AccountLimitData::clear_has_updated_by() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AccountLimitData::clear_updated_by() {
  if (updated_by_ != &::google::protobuf::internal::kEmptyString) {
    updated_by_->clear();
  }
  clear_has_updated_by();
}
inline const ::std::string& AccountLimitData::updated_by() const {
  return *updated_by_;
}
inline void AccountLimitData::set_updated_by(const ::std::string& value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void AccountLimitData::set_updated_by(const char* value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void AccountLimitData::set_updated_by(const char* value, size_t size) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLimitData::mutable_updated_by() {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  return updated_by_;
}
inline ::std::string* AccountLimitData::release_updated_by() {
  clear_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_by_;
    updated_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DraftOrderData

// optional string external_order_id = 1;
inline bool DraftOrderData::has_external_order_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DraftOrderData::set_has_external_order_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DraftOrderData::clear_has_external_order_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DraftOrderData::clear_external_order_id() {
  if (external_order_id_ != &::google::protobuf::internal::kEmptyString) {
    external_order_id_->clear();
  }
  clear_has_external_order_id();
}
inline const ::std::string& DraftOrderData::external_order_id() const {
  return *external_order_id_;
}
inline void DraftOrderData::set_external_order_id(const ::std::string& value) {
  set_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    external_order_id_ = new ::std::string;
  }
  external_order_id_->assign(value);
}
inline void DraftOrderData::set_external_order_id(const char* value) {
  set_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    external_order_id_ = new ::std::string;
  }
  external_order_id_->assign(value);
}
inline void DraftOrderData::set_external_order_id(const char* value, size_t size) {
  set_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    external_order_id_ = new ::std::string;
  }
  external_order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DraftOrderData::mutable_external_order_id() {
  set_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    external_order_id_ = new ::std::string;
  }
  return external_order_id_;
}
inline ::std::string* DraftOrderData::release_external_order_id() {
  clear_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = external_order_id_;
    external_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string investment_system_id = 2;
inline bool DraftOrderData::has_investment_system_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DraftOrderData::set_has_investment_system_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DraftOrderData::clear_has_investment_system_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DraftOrderData::clear_investment_system_id() {
  if (investment_system_id_ != &::google::protobuf::internal::kEmptyString) {
    investment_system_id_->clear();
  }
  clear_has_investment_system_id();
}
inline const ::std::string& DraftOrderData::investment_system_id() const {
  return *investment_system_id_;
}
inline void DraftOrderData::set_investment_system_id(const ::std::string& value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void DraftOrderData::set_investment_system_id(const char* value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void DraftOrderData::set_investment_system_id(const char* value, size_t size) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DraftOrderData::mutable_investment_system_id() {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  return investment_system_id_;
}
inline ::std::string* DraftOrderData::release_investment_system_id() {
  clear_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = investment_system_id_;
    investment_system_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string instrument_id = 3;
inline bool DraftOrderData::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DraftOrderData::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DraftOrderData::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DraftOrderData::clear_instrument_id() {
  if (instrument_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_id_->clear();
  }
  clear_has_instrument_id();
}
inline const ::std::string& DraftOrderData::instrument_id() const {
  return *instrument_id_;
}
inline void DraftOrderData::set_instrument_id(const ::std::string& value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void DraftOrderData::set_instrument_id(const char* value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void DraftOrderData::set_instrument_id(const char* value, size_t size) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DraftOrderData::mutable_instrument_id() {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  return instrument_id_;
}
inline ::std::string* DraftOrderData::release_instrument_id() {
  clear_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_id_;
    instrument_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.DraftOrderData.SideCode side_code = 4;
inline bool DraftOrderData::has_side_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DraftOrderData::set_has_side_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DraftOrderData::clear_has_side_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DraftOrderData::clear_side_code() {
  side_code_ = 1;
  clear_has_side_code();
}
inline ::quantmodel::DraftOrderData_SideCode DraftOrderData::side_code() const {
  return static_cast< ::quantmodel::DraftOrderData_SideCode >(side_code_);
}
inline void DraftOrderData::set_side_code(::quantmodel::DraftOrderData_SideCode value) {
  GOOGLE_DCHECK(::quantmodel::DraftOrderData_SideCode_IsValid(value));
  set_has_side_code();
  side_code_ = value;
}

// optional .quantmodel.DraftOrderData.TimeInForce tif = 5;
inline bool DraftOrderData::has_tif() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DraftOrderData::set_has_tif() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DraftOrderData::clear_has_tif() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DraftOrderData::clear_tif() {
  tif_ = 0;
  clear_has_tif();
}
inline ::quantmodel::DraftOrderData_TimeInForce DraftOrderData::tif() const {
  return static_cast< ::quantmodel::DraftOrderData_TimeInForce >(tif_);
}
inline void DraftOrderData::set_tif(::quantmodel::DraftOrderData_TimeInForce value) {
  GOOGLE_DCHECK(::quantmodel::DraftOrderData_TimeInForce_IsValid(value));
  set_has_tif();
  tif_ = value;
}

// optional .quantmodel.DraftOrderData.OrderType order_type = 6;
inline bool DraftOrderData::has_order_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DraftOrderData::set_has_order_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DraftOrderData::clear_has_order_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DraftOrderData::clear_order_type() {
  order_type_ = 1;
  clear_has_order_type();
}
inline ::quantmodel::DraftOrderData_OrderType DraftOrderData::order_type() const {
  return static_cast< ::quantmodel::DraftOrderData_OrderType >(order_type_);
}
inline void DraftOrderData::set_order_type(::quantmodel::DraftOrderData_OrderType value) {
  GOOGLE_DCHECK(::quantmodel::DraftOrderData_OrderType_IsValid(value));
  set_has_order_type();
  order_type_ = value;
}

// optional string order_qty = 7 [default = "0"];
inline bool DraftOrderData::has_order_qty() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DraftOrderData::set_has_order_qty() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DraftOrderData::clear_has_order_qty() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DraftOrderData::clear_order_qty() {
  if (order_qty_ != &_default_order_qty_) {
    order_qty_->assign(_default_order_qty_);
  }
  clear_has_order_qty();
}
inline const ::std::string& DraftOrderData::order_qty() const {
  return *order_qty_;
}
inline void DraftOrderData::set_order_qty(const ::std::string& value) {
  set_has_order_qty();
  if (order_qty_ == &_default_order_qty_) {
    order_qty_ = new ::std::string;
  }
  order_qty_->assign(value);
}
inline void DraftOrderData::set_order_qty(const char* value) {
  set_has_order_qty();
  if (order_qty_ == &_default_order_qty_) {
    order_qty_ = new ::std::string;
  }
  order_qty_->assign(value);
}
inline void DraftOrderData::set_order_qty(const char* value, size_t size) {
  set_has_order_qty();
  if (order_qty_ == &_default_order_qty_) {
    order_qty_ = new ::std::string;
  }
  order_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DraftOrderData::mutable_order_qty() {
  set_has_order_qty();
  if (order_qty_ == &_default_order_qty_) {
    order_qty_ = new ::std::string(_default_order_qty_);
  }
  return order_qty_;
}
inline ::std::string* DraftOrderData::release_order_qty() {
  clear_has_order_qty();
  if (order_qty_ == &_default_order_qty_) {
    return NULL;
  } else {
    ::std::string* temp = order_qty_;
    order_qty_ = const_cast< ::std::string*>(&_default_order_qty_);
    return temp;
  }
}

// optional string limit_prc = 8 [default = "0"];
inline bool DraftOrderData::has_limit_prc() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DraftOrderData::set_has_limit_prc() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DraftOrderData::clear_has_limit_prc() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DraftOrderData::clear_limit_prc() {
  if (limit_prc_ != &_default_limit_prc_) {
    limit_prc_->assign(_default_limit_prc_);
  }
  clear_has_limit_prc();
}
inline const ::std::string& DraftOrderData::limit_prc() const {
  return *limit_prc_;
}
inline void DraftOrderData::set_limit_prc(const ::std::string& value) {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string;
  }
  limit_prc_->assign(value);
}
inline void DraftOrderData::set_limit_prc(const char* value) {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string;
  }
  limit_prc_->assign(value);
}
inline void DraftOrderData::set_limit_prc(const char* value, size_t size) {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string;
  }
  limit_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DraftOrderData::mutable_limit_prc() {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string(_default_limit_prc_);
  }
  return limit_prc_;
}
inline ::std::string* DraftOrderData::release_limit_prc() {
  clear_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    return NULL;
  } else {
    ::std::string* temp = limit_prc_;
    limit_prc_ = const_cast< ::std::string*>(&_default_limit_prc_);
    return temp;
  }
}

// optional string stop_prc = 9 [default = "0"];
inline bool DraftOrderData::has_stop_prc() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DraftOrderData::set_has_stop_prc() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DraftOrderData::clear_has_stop_prc() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DraftOrderData::clear_stop_prc() {
  if (stop_prc_ != &_default_stop_prc_) {
    stop_prc_->assign(_default_stop_prc_);
  }
  clear_has_stop_prc();
}
inline const ::std::string& DraftOrderData::stop_prc() const {
  return *stop_prc_;
}
inline void DraftOrderData::set_stop_prc(const ::std::string& value) {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string;
  }
  stop_prc_->assign(value);
}
inline void DraftOrderData::set_stop_prc(const char* value) {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string;
  }
  stop_prc_->assign(value);
}
inline void DraftOrderData::set_stop_prc(const char* value, size_t size) {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string;
  }
  stop_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DraftOrderData::mutable_stop_prc() {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string(_default_stop_prc_);
  }
  return stop_prc_;
}
inline ::std::string* DraftOrderData::release_stop_prc() {
  clear_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    return NULL;
  } else {
    ::std::string* temp = stop_prc_;
    stop_prc_ = const_cast< ::std::string*>(&_default_stop_prc_);
    return temp;
  }
}

// -------------------------------------------------------------------

// DraftAllocationData

// optional string account_id = 1;
inline bool DraftAllocationData::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DraftAllocationData::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DraftAllocationData::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DraftAllocationData::clear_account_id() {
  if (account_id_ != &::google::protobuf::internal::kEmptyString) {
    account_id_->clear();
  }
  clear_has_account_id();
}
inline const ::std::string& DraftAllocationData::account_id() const {
  return *account_id_;
}
inline void DraftAllocationData::set_account_id(const ::std::string& value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void DraftAllocationData::set_account_id(const char* value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void DraftAllocationData::set_account_id(const char* value, size_t size) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DraftAllocationData::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  return account_id_;
}
inline ::std::string* DraftAllocationData::release_account_id() {
  clear_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_id_;
    account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string allocation_qty = 2 [default = "0"];
inline bool DraftAllocationData::has_allocation_qty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DraftAllocationData::set_has_allocation_qty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DraftAllocationData::clear_has_allocation_qty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DraftAllocationData::clear_allocation_qty() {
  if (allocation_qty_ != &_default_allocation_qty_) {
    allocation_qty_->assign(_default_allocation_qty_);
  }
  clear_has_allocation_qty();
}
inline const ::std::string& DraftAllocationData::allocation_qty() const {
  return *allocation_qty_;
}
inline void DraftAllocationData::set_allocation_qty(const ::std::string& value) {
  set_has_allocation_qty();
  if (allocation_qty_ == &_default_allocation_qty_) {
    allocation_qty_ = new ::std::string;
  }
  allocation_qty_->assign(value);
}
inline void DraftAllocationData::set_allocation_qty(const char* value) {
  set_has_allocation_qty();
  if (allocation_qty_ == &_default_allocation_qty_) {
    allocation_qty_ = new ::std::string;
  }
  allocation_qty_->assign(value);
}
inline void DraftAllocationData::set_allocation_qty(const char* value, size_t size) {
  set_has_allocation_qty();
  if (allocation_qty_ == &_default_allocation_qty_) {
    allocation_qty_ = new ::std::string;
  }
  allocation_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DraftAllocationData::mutable_allocation_qty() {
  set_has_allocation_qty();
  if (allocation_qty_ == &_default_allocation_qty_) {
    allocation_qty_ = new ::std::string(_default_allocation_qty_);
  }
  return allocation_qty_;
}
inline ::std::string* DraftAllocationData::release_allocation_qty() {
  clear_has_allocation_qty();
  if (allocation_qty_ == &_default_allocation_qty_) {
    return NULL;
  } else {
    ::std::string* temp = allocation_qty_;
    allocation_qty_ = const_cast< ::std::string*>(&_default_allocation_qty_);
    return temp;
  }
}

// -------------------------------------------------------------------

// AccountData

// optional string account_id = 1;
inline bool AccountData::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountData::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountData::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountData::clear_account_id() {
  if (account_id_ != &::google::protobuf::internal::kEmptyString) {
    account_id_->clear();
  }
  clear_has_account_id();
}
inline const ::std::string& AccountData::account_id() const {
  return *account_id_;
}
inline void AccountData::set_account_id(const ::std::string& value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void AccountData::set_account_id(const char* value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void AccountData::set_account_id(const char* value, size_t size) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  return account_id_;
}
inline ::std::string* AccountData::release_account_id() {
  clear_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_id_;
    account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string parent_account_id = 2;
inline bool AccountData::has_parent_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountData::set_has_parent_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountData::clear_has_parent_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountData::clear_parent_account_id() {
  if (parent_account_id_ != &::google::protobuf::internal::kEmptyString) {
    parent_account_id_->clear();
  }
  clear_has_parent_account_id();
}
inline const ::std::string& AccountData::parent_account_id() const {
  return *parent_account_id_;
}
inline void AccountData::set_parent_account_id(const ::std::string& value) {
  set_has_parent_account_id();
  if (parent_account_id_ == &::google::protobuf::internal::kEmptyString) {
    parent_account_id_ = new ::std::string;
  }
  parent_account_id_->assign(value);
}
inline void AccountData::set_parent_account_id(const char* value) {
  set_has_parent_account_id();
  if (parent_account_id_ == &::google::protobuf::internal::kEmptyString) {
    parent_account_id_ = new ::std::string;
  }
  parent_account_id_->assign(value);
}
inline void AccountData::set_parent_account_id(const char* value, size_t size) {
  set_has_parent_account_id();
  if (parent_account_id_ == &::google::protobuf::internal::kEmptyString) {
    parent_account_id_ = new ::std::string;
  }
  parent_account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_parent_account_id() {
  set_has_parent_account_id();
  if (parent_account_id_ == &::google::protobuf::internal::kEmptyString) {
    parent_account_id_ = new ::std::string;
  }
  return parent_account_id_;
}
inline ::std::string* AccountData::release_parent_account_id() {
  clear_has_parent_account_id();
  if (parent_account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parent_account_id_;
    parent_account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string name = 3;
inline bool AccountData::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountData::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountData::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AccountData::name() const {
  return *name_;
}
inline void AccountData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AccountData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AccountData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AccountData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string market_account_id = 4;
inline bool AccountData::has_market_account_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountData::set_has_market_account_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountData::clear_has_market_account_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountData::clear_market_account_id() {
  if (market_account_id_ != &::google::protobuf::internal::kEmptyString) {
    market_account_id_->clear();
  }
  clear_has_market_account_id();
}
inline const ::std::string& AccountData::market_account_id() const {
  return *market_account_id_;
}
inline void AccountData::set_market_account_id(const ::std::string& value) {
  set_has_market_account_id();
  if (market_account_id_ == &::google::protobuf::internal::kEmptyString) {
    market_account_id_ = new ::std::string;
  }
  market_account_id_->assign(value);
}
inline void AccountData::set_market_account_id(const char* value) {
  set_has_market_account_id();
  if (market_account_id_ == &::google::protobuf::internal::kEmptyString) {
    market_account_id_ = new ::std::string;
  }
  market_account_id_->assign(value);
}
inline void AccountData::set_market_account_id(const char* value, size_t size) {
  set_has_market_account_id();
  if (market_account_id_ == &::google::protobuf::internal::kEmptyString) {
    market_account_id_ = new ::std::string;
  }
  market_account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_market_account_id() {
  set_has_market_account_id();
  if (market_account_id_ == &::google::protobuf::internal::kEmptyString) {
    market_account_id_ = new ::std::string;
  }
  return market_account_id_;
}
inline ::std::string* AccountData::release_market_account_id() {
  clear_has_market_account_id();
  if (market_account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = market_account_id_;
    market_account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string custody_account_id = 5;
inline bool AccountData::has_custody_account_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountData::set_has_custody_account_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountData::clear_has_custody_account_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountData::clear_custody_account_id() {
  if (custody_account_id_ != &::google::protobuf::internal::kEmptyString) {
    custody_account_id_->clear();
  }
  clear_has_custody_account_id();
}
inline const ::std::string& AccountData::custody_account_id() const {
  return *custody_account_id_;
}
inline void AccountData::set_custody_account_id(const ::std::string& value) {
  set_has_custody_account_id();
  if (custody_account_id_ == &::google::protobuf::internal::kEmptyString) {
    custody_account_id_ = new ::std::string;
  }
  custody_account_id_->assign(value);
}
inline void AccountData::set_custody_account_id(const char* value) {
  set_has_custody_account_id();
  if (custody_account_id_ == &::google::protobuf::internal::kEmptyString) {
    custody_account_id_ = new ::std::string;
  }
  custody_account_id_->assign(value);
}
inline void AccountData::set_custody_account_id(const char* value, size_t size) {
  set_has_custody_account_id();
  if (custody_account_id_ == &::google::protobuf::internal::kEmptyString) {
    custody_account_id_ = new ::std::string;
  }
  custody_account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_custody_account_id() {
  set_has_custody_account_id();
  if (custody_account_id_ == &::google::protobuf::internal::kEmptyString) {
    custody_account_id_ = new ::std::string;
  }
  return custody_account_id_;
}
inline ::std::string* AccountData::release_custody_account_id() {
  clear_has_custody_account_id();
  if (custody_account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = custody_account_id_;
    custody_account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string giveup_account_id = 6;
inline bool AccountData::has_giveup_account_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AccountData::set_has_giveup_account_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AccountData::clear_has_giveup_account_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AccountData::clear_giveup_account_id() {
  if (giveup_account_id_ != &::google::protobuf::internal::kEmptyString) {
    giveup_account_id_->clear();
  }
  clear_has_giveup_account_id();
}
inline const ::std::string& AccountData::giveup_account_id() const {
  return *giveup_account_id_;
}
inline void AccountData::set_giveup_account_id(const ::std::string& value) {
  set_has_giveup_account_id();
  if (giveup_account_id_ == &::google::protobuf::internal::kEmptyString) {
    giveup_account_id_ = new ::std::string;
  }
  giveup_account_id_->assign(value);
}
inline void AccountData::set_giveup_account_id(const char* value) {
  set_has_giveup_account_id();
  if (giveup_account_id_ == &::google::protobuf::internal::kEmptyString) {
    giveup_account_id_ = new ::std::string;
  }
  giveup_account_id_->assign(value);
}
inline void AccountData::set_giveup_account_id(const char* value, size_t size) {
  set_has_giveup_account_id();
  if (giveup_account_id_ == &::google::protobuf::internal::kEmptyString) {
    giveup_account_id_ = new ::std::string;
  }
  giveup_account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_giveup_account_id() {
  set_has_giveup_account_id();
  if (giveup_account_id_ == &::google::protobuf::internal::kEmptyString) {
    giveup_account_id_ = new ::std::string;
  }
  return giveup_account_id_;
}
inline ::std::string* AccountData::release_giveup_account_id() {
  clear_has_giveup_account_id();
  if (giveup_account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = giveup_account_id_;
    giveup_account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string giveup_firm_id = 7;
inline bool AccountData::has_giveup_firm_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AccountData::set_has_giveup_firm_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AccountData::clear_has_giveup_firm_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AccountData::clear_giveup_firm_id() {
  if (giveup_firm_id_ != &::google::protobuf::internal::kEmptyString) {
    giveup_firm_id_->clear();
  }
  clear_has_giveup_firm_id();
}
inline const ::std::string& AccountData::giveup_firm_id() const {
  return *giveup_firm_id_;
}
inline void AccountData::set_giveup_firm_id(const ::std::string& value) {
  set_has_giveup_firm_id();
  if (giveup_firm_id_ == &::google::protobuf::internal::kEmptyString) {
    giveup_firm_id_ = new ::std::string;
  }
  giveup_firm_id_->assign(value);
}
inline void AccountData::set_giveup_firm_id(const char* value) {
  set_has_giveup_firm_id();
  if (giveup_firm_id_ == &::google::protobuf::internal::kEmptyString) {
    giveup_firm_id_ = new ::std::string;
  }
  giveup_firm_id_->assign(value);
}
inline void AccountData::set_giveup_firm_id(const char* value, size_t size) {
  set_has_giveup_firm_id();
  if (giveup_firm_id_ == &::google::protobuf::internal::kEmptyString) {
    giveup_firm_id_ = new ::std::string;
  }
  giveup_firm_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_giveup_firm_id() {
  set_has_giveup_firm_id();
  if (giveup_firm_id_ == &::google::protobuf::internal::kEmptyString) {
    giveup_firm_id_ = new ::std::string;
  }
  return giveup_firm_id_;
}
inline ::std::string* AccountData::release_giveup_firm_id() {
  clear_has_giveup_firm_id();
  if (giveup_firm_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = giveup_firm_id_;
    giveup_firm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string notional_val = 8;
inline bool AccountData::has_notional_val() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AccountData::set_has_notional_val() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AccountData::clear_has_notional_val() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AccountData::clear_notional_val() {
  if (notional_val_ != &::google::protobuf::internal::kEmptyString) {
    notional_val_->clear();
  }
  clear_has_notional_val();
}
inline const ::std::string& AccountData::notional_val() const {
  return *notional_val_;
}
inline void AccountData::set_notional_val(const ::std::string& value) {
  set_has_notional_val();
  if (notional_val_ == &::google::protobuf::internal::kEmptyString) {
    notional_val_ = new ::std::string;
  }
  notional_val_->assign(value);
}
inline void AccountData::set_notional_val(const char* value) {
  set_has_notional_val();
  if (notional_val_ == &::google::protobuf::internal::kEmptyString) {
    notional_val_ = new ::std::string;
  }
  notional_val_->assign(value);
}
inline void AccountData::set_notional_val(const char* value, size_t size) {
  set_has_notional_val();
  if (notional_val_ == &::google::protobuf::internal::kEmptyString) {
    notional_val_ = new ::std::string;
  }
  notional_val_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_notional_val() {
  set_has_notional_val();
  if (notional_val_ == &::google::protobuf::internal::kEmptyString) {
    notional_val_ = new ::std::string;
  }
  return notional_val_;
}
inline ::std::string* AccountData::release_notional_val() {
  clear_has_notional_val();
  if (notional_val_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notional_val_;
    notional_val_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string profit_target = 9;
inline bool AccountData::has_profit_target() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AccountData::set_has_profit_target() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AccountData::clear_has_profit_target() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AccountData::clear_profit_target() {
  if (profit_target_ != &::google::protobuf::internal::kEmptyString) {
    profit_target_->clear();
  }
  clear_has_profit_target();
}
inline const ::std::string& AccountData::profit_target() const {
  return *profit_target_;
}
inline void AccountData::set_profit_target(const ::std::string& value) {
  set_has_profit_target();
  if (profit_target_ == &::google::protobuf::internal::kEmptyString) {
    profit_target_ = new ::std::string;
  }
  profit_target_->assign(value);
}
inline void AccountData::set_profit_target(const char* value) {
  set_has_profit_target();
  if (profit_target_ == &::google::protobuf::internal::kEmptyString) {
    profit_target_ = new ::std::string;
  }
  profit_target_->assign(value);
}
inline void AccountData::set_profit_target(const char* value, size_t size) {
  set_has_profit_target();
  if (profit_target_ == &::google::protobuf::internal::kEmptyString) {
    profit_target_ = new ::std::string;
  }
  profit_target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_profit_target() {
  set_has_profit_target();
  if (profit_target_ == &::google::protobuf::internal::kEmptyString) {
    profit_target_ = new ::std::string;
  }
  return profit_target_;
}
inline ::std::string* AccountData::release_profit_target() {
  clear_has_profit_target();
  if (profit_target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = profit_target_;
    profit_target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string stop_loss = 10;
inline bool AccountData::has_stop_loss() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AccountData::set_has_stop_loss() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AccountData::clear_has_stop_loss() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AccountData::clear_stop_loss() {
  if (stop_loss_ != &::google::protobuf::internal::kEmptyString) {
    stop_loss_->clear();
  }
  clear_has_stop_loss();
}
inline const ::std::string& AccountData::stop_loss() const {
  return *stop_loss_;
}
inline void AccountData::set_stop_loss(const ::std::string& value) {
  set_has_stop_loss();
  if (stop_loss_ == &::google::protobuf::internal::kEmptyString) {
    stop_loss_ = new ::std::string;
  }
  stop_loss_->assign(value);
}
inline void AccountData::set_stop_loss(const char* value) {
  set_has_stop_loss();
  if (stop_loss_ == &::google::protobuf::internal::kEmptyString) {
    stop_loss_ = new ::std::string;
  }
  stop_loss_->assign(value);
}
inline void AccountData::set_stop_loss(const char* value, size_t size) {
  set_has_stop_loss();
  if (stop_loss_ == &::google::protobuf::internal::kEmptyString) {
    stop_loss_ = new ::std::string;
  }
  stop_loss_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_stop_loss() {
  set_has_stop_loss();
  if (stop_loss_ == &::google::protobuf::internal::kEmptyString) {
    stop_loss_ = new ::std::string;
  }
  return stop_loss_;
}
inline ::std::string* AccountData::release_stop_loss() {
  clear_has_stop_loss();
  if (stop_loss_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stop_loss_;
    stop_loss_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string signal_weight = 11;
inline bool AccountData::has_signal_weight() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AccountData::set_has_signal_weight() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AccountData::clear_has_signal_weight() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AccountData::clear_signal_weight() {
  if (signal_weight_ != &::google::protobuf::internal::kEmptyString) {
    signal_weight_->clear();
  }
  clear_has_signal_weight();
}
inline const ::std::string& AccountData::signal_weight() const {
  return *signal_weight_;
}
inline void AccountData::set_signal_weight(const ::std::string& value) {
  set_has_signal_weight();
  if (signal_weight_ == &::google::protobuf::internal::kEmptyString) {
    signal_weight_ = new ::std::string;
  }
  signal_weight_->assign(value);
}
inline void AccountData::set_signal_weight(const char* value) {
  set_has_signal_weight();
  if (signal_weight_ == &::google::protobuf::internal::kEmptyString) {
    signal_weight_ = new ::std::string;
  }
  signal_weight_->assign(value);
}
inline void AccountData::set_signal_weight(const char* value, size_t size) {
  set_has_signal_weight();
  if (signal_weight_ == &::google::protobuf::internal::kEmptyString) {
    signal_weight_ = new ::std::string;
  }
  signal_weight_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_signal_weight() {
  set_has_signal_weight();
  if (signal_weight_ == &::google::protobuf::internal::kEmptyString) {
    signal_weight_ = new ::std::string;
  }
  return signal_weight_;
}
inline ::std::string* AccountData::release_signal_weight() {
  clear_has_signal_weight();
  if (signal_weight_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signal_weight_;
    signal_weight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string is_suppressed = 12;
inline bool AccountData::has_is_suppressed() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AccountData::set_has_is_suppressed() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AccountData::clear_has_is_suppressed() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AccountData::clear_is_suppressed() {
  if (is_suppressed_ != &::google::protobuf::internal::kEmptyString) {
    is_suppressed_->clear();
  }
  clear_has_is_suppressed();
}
inline const ::std::string& AccountData::is_suppressed() const {
  return *is_suppressed_;
}
inline void AccountData::set_is_suppressed(const ::std::string& value) {
  set_has_is_suppressed();
  if (is_suppressed_ == &::google::protobuf::internal::kEmptyString) {
    is_suppressed_ = new ::std::string;
  }
  is_suppressed_->assign(value);
}
inline void AccountData::set_is_suppressed(const char* value) {
  set_has_is_suppressed();
  if (is_suppressed_ == &::google::protobuf::internal::kEmptyString) {
    is_suppressed_ = new ::std::string;
  }
  is_suppressed_->assign(value);
}
inline void AccountData::set_is_suppressed(const char* value, size_t size) {
  set_has_is_suppressed();
  if (is_suppressed_ == &::google::protobuf::internal::kEmptyString) {
    is_suppressed_ = new ::std::string;
  }
  is_suppressed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_is_suppressed() {
  set_has_is_suppressed();
  if (is_suppressed_ == &::google::protobuf::internal::kEmptyString) {
    is_suppressed_ = new ::std::string;
  }
  return is_suppressed_;
}
inline ::std::string* AccountData::release_is_suppressed() {
  clear_has_is_suppressed();
  if (is_suppressed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = is_suppressed_;
    is_suppressed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string is_active = 13;
inline bool AccountData::has_is_active() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AccountData::set_has_is_active() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AccountData::clear_has_is_active() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AccountData::clear_is_active() {
  if (is_active_ != &::google::protobuf::internal::kEmptyString) {
    is_active_->clear();
  }
  clear_has_is_active();
}
inline const ::std::string& AccountData::is_active() const {
  return *is_active_;
}
inline void AccountData::set_is_active(const ::std::string& value) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(value);
}
inline void AccountData::set_is_active(const char* value) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(value);
}
inline void AccountData::set_is_active(const char* value, size_t size) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_is_active() {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  return is_active_;
}
inline ::std::string* AccountData::release_is_active() {
  clear_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = is_active_;
    is_active_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string contact_name = 14;
inline bool AccountData::has_contact_name() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AccountData::set_has_contact_name() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AccountData::clear_has_contact_name() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AccountData::clear_contact_name() {
  if (contact_name_ != &::google::protobuf::internal::kEmptyString) {
    contact_name_->clear();
  }
  clear_has_contact_name();
}
inline const ::std::string& AccountData::contact_name() const {
  return *contact_name_;
}
inline void AccountData::set_contact_name(const ::std::string& value) {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::kEmptyString) {
    contact_name_ = new ::std::string;
  }
  contact_name_->assign(value);
}
inline void AccountData::set_contact_name(const char* value) {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::kEmptyString) {
    contact_name_ = new ::std::string;
  }
  contact_name_->assign(value);
}
inline void AccountData::set_contact_name(const char* value, size_t size) {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::kEmptyString) {
    contact_name_ = new ::std::string;
  }
  contact_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_contact_name() {
  set_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::kEmptyString) {
    contact_name_ = new ::std::string;
  }
  return contact_name_;
}
inline ::std::string* AccountData::release_contact_name() {
  clear_has_contact_name();
  if (contact_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contact_name_;
    contact_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string contact_email = 15;
inline bool AccountData::has_contact_email() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AccountData::set_has_contact_email() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AccountData::clear_has_contact_email() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AccountData::clear_contact_email() {
  if (contact_email_ != &::google::protobuf::internal::kEmptyString) {
    contact_email_->clear();
  }
  clear_has_contact_email();
}
inline const ::std::string& AccountData::contact_email() const {
  return *contact_email_;
}
inline void AccountData::set_contact_email(const ::std::string& value) {
  set_has_contact_email();
  if (contact_email_ == &::google::protobuf::internal::kEmptyString) {
    contact_email_ = new ::std::string;
  }
  contact_email_->assign(value);
}
inline void AccountData::set_contact_email(const char* value) {
  set_has_contact_email();
  if (contact_email_ == &::google::protobuf::internal::kEmptyString) {
    contact_email_ = new ::std::string;
  }
  contact_email_->assign(value);
}
inline void AccountData::set_contact_email(const char* value, size_t size) {
  set_has_contact_email();
  if (contact_email_ == &::google::protobuf::internal::kEmptyString) {
    contact_email_ = new ::std::string;
  }
  contact_email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_contact_email() {
  set_has_contact_email();
  if (contact_email_ == &::google::protobuf::internal::kEmptyString) {
    contact_email_ = new ::std::string;
  }
  return contact_email_;
}
inline ::std::string* AccountData::release_contact_email() {
  clear_has_contact_email();
  if (contact_email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contact_email_;
    contact_email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string contact_phone = 16;
inline bool AccountData::has_contact_phone() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AccountData::set_has_contact_phone() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AccountData::clear_has_contact_phone() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AccountData::clear_contact_phone() {
  if (contact_phone_ != &::google::protobuf::internal::kEmptyString) {
    contact_phone_->clear();
  }
  clear_has_contact_phone();
}
inline const ::std::string& AccountData::contact_phone() const {
  return *contact_phone_;
}
inline void AccountData::set_contact_phone(const ::std::string& value) {
  set_has_contact_phone();
  if (contact_phone_ == &::google::protobuf::internal::kEmptyString) {
    contact_phone_ = new ::std::string;
  }
  contact_phone_->assign(value);
}
inline void AccountData::set_contact_phone(const char* value) {
  set_has_contact_phone();
  if (contact_phone_ == &::google::protobuf::internal::kEmptyString) {
    contact_phone_ = new ::std::string;
  }
  contact_phone_->assign(value);
}
inline void AccountData::set_contact_phone(const char* value, size_t size) {
  set_has_contact_phone();
  if (contact_phone_ == &::google::protobuf::internal::kEmptyString) {
    contact_phone_ = new ::std::string;
  }
  contact_phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_contact_phone() {
  set_has_contact_phone();
  if (contact_phone_ == &::google::protobuf::internal::kEmptyString) {
    contact_phone_ = new ::std::string;
  }
  return contact_phone_;
}
inline ::std::string* AccountData::release_contact_phone() {
  clear_has_contact_phone();
  if (contact_phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contact_phone_;
    contact_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string trading_firm_name = 17;
inline bool AccountData::has_trading_firm_name() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AccountData::set_has_trading_firm_name() {
  _has_bits_[0] |= 0x00010000u;
}
inline void AccountData::clear_has_trading_firm_name() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void AccountData::clear_trading_firm_name() {
  if (trading_firm_name_ != &::google::protobuf::internal::kEmptyString) {
    trading_firm_name_->clear();
  }
  clear_has_trading_firm_name();
}
inline const ::std::string& AccountData::trading_firm_name() const {
  return *trading_firm_name_;
}
inline void AccountData::set_trading_firm_name(const ::std::string& value) {
  set_has_trading_firm_name();
  if (trading_firm_name_ == &::google::protobuf::internal::kEmptyString) {
    trading_firm_name_ = new ::std::string;
  }
  trading_firm_name_->assign(value);
}
inline void AccountData::set_trading_firm_name(const char* value) {
  set_has_trading_firm_name();
  if (trading_firm_name_ == &::google::protobuf::internal::kEmptyString) {
    trading_firm_name_ = new ::std::string;
  }
  trading_firm_name_->assign(value);
}
inline void AccountData::set_trading_firm_name(const char* value, size_t size) {
  set_has_trading_firm_name();
  if (trading_firm_name_ == &::google::protobuf::internal::kEmptyString) {
    trading_firm_name_ = new ::std::string;
  }
  trading_firm_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_trading_firm_name() {
  set_has_trading_firm_name();
  if (trading_firm_name_ == &::google::protobuf::internal::kEmptyString) {
    trading_firm_name_ = new ::std::string;
  }
  return trading_firm_name_;
}
inline ::std::string* AccountData::release_trading_firm_name() {
  clear_has_trading_firm_name();
  if (trading_firm_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trading_firm_name_;
    trading_firm_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string trading_firm_email = 18;
inline bool AccountData::has_trading_firm_email() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AccountData::set_has_trading_firm_email() {
  _has_bits_[0] |= 0x00020000u;
}
inline void AccountData::clear_has_trading_firm_email() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void AccountData::clear_trading_firm_email() {
  if (trading_firm_email_ != &::google::protobuf::internal::kEmptyString) {
    trading_firm_email_->clear();
  }
  clear_has_trading_firm_email();
}
inline const ::std::string& AccountData::trading_firm_email() const {
  return *trading_firm_email_;
}
inline void AccountData::set_trading_firm_email(const ::std::string& value) {
  set_has_trading_firm_email();
  if (trading_firm_email_ == &::google::protobuf::internal::kEmptyString) {
    trading_firm_email_ = new ::std::string;
  }
  trading_firm_email_->assign(value);
}
inline void AccountData::set_trading_firm_email(const char* value) {
  set_has_trading_firm_email();
  if (trading_firm_email_ == &::google::protobuf::internal::kEmptyString) {
    trading_firm_email_ = new ::std::string;
  }
  trading_firm_email_->assign(value);
}
inline void AccountData::set_trading_firm_email(const char* value, size_t size) {
  set_has_trading_firm_email();
  if (trading_firm_email_ == &::google::protobuf::internal::kEmptyString) {
    trading_firm_email_ = new ::std::string;
  }
  trading_firm_email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_trading_firm_email() {
  set_has_trading_firm_email();
  if (trading_firm_email_ == &::google::protobuf::internal::kEmptyString) {
    trading_firm_email_ = new ::std::string;
  }
  return trading_firm_email_;
}
inline ::std::string* AccountData::release_trading_firm_email() {
  clear_has_trading_firm_email();
  if (trading_firm_email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trading_firm_email_;
    trading_firm_email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string trading_firm_phone = 19;
inline bool AccountData::has_trading_firm_phone() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AccountData::set_has_trading_firm_phone() {
  _has_bits_[0] |= 0x00040000u;
}
inline void AccountData::clear_has_trading_firm_phone() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void AccountData::clear_trading_firm_phone() {
  if (trading_firm_phone_ != &::google::protobuf::internal::kEmptyString) {
    trading_firm_phone_->clear();
  }
  clear_has_trading_firm_phone();
}
inline const ::std::string& AccountData::trading_firm_phone() const {
  return *trading_firm_phone_;
}
inline void AccountData::set_trading_firm_phone(const ::std::string& value) {
  set_has_trading_firm_phone();
  if (trading_firm_phone_ == &::google::protobuf::internal::kEmptyString) {
    trading_firm_phone_ = new ::std::string;
  }
  trading_firm_phone_->assign(value);
}
inline void AccountData::set_trading_firm_phone(const char* value) {
  set_has_trading_firm_phone();
  if (trading_firm_phone_ == &::google::protobuf::internal::kEmptyString) {
    trading_firm_phone_ = new ::std::string;
  }
  trading_firm_phone_->assign(value);
}
inline void AccountData::set_trading_firm_phone(const char* value, size_t size) {
  set_has_trading_firm_phone();
  if (trading_firm_phone_ == &::google::protobuf::internal::kEmptyString) {
    trading_firm_phone_ = new ::std::string;
  }
  trading_firm_phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_trading_firm_phone() {
  set_has_trading_firm_phone();
  if (trading_firm_phone_ == &::google::protobuf::internal::kEmptyString) {
    trading_firm_phone_ = new ::std::string;
  }
  return trading_firm_phone_;
}
inline ::std::string* AccountData::release_trading_firm_phone() {
  clear_has_trading_firm_phone();
  if (trading_firm_phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trading_firm_phone_;
    trading_firm_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string added_datetime = 20;
inline bool AccountData::has_added_datetime() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void AccountData::set_has_added_datetime() {
  _has_bits_[0] |= 0x00080000u;
}
inline void AccountData::clear_has_added_datetime() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void AccountData::clear_added_datetime() {
  if (added_datetime_ != &::google::protobuf::internal::kEmptyString) {
    added_datetime_->clear();
  }
  clear_has_added_datetime();
}
inline const ::std::string& AccountData::added_datetime() const {
  return *added_datetime_;
}
inline void AccountData::set_added_datetime(const ::std::string& value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void AccountData::set_added_datetime(const char* value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void AccountData::set_added_datetime(const char* value, size_t size) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_added_datetime() {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  return added_datetime_;
}
inline ::std::string* AccountData::release_added_datetime() {
  clear_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_datetime_;
    added_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string added_by = 21;
inline bool AccountData::has_added_by() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void AccountData::set_has_added_by() {
  _has_bits_[0] |= 0x00100000u;
}
inline void AccountData::clear_has_added_by() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void AccountData::clear_added_by() {
  if (added_by_ != &::google::protobuf::internal::kEmptyString) {
    added_by_->clear();
  }
  clear_has_added_by();
}
inline const ::std::string& AccountData::added_by() const {
  return *added_by_;
}
inline void AccountData::set_added_by(const ::std::string& value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void AccountData::set_added_by(const char* value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void AccountData::set_added_by(const char* value, size_t size) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_added_by() {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  return added_by_;
}
inline ::std::string* AccountData::release_added_by() {
  clear_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_by_;
    added_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_datetime = 22;
inline bool AccountData::has_updated_datetime() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void AccountData::set_has_updated_datetime() {
  _has_bits_[0] |= 0x00200000u;
}
inline void AccountData::clear_has_updated_datetime() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void AccountData::clear_updated_datetime() {
  if (updated_datetime_ != &::google::protobuf::internal::kEmptyString) {
    updated_datetime_->clear();
  }
  clear_has_updated_datetime();
}
inline const ::std::string& AccountData::updated_datetime() const {
  return *updated_datetime_;
}
inline void AccountData::set_updated_datetime(const ::std::string& value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void AccountData::set_updated_datetime(const char* value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void AccountData::set_updated_datetime(const char* value, size_t size) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_updated_datetime() {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  return updated_datetime_;
}
inline ::std::string* AccountData::release_updated_datetime() {
  clear_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_datetime_;
    updated_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_by = 23;
inline bool AccountData::has_updated_by() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void AccountData::set_has_updated_by() {
  _has_bits_[0] |= 0x00400000u;
}
inline void AccountData::clear_has_updated_by() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void AccountData::clear_updated_by() {
  if (updated_by_ != &::google::protobuf::internal::kEmptyString) {
    updated_by_->clear();
  }
  clear_has_updated_by();
}
inline const ::std::string& AccountData::updated_by() const {
  return *updated_by_;
}
inline void AccountData::set_updated_by(const ::std::string& value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void AccountData::set_updated_by(const char* value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void AccountData::set_updated_by(const char* value, size_t size) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountData::mutable_updated_by() {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  return updated_by_;
}
inline ::std::string* AccountData::release_updated_by() {
  clear_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_by_;
    updated_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OrderData

// optional string order_id = 1;
inline bool OrderData::has_order_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderData::set_has_order_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderData::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderData::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& OrderData::order_id() const {
  return *order_id_;
}
inline void OrderData::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void OrderData::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void OrderData::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* OrderData::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string external_order_id = 2;
inline bool OrderData::has_external_order_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderData::set_has_external_order_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderData::clear_has_external_order_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderData::clear_external_order_id() {
  if (external_order_id_ != &::google::protobuf::internal::kEmptyString) {
    external_order_id_->clear();
  }
  clear_has_external_order_id();
}
inline const ::std::string& OrderData::external_order_id() const {
  return *external_order_id_;
}
inline void OrderData::set_external_order_id(const ::std::string& value) {
  set_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    external_order_id_ = new ::std::string;
  }
  external_order_id_->assign(value);
}
inline void OrderData::set_external_order_id(const char* value) {
  set_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    external_order_id_ = new ::std::string;
  }
  external_order_id_->assign(value);
}
inline void OrderData::set_external_order_id(const char* value, size_t size) {
  set_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    external_order_id_ = new ::std::string;
  }
  external_order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_external_order_id() {
  set_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    external_order_id_ = new ::std::string;
  }
  return external_order_id_;
}
inline ::std::string* OrderData::release_external_order_id() {
  clear_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = external_order_id_;
    external_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string investment_system_id = 3;
inline bool OrderData::has_investment_system_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderData::set_has_investment_system_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderData::clear_has_investment_system_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderData::clear_investment_system_id() {
  if (investment_system_id_ != &::google::protobuf::internal::kEmptyString) {
    investment_system_id_->clear();
  }
  clear_has_investment_system_id();
}
inline const ::std::string& OrderData::investment_system_id() const {
  return *investment_system_id_;
}
inline void OrderData::set_investment_system_id(const ::std::string& value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void OrderData::set_investment_system_id(const char* value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void OrderData::set_investment_system_id(const char* value, size_t size) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_investment_system_id() {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  return investment_system_id_;
}
inline ::std::string* OrderData::release_investment_system_id() {
  clear_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = investment_system_id_;
    investment_system_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string order_type = 4;
inline bool OrderData::has_order_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderData::set_has_order_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderData::clear_has_order_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderData::clear_order_type() {
  if (order_type_ != &::google::protobuf::internal::kEmptyString) {
    order_type_->clear();
  }
  clear_has_order_type();
}
inline const ::std::string& OrderData::order_type() const {
  return *order_type_;
}
inline void OrderData::set_order_type(const ::std::string& value) {
  set_has_order_type();
  if (order_type_ == &::google::protobuf::internal::kEmptyString) {
    order_type_ = new ::std::string;
  }
  order_type_->assign(value);
}
inline void OrderData::set_order_type(const char* value) {
  set_has_order_type();
  if (order_type_ == &::google::protobuf::internal::kEmptyString) {
    order_type_ = new ::std::string;
  }
  order_type_->assign(value);
}
inline void OrderData::set_order_type(const char* value, size_t size) {
  set_has_order_type();
  if (order_type_ == &::google::protobuf::internal::kEmptyString) {
    order_type_ = new ::std::string;
  }
  order_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_order_type() {
  set_has_order_type();
  if (order_type_ == &::google::protobuf::internal::kEmptyString) {
    order_type_ = new ::std::string;
  }
  return order_type_;
}
inline ::std::string* OrderData::release_order_type() {
  clear_has_order_type();
  if (order_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_type_;
    order_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string order_status = 5;
inline bool OrderData::has_order_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderData::set_has_order_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderData::clear_has_order_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderData::clear_order_status() {
  if (order_status_ != &::google::protobuf::internal::kEmptyString) {
    order_status_->clear();
  }
  clear_has_order_status();
}
inline const ::std::string& OrderData::order_status() const {
  return *order_status_;
}
inline void OrderData::set_order_status(const ::std::string& value) {
  set_has_order_status();
  if (order_status_ == &::google::protobuf::internal::kEmptyString) {
    order_status_ = new ::std::string;
  }
  order_status_->assign(value);
}
inline void OrderData::set_order_status(const char* value) {
  set_has_order_status();
  if (order_status_ == &::google::protobuf::internal::kEmptyString) {
    order_status_ = new ::std::string;
  }
  order_status_->assign(value);
}
inline void OrderData::set_order_status(const char* value, size_t size) {
  set_has_order_status();
  if (order_status_ == &::google::protobuf::internal::kEmptyString) {
    order_status_ = new ::std::string;
  }
  order_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_order_status() {
  set_has_order_status();
  if (order_status_ == &::google::protobuf::internal::kEmptyString) {
    order_status_ = new ::std::string;
  }
  return order_status_;
}
inline ::std::string* OrderData::release_order_status() {
  clear_has_order_status();
  if (order_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_status_;
    order_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string instrument_id = 6;
inline bool OrderData::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderData::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderData::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderData::clear_instrument_id() {
  if (instrument_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_id_->clear();
  }
  clear_has_instrument_id();
}
inline const ::std::string& OrderData::instrument_id() const {
  return *instrument_id_;
}
inline void OrderData::set_instrument_id(const ::std::string& value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void OrderData::set_instrument_id(const char* value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void OrderData::set_instrument_id(const char* value, size_t size) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_instrument_id() {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  return instrument_id_;
}
inline ::std::string* OrderData::release_instrument_id() {
  clear_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_id_;
    instrument_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string symbol = 7;
inline bool OrderData::has_symbol() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderData::set_has_symbol() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderData::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderData::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& OrderData::symbol() const {
  return *symbol_;
}
inline void OrderData::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void OrderData::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void OrderData::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* OrderData::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string tif = 8;
inline bool OrderData::has_tif() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderData::set_has_tif() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderData::clear_has_tif() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderData::clear_tif() {
  if (tif_ != &::google::protobuf::internal::kEmptyString) {
    tif_->clear();
  }
  clear_has_tif();
}
inline const ::std::string& OrderData::tif() const {
  return *tif_;
}
inline void OrderData::set_tif(const ::std::string& value) {
  set_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    tif_ = new ::std::string;
  }
  tif_->assign(value);
}
inline void OrderData::set_tif(const char* value) {
  set_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    tif_ = new ::std::string;
  }
  tif_->assign(value);
}
inline void OrderData::set_tif(const char* value, size_t size) {
  set_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    tif_ = new ::std::string;
  }
  tif_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_tif() {
  set_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    tif_ = new ::std::string;
  }
  return tif_;
}
inline ::std::string* OrderData::release_tif() {
  clear_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tif_;
    tif_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string side_code = 9;
inline bool OrderData::has_side_code() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderData::set_has_side_code() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderData::clear_has_side_code() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderData::clear_side_code() {
  if (side_code_ != &::google::protobuf::internal::kEmptyString) {
    side_code_->clear();
  }
  clear_has_side_code();
}
inline const ::std::string& OrderData::side_code() const {
  return *side_code_;
}
inline void OrderData::set_side_code(const ::std::string& value) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(value);
}
inline void OrderData::set_side_code(const char* value) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(value);
}
inline void OrderData::set_side_code(const char* value, size_t size) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_side_code() {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  return side_code_;
}
inline ::std::string* OrderData::release_side_code() {
  clear_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = side_code_;
    side_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string base_ccy = 10;
inline bool OrderData::has_base_ccy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OrderData::set_has_base_ccy() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OrderData::clear_has_base_ccy() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OrderData::clear_base_ccy() {
  if (base_ccy_ != &::google::protobuf::internal::kEmptyString) {
    base_ccy_->clear();
  }
  clear_has_base_ccy();
}
inline const ::std::string& OrderData::base_ccy() const {
  return *base_ccy_;
}
inline void OrderData::set_base_ccy(const ::std::string& value) {
  set_has_base_ccy();
  if (base_ccy_ == &::google::protobuf::internal::kEmptyString) {
    base_ccy_ = new ::std::string;
  }
  base_ccy_->assign(value);
}
inline void OrderData::set_base_ccy(const char* value) {
  set_has_base_ccy();
  if (base_ccy_ == &::google::protobuf::internal::kEmptyString) {
    base_ccy_ = new ::std::string;
  }
  base_ccy_->assign(value);
}
inline void OrderData::set_base_ccy(const char* value, size_t size) {
  set_has_base_ccy();
  if (base_ccy_ == &::google::protobuf::internal::kEmptyString) {
    base_ccy_ = new ::std::string;
  }
  base_ccy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_base_ccy() {
  set_has_base_ccy();
  if (base_ccy_ == &::google::protobuf::internal::kEmptyString) {
    base_ccy_ = new ::std::string;
  }
  return base_ccy_;
}
inline ::std::string* OrderData::release_base_ccy() {
  clear_has_base_ccy();
  if (base_ccy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = base_ccy_;
    base_ccy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string order_qty = 11 [default = "0"];
inline bool OrderData::has_order_qty() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OrderData::set_has_order_qty() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OrderData::clear_has_order_qty() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OrderData::clear_order_qty() {
  if (order_qty_ != &_default_order_qty_) {
    order_qty_->assign(_default_order_qty_);
  }
  clear_has_order_qty();
}
inline const ::std::string& OrderData::order_qty() const {
  return *order_qty_;
}
inline void OrderData::set_order_qty(const ::std::string& value) {
  set_has_order_qty();
  if (order_qty_ == &_default_order_qty_) {
    order_qty_ = new ::std::string;
  }
  order_qty_->assign(value);
}
inline void OrderData::set_order_qty(const char* value) {
  set_has_order_qty();
  if (order_qty_ == &_default_order_qty_) {
    order_qty_ = new ::std::string;
  }
  order_qty_->assign(value);
}
inline void OrderData::set_order_qty(const char* value, size_t size) {
  set_has_order_qty();
  if (order_qty_ == &_default_order_qty_) {
    order_qty_ = new ::std::string;
  }
  order_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_order_qty() {
  set_has_order_qty();
  if (order_qty_ == &_default_order_qty_) {
    order_qty_ = new ::std::string(_default_order_qty_);
  }
  return order_qty_;
}
inline ::std::string* OrderData::release_order_qty() {
  clear_has_order_qty();
  if (order_qty_ == &_default_order_qty_) {
    return NULL;
  } else {
    ::std::string* temp = order_qty_;
    order_qty_ = const_cast< ::std::string*>(&_default_order_qty_);
    return temp;
  }
}

// optional string open_qty = 12 [default = "0"];
inline bool OrderData::has_open_qty() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OrderData::set_has_open_qty() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OrderData::clear_has_open_qty() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OrderData::clear_open_qty() {
  if (open_qty_ != &_default_open_qty_) {
    open_qty_->assign(_default_open_qty_);
  }
  clear_has_open_qty();
}
inline const ::std::string& OrderData::open_qty() const {
  return *open_qty_;
}
inline void OrderData::set_open_qty(const ::std::string& value) {
  set_has_open_qty();
  if (open_qty_ == &_default_open_qty_) {
    open_qty_ = new ::std::string;
  }
  open_qty_->assign(value);
}
inline void OrderData::set_open_qty(const char* value) {
  set_has_open_qty();
  if (open_qty_ == &_default_open_qty_) {
    open_qty_ = new ::std::string;
  }
  open_qty_->assign(value);
}
inline void OrderData::set_open_qty(const char* value, size_t size) {
  set_has_open_qty();
  if (open_qty_ == &_default_open_qty_) {
    open_qty_ = new ::std::string;
  }
  open_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_open_qty() {
  set_has_open_qty();
  if (open_qty_ == &_default_open_qty_) {
    open_qty_ = new ::std::string(_default_open_qty_);
  }
  return open_qty_;
}
inline ::std::string* OrderData::release_open_qty() {
  clear_has_open_qty();
  if (open_qty_ == &_default_open_qty_) {
    return NULL;
  } else {
    ::std::string* temp = open_qty_;
    open_qty_ = const_cast< ::std::string*>(&_default_open_qty_);
    return temp;
  }
}

// optional string released_qty = 13 [default = "0"];
inline bool OrderData::has_released_qty() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OrderData::set_has_released_qty() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OrderData::clear_has_released_qty() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OrderData::clear_released_qty() {
  if (released_qty_ != &_default_released_qty_) {
    released_qty_->assign(_default_released_qty_);
  }
  clear_has_released_qty();
}
inline const ::std::string& OrderData::released_qty() const {
  return *released_qty_;
}
inline void OrderData::set_released_qty(const ::std::string& value) {
  set_has_released_qty();
  if (released_qty_ == &_default_released_qty_) {
    released_qty_ = new ::std::string;
  }
  released_qty_->assign(value);
}
inline void OrderData::set_released_qty(const char* value) {
  set_has_released_qty();
  if (released_qty_ == &_default_released_qty_) {
    released_qty_ = new ::std::string;
  }
  released_qty_->assign(value);
}
inline void OrderData::set_released_qty(const char* value, size_t size) {
  set_has_released_qty();
  if (released_qty_ == &_default_released_qty_) {
    released_qty_ = new ::std::string;
  }
  released_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_released_qty() {
  set_has_released_qty();
  if (released_qty_ == &_default_released_qty_) {
    released_qty_ = new ::std::string(_default_released_qty_);
  }
  return released_qty_;
}
inline ::std::string* OrderData::release_released_qty() {
  clear_has_released_qty();
  if (released_qty_ == &_default_released_qty_) {
    return NULL;
  } else {
    ::std::string* temp = released_qty_;
    released_qty_ = const_cast< ::std::string*>(&_default_released_qty_);
    return temp;
  }
}

// optional string executed_qty = 14 [default = "0"];
inline bool OrderData::has_executed_qty() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void OrderData::set_has_executed_qty() {
  _has_bits_[0] |= 0x00002000u;
}
inline void OrderData::clear_has_executed_qty() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void OrderData::clear_executed_qty() {
  if (executed_qty_ != &_default_executed_qty_) {
    executed_qty_->assign(_default_executed_qty_);
  }
  clear_has_executed_qty();
}
inline const ::std::string& OrderData::executed_qty() const {
  return *executed_qty_;
}
inline void OrderData::set_executed_qty(const ::std::string& value) {
  set_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    executed_qty_ = new ::std::string;
  }
  executed_qty_->assign(value);
}
inline void OrderData::set_executed_qty(const char* value) {
  set_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    executed_qty_ = new ::std::string;
  }
  executed_qty_->assign(value);
}
inline void OrderData::set_executed_qty(const char* value, size_t size) {
  set_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    executed_qty_ = new ::std::string;
  }
  executed_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_executed_qty() {
  set_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    executed_qty_ = new ::std::string(_default_executed_qty_);
  }
  return executed_qty_;
}
inline ::std::string* OrderData::release_executed_qty() {
  clear_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    return NULL;
  } else {
    ::std::string* temp = executed_qty_;
    executed_qty_ = const_cast< ::std::string*>(&_default_executed_qty_);
    return temp;
  }
}

// optional string limit_prc = 15 [default = "0"];
inline bool OrderData::has_limit_prc() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void OrderData::set_has_limit_prc() {
  _has_bits_[0] |= 0x00004000u;
}
inline void OrderData::clear_has_limit_prc() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void OrderData::clear_limit_prc() {
  if (limit_prc_ != &_default_limit_prc_) {
    limit_prc_->assign(_default_limit_prc_);
  }
  clear_has_limit_prc();
}
inline const ::std::string& OrderData::limit_prc() const {
  return *limit_prc_;
}
inline void OrderData::set_limit_prc(const ::std::string& value) {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string;
  }
  limit_prc_->assign(value);
}
inline void OrderData::set_limit_prc(const char* value) {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string;
  }
  limit_prc_->assign(value);
}
inline void OrderData::set_limit_prc(const char* value, size_t size) {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string;
  }
  limit_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_limit_prc() {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string(_default_limit_prc_);
  }
  return limit_prc_;
}
inline ::std::string* OrderData::release_limit_prc() {
  clear_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    return NULL;
  } else {
    ::std::string* temp = limit_prc_;
    limit_prc_ = const_cast< ::std::string*>(&_default_limit_prc_);
    return temp;
  }
}

// optional string stop_prc = 16 [default = "0"];
inline bool OrderData::has_stop_prc() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void OrderData::set_has_stop_prc() {
  _has_bits_[0] |= 0x00008000u;
}
inline void OrderData::clear_has_stop_prc() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void OrderData::clear_stop_prc() {
  if (stop_prc_ != &_default_stop_prc_) {
    stop_prc_->assign(_default_stop_prc_);
  }
  clear_has_stop_prc();
}
inline const ::std::string& OrderData::stop_prc() const {
  return *stop_prc_;
}
inline void OrderData::set_stop_prc(const ::std::string& value) {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string;
  }
  stop_prc_->assign(value);
}
inline void OrderData::set_stop_prc(const char* value) {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string;
  }
  stop_prc_->assign(value);
}
inline void OrderData::set_stop_prc(const char* value, size_t size) {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string;
  }
  stop_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_stop_prc() {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string(_default_stop_prc_);
  }
  return stop_prc_;
}
inline ::std::string* OrderData::release_stop_prc() {
  clear_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    return NULL;
  } else {
    ::std::string* temp = stop_prc_;
    stop_prc_ = const_cast< ::std::string*>(&_default_stop_prc_);
    return temp;
  }
}

// optional string mark_prc = 17 [default = "0"];
inline bool OrderData::has_mark_prc() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void OrderData::set_has_mark_prc() {
  _has_bits_[0] |= 0x00010000u;
}
inline void OrderData::clear_has_mark_prc() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void OrderData::clear_mark_prc() {
  if (mark_prc_ != &_default_mark_prc_) {
    mark_prc_->assign(_default_mark_prc_);
  }
  clear_has_mark_prc();
}
inline const ::std::string& OrderData::mark_prc() const {
  return *mark_prc_;
}
inline void OrderData::set_mark_prc(const ::std::string& value) {
  set_has_mark_prc();
  if (mark_prc_ == &_default_mark_prc_) {
    mark_prc_ = new ::std::string;
  }
  mark_prc_->assign(value);
}
inline void OrderData::set_mark_prc(const char* value) {
  set_has_mark_prc();
  if (mark_prc_ == &_default_mark_prc_) {
    mark_prc_ = new ::std::string;
  }
  mark_prc_->assign(value);
}
inline void OrderData::set_mark_prc(const char* value, size_t size) {
  set_has_mark_prc();
  if (mark_prc_ == &_default_mark_prc_) {
    mark_prc_ = new ::std::string;
  }
  mark_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_mark_prc() {
  set_has_mark_prc();
  if (mark_prc_ == &_default_mark_prc_) {
    mark_prc_ = new ::std::string(_default_mark_prc_);
  }
  return mark_prc_;
}
inline ::std::string* OrderData::release_mark_prc() {
  clear_has_mark_prc();
  if (mark_prc_ == &_default_mark_prc_) {
    return NULL;
  } else {
    ::std::string* temp = mark_prc_;
    mark_prc_ = const_cast< ::std::string*>(&_default_mark_prc_);
    return temp;
  }
}

// optional string average_prc = 18 [default = "0"];
inline bool OrderData::has_average_prc() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void OrderData::set_has_average_prc() {
  _has_bits_[0] |= 0x00020000u;
}
inline void OrderData::clear_has_average_prc() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void OrderData::clear_average_prc() {
  if (average_prc_ != &_default_average_prc_) {
    average_prc_->assign(_default_average_prc_);
  }
  clear_has_average_prc();
}
inline const ::std::string& OrderData::average_prc() const {
  return *average_prc_;
}
inline void OrderData::set_average_prc(const ::std::string& value) {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string;
  }
  average_prc_->assign(value);
}
inline void OrderData::set_average_prc(const char* value) {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string;
  }
  average_prc_->assign(value);
}
inline void OrderData::set_average_prc(const char* value, size_t size) {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string;
  }
  average_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_average_prc() {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string(_default_average_prc_);
  }
  return average_prc_;
}
inline ::std::string* OrderData::release_average_prc() {
  clear_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    return NULL;
  } else {
    ::std::string* temp = average_prc_;
    average_prc_ = const_cast< ::std::string*>(&_default_average_prc_);
    return temp;
  }
}

// optional string entry_prc = 19 [default = "0"];
inline bool OrderData::has_entry_prc() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void OrderData::set_has_entry_prc() {
  _has_bits_[0] |= 0x00040000u;
}
inline void OrderData::clear_has_entry_prc() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void OrderData::clear_entry_prc() {
  if (entry_prc_ != &_default_entry_prc_) {
    entry_prc_->assign(_default_entry_prc_);
  }
  clear_has_entry_prc();
}
inline const ::std::string& OrderData::entry_prc() const {
  return *entry_prc_;
}
inline void OrderData::set_entry_prc(const ::std::string& value) {
  set_has_entry_prc();
  if (entry_prc_ == &_default_entry_prc_) {
    entry_prc_ = new ::std::string;
  }
  entry_prc_->assign(value);
}
inline void OrderData::set_entry_prc(const char* value) {
  set_has_entry_prc();
  if (entry_prc_ == &_default_entry_prc_) {
    entry_prc_ = new ::std::string;
  }
  entry_prc_->assign(value);
}
inline void OrderData::set_entry_prc(const char* value, size_t size) {
  set_has_entry_prc();
  if (entry_prc_ == &_default_entry_prc_) {
    entry_prc_ = new ::std::string;
  }
  entry_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_entry_prc() {
  set_has_entry_prc();
  if (entry_prc_ == &_default_entry_prc_) {
    entry_prc_ = new ::std::string(_default_entry_prc_);
  }
  return entry_prc_;
}
inline ::std::string* OrderData::release_entry_prc() {
  clear_has_entry_prc();
  if (entry_prc_ == &_default_entry_prc_) {
    return NULL;
  } else {
    ::std::string* temp = entry_prc_;
    entry_prc_ = const_cast< ::std::string*>(&_default_entry_prc_);
    return temp;
  }
}

// optional string released_val = 20 [default = "0"];
inline bool OrderData::has_released_val() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void OrderData::set_has_released_val() {
  _has_bits_[0] |= 0x00080000u;
}
inline void OrderData::clear_has_released_val() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void OrderData::clear_released_val() {
  if (released_val_ != &_default_released_val_) {
    released_val_->assign(_default_released_val_);
  }
  clear_has_released_val();
}
inline const ::std::string& OrderData::released_val() const {
  return *released_val_;
}
inline void OrderData::set_released_val(const ::std::string& value) {
  set_has_released_val();
  if (released_val_ == &_default_released_val_) {
    released_val_ = new ::std::string;
  }
  released_val_->assign(value);
}
inline void OrderData::set_released_val(const char* value) {
  set_has_released_val();
  if (released_val_ == &_default_released_val_) {
    released_val_ = new ::std::string;
  }
  released_val_->assign(value);
}
inline void OrderData::set_released_val(const char* value, size_t size) {
  set_has_released_val();
  if (released_val_ == &_default_released_val_) {
    released_val_ = new ::std::string;
  }
  released_val_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_released_val() {
  set_has_released_val();
  if (released_val_ == &_default_released_val_) {
    released_val_ = new ::std::string(_default_released_val_);
  }
  return released_val_;
}
inline ::std::string* OrderData::release_released_val() {
  clear_has_released_val();
  if (released_val_ == &_default_released_val_) {
    return NULL;
  } else {
    ::std::string* temp = released_val_;
    released_val_ = const_cast< ::std::string*>(&_default_released_val_);
    return temp;
  }
}

// optional string executed_val = 21 [default = "0"];
inline bool OrderData::has_executed_val() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void OrderData::set_has_executed_val() {
  _has_bits_[0] |= 0x00100000u;
}
inline void OrderData::clear_has_executed_val() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void OrderData::clear_executed_val() {
  if (executed_val_ != &_default_executed_val_) {
    executed_val_->assign(_default_executed_val_);
  }
  clear_has_executed_val();
}
inline const ::std::string& OrderData::executed_val() const {
  return *executed_val_;
}
inline void OrderData::set_executed_val(const ::std::string& value) {
  set_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    executed_val_ = new ::std::string;
  }
  executed_val_->assign(value);
}
inline void OrderData::set_executed_val(const char* value) {
  set_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    executed_val_ = new ::std::string;
  }
  executed_val_->assign(value);
}
inline void OrderData::set_executed_val(const char* value, size_t size) {
  set_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    executed_val_ = new ::std::string;
  }
  executed_val_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_executed_val() {
  set_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    executed_val_ = new ::std::string(_default_executed_val_);
  }
  return executed_val_;
}
inline ::std::string* OrderData::release_executed_val() {
  clear_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    return NULL;
  } else {
    ::std::string* temp = executed_val_;
    executed_val_ = const_cast< ::std::string*>(&_default_executed_val_);
    return temp;
  }
}

// optional string added_datetime = 22;
inline bool OrderData::has_added_datetime() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void OrderData::set_has_added_datetime() {
  _has_bits_[0] |= 0x00200000u;
}
inline void OrderData::clear_has_added_datetime() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void OrderData::clear_added_datetime() {
  if (added_datetime_ != &::google::protobuf::internal::kEmptyString) {
    added_datetime_->clear();
  }
  clear_has_added_datetime();
}
inline const ::std::string& OrderData::added_datetime() const {
  return *added_datetime_;
}
inline void OrderData::set_added_datetime(const ::std::string& value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void OrderData::set_added_datetime(const char* value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void OrderData::set_added_datetime(const char* value, size_t size) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_added_datetime() {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  return added_datetime_;
}
inline ::std::string* OrderData::release_added_datetime() {
  clear_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_datetime_;
    added_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string added_by = 23;
inline bool OrderData::has_added_by() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void OrderData::set_has_added_by() {
  _has_bits_[0] |= 0x00400000u;
}
inline void OrderData::clear_has_added_by() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void OrderData::clear_added_by() {
  if (added_by_ != &::google::protobuf::internal::kEmptyString) {
    added_by_->clear();
  }
  clear_has_added_by();
}
inline const ::std::string& OrderData::added_by() const {
  return *added_by_;
}
inline void OrderData::set_added_by(const ::std::string& value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void OrderData::set_added_by(const char* value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void OrderData::set_added_by(const char* value, size_t size) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_added_by() {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  return added_by_;
}
inline ::std::string* OrderData::release_added_by() {
  clear_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_by_;
    added_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_datetime = 24;
inline bool OrderData::has_updated_datetime() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void OrderData::set_has_updated_datetime() {
  _has_bits_[0] |= 0x00800000u;
}
inline void OrderData::clear_has_updated_datetime() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void OrderData::clear_updated_datetime() {
  if (updated_datetime_ != &::google::protobuf::internal::kEmptyString) {
    updated_datetime_->clear();
  }
  clear_has_updated_datetime();
}
inline const ::std::string& OrderData::updated_datetime() const {
  return *updated_datetime_;
}
inline void OrderData::set_updated_datetime(const ::std::string& value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void OrderData::set_updated_datetime(const char* value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void OrderData::set_updated_datetime(const char* value, size_t size) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_updated_datetime() {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  return updated_datetime_;
}
inline ::std::string* OrderData::release_updated_datetime() {
  clear_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_datetime_;
    updated_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_by = 25;
inline bool OrderData::has_updated_by() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void OrderData::set_has_updated_by() {
  _has_bits_[0] |= 0x01000000u;
}
inline void OrderData::clear_has_updated_by() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void OrderData::clear_updated_by() {
  if (updated_by_ != &::google::protobuf::internal::kEmptyString) {
    updated_by_->clear();
  }
  clear_has_updated_by();
}
inline const ::std::string& OrderData::updated_by() const {
  return *updated_by_;
}
inline void OrderData::set_updated_by(const ::std::string& value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void OrderData::set_updated_by(const char* value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void OrderData::set_updated_by(const char* value, size_t size) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderData::mutable_updated_by() {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  return updated_by_;
}
inline ::std::string* OrderData::release_updated_by() {
  clear_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_by_;
    updated_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AllocationData

// optional string allocation_id = 1;
inline bool AllocationData::has_allocation_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllocationData::set_has_allocation_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllocationData::clear_has_allocation_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllocationData::clear_allocation_id() {
  if (allocation_id_ != &::google::protobuf::internal::kEmptyString) {
    allocation_id_->clear();
  }
  clear_has_allocation_id();
}
inline const ::std::string& AllocationData::allocation_id() const {
  return *allocation_id_;
}
inline void AllocationData::set_allocation_id(const ::std::string& value) {
  set_has_allocation_id();
  if (allocation_id_ == &::google::protobuf::internal::kEmptyString) {
    allocation_id_ = new ::std::string;
  }
  allocation_id_->assign(value);
}
inline void AllocationData::set_allocation_id(const char* value) {
  set_has_allocation_id();
  if (allocation_id_ == &::google::protobuf::internal::kEmptyString) {
    allocation_id_ = new ::std::string;
  }
  allocation_id_->assign(value);
}
inline void AllocationData::set_allocation_id(const char* value, size_t size) {
  set_has_allocation_id();
  if (allocation_id_ == &::google::protobuf::internal::kEmptyString) {
    allocation_id_ = new ::std::string;
  }
  allocation_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocationData::mutable_allocation_id() {
  set_has_allocation_id();
  if (allocation_id_ == &::google::protobuf::internal::kEmptyString) {
    allocation_id_ = new ::std::string;
  }
  return allocation_id_;
}
inline ::std::string* AllocationData::release_allocation_id() {
  clear_has_allocation_id();
  if (allocation_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = allocation_id_;
    allocation_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string order_id = 2;
inline bool AllocationData::has_order_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllocationData::set_has_order_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AllocationData::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AllocationData::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& AllocationData::order_id() const {
  return *order_id_;
}
inline void AllocationData::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void AllocationData::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void AllocationData::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocationData::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* AllocationData::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string account_id = 3;
inline bool AllocationData::has_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AllocationData::set_has_account_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AllocationData::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AllocationData::clear_account_id() {
  if (account_id_ != &::google::protobuf::internal::kEmptyString) {
    account_id_->clear();
  }
  clear_has_account_id();
}
inline const ::std::string& AllocationData::account_id() const {
  return *account_id_;
}
inline void AllocationData::set_account_id(const ::std::string& value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void AllocationData::set_account_id(const char* value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void AllocationData::set_account_id(const char* value, size_t size) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocationData::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  return account_id_;
}
inline ::std::string* AllocationData::release_account_id() {
  clear_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_id_;
    account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string instrument_id = 4;
inline bool AllocationData::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AllocationData::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AllocationData::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AllocationData::clear_instrument_id() {
  if (instrument_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_id_->clear();
  }
  clear_has_instrument_id();
}
inline const ::std::string& AllocationData::instrument_id() const {
  return *instrument_id_;
}
inline void AllocationData::set_instrument_id(const ::std::string& value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void AllocationData::set_instrument_id(const char* value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void AllocationData::set_instrument_id(const char* value, size_t size) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocationData::mutable_instrument_id() {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  return instrument_id_;
}
inline ::std::string* AllocationData::release_instrument_id() {
  clear_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_id_;
    instrument_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string side_code = 5;
inline bool AllocationData::has_side_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AllocationData::set_has_side_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AllocationData::clear_has_side_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AllocationData::clear_side_code() {
  if (side_code_ != &::google::protobuf::internal::kEmptyString) {
    side_code_->clear();
  }
  clear_has_side_code();
}
inline const ::std::string& AllocationData::side_code() const {
  return *side_code_;
}
inline void AllocationData::set_side_code(const ::std::string& value) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(value);
}
inline void AllocationData::set_side_code(const char* value) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(value);
}
inline void AllocationData::set_side_code(const char* value, size_t size) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocationData::mutable_side_code() {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  return side_code_;
}
inline ::std::string* AllocationData::release_side_code() {
  clear_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = side_code_;
    side_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string allocation_qty = 6 [default = "0"];
inline bool AllocationData::has_allocation_qty() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AllocationData::set_has_allocation_qty() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AllocationData::clear_has_allocation_qty() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AllocationData::clear_allocation_qty() {
  if (allocation_qty_ != &_default_allocation_qty_) {
    allocation_qty_->assign(_default_allocation_qty_);
  }
  clear_has_allocation_qty();
}
inline const ::std::string& AllocationData::allocation_qty() const {
  return *allocation_qty_;
}
inline void AllocationData::set_allocation_qty(const ::std::string& value) {
  set_has_allocation_qty();
  if (allocation_qty_ == &_default_allocation_qty_) {
    allocation_qty_ = new ::std::string;
  }
  allocation_qty_->assign(value);
}
inline void AllocationData::set_allocation_qty(const char* value) {
  set_has_allocation_qty();
  if (allocation_qty_ == &_default_allocation_qty_) {
    allocation_qty_ = new ::std::string;
  }
  allocation_qty_->assign(value);
}
inline void AllocationData::set_allocation_qty(const char* value, size_t size) {
  set_has_allocation_qty();
  if (allocation_qty_ == &_default_allocation_qty_) {
    allocation_qty_ = new ::std::string;
  }
  allocation_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocationData::mutable_allocation_qty() {
  set_has_allocation_qty();
  if (allocation_qty_ == &_default_allocation_qty_) {
    allocation_qty_ = new ::std::string(_default_allocation_qty_);
  }
  return allocation_qty_;
}
inline ::std::string* AllocationData::release_allocation_qty() {
  clear_has_allocation_qty();
  if (allocation_qty_ == &_default_allocation_qty_) {
    return NULL;
  } else {
    ::std::string* temp = allocation_qty_;
    allocation_qty_ = const_cast< ::std::string*>(&_default_allocation_qty_);
    return temp;
  }
}

// optional string released_qty = 7 [default = "0"];
inline bool AllocationData::has_released_qty() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AllocationData::set_has_released_qty() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AllocationData::clear_has_released_qty() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AllocationData::clear_released_qty() {
  if (released_qty_ != &_default_released_qty_) {
    released_qty_->assign(_default_released_qty_);
  }
  clear_has_released_qty();
}
inline const ::std::string& AllocationData::released_qty() const {
  return *released_qty_;
}
inline void AllocationData::set_released_qty(const ::std::string& value) {
  set_has_released_qty();
  if (released_qty_ == &_default_released_qty_) {
    released_qty_ = new ::std::string;
  }
  released_qty_->assign(value);
}
inline void AllocationData::set_released_qty(const char* value) {
  set_has_released_qty();
  if (released_qty_ == &_default_released_qty_) {
    released_qty_ = new ::std::string;
  }
  released_qty_->assign(value);
}
inline void AllocationData::set_released_qty(const char* value, size_t size) {
  set_has_released_qty();
  if (released_qty_ == &_default_released_qty_) {
    released_qty_ = new ::std::string;
  }
  released_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocationData::mutable_released_qty() {
  set_has_released_qty();
  if (released_qty_ == &_default_released_qty_) {
    released_qty_ = new ::std::string(_default_released_qty_);
  }
  return released_qty_;
}
inline ::std::string* AllocationData::release_released_qty() {
  clear_has_released_qty();
  if (released_qty_ == &_default_released_qty_) {
    return NULL;
  } else {
    ::std::string* temp = released_qty_;
    released_qty_ = const_cast< ::std::string*>(&_default_released_qty_);
    return temp;
  }
}

// optional string executed_qty = 8 [default = "0"];
inline bool AllocationData::has_executed_qty() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AllocationData::set_has_executed_qty() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AllocationData::clear_has_executed_qty() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AllocationData::clear_executed_qty() {
  if (executed_qty_ != &_default_executed_qty_) {
    executed_qty_->assign(_default_executed_qty_);
  }
  clear_has_executed_qty();
}
inline const ::std::string& AllocationData::executed_qty() const {
  return *executed_qty_;
}
inline void AllocationData::set_executed_qty(const ::std::string& value) {
  set_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    executed_qty_ = new ::std::string;
  }
  executed_qty_->assign(value);
}
inline void AllocationData::set_executed_qty(const char* value) {
  set_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    executed_qty_ = new ::std::string;
  }
  executed_qty_->assign(value);
}
inline void AllocationData::set_executed_qty(const char* value, size_t size) {
  set_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    executed_qty_ = new ::std::string;
  }
  executed_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocationData::mutable_executed_qty() {
  set_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    executed_qty_ = new ::std::string(_default_executed_qty_);
  }
  return executed_qty_;
}
inline ::std::string* AllocationData::release_executed_qty() {
  clear_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    return NULL;
  } else {
    ::std::string* temp = executed_qty_;
    executed_qty_ = const_cast< ::std::string*>(&_default_executed_qty_);
    return temp;
  }
}

// optional string executed_val = 9 [default = "0"];
inline bool AllocationData::has_executed_val() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AllocationData::set_has_executed_val() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AllocationData::clear_has_executed_val() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AllocationData::clear_executed_val() {
  if (executed_val_ != &_default_executed_val_) {
    executed_val_->assign(_default_executed_val_);
  }
  clear_has_executed_val();
}
inline const ::std::string& AllocationData::executed_val() const {
  return *executed_val_;
}
inline void AllocationData::set_executed_val(const ::std::string& value) {
  set_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    executed_val_ = new ::std::string;
  }
  executed_val_->assign(value);
}
inline void AllocationData::set_executed_val(const char* value) {
  set_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    executed_val_ = new ::std::string;
  }
  executed_val_->assign(value);
}
inline void AllocationData::set_executed_val(const char* value, size_t size) {
  set_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    executed_val_ = new ::std::string;
  }
  executed_val_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocationData::mutable_executed_val() {
  set_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    executed_val_ = new ::std::string(_default_executed_val_);
  }
  return executed_val_;
}
inline ::std::string* AllocationData::release_executed_val() {
  clear_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    return NULL;
  } else {
    ::std::string* temp = executed_val_;
    executed_val_ = const_cast< ::std::string*>(&_default_executed_val_);
    return temp;
  }
}

// optional string average_prc = 10 [default = "0"];
inline bool AllocationData::has_average_prc() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AllocationData::set_has_average_prc() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AllocationData::clear_has_average_prc() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AllocationData::clear_average_prc() {
  if (average_prc_ != &_default_average_prc_) {
    average_prc_->assign(_default_average_prc_);
  }
  clear_has_average_prc();
}
inline const ::std::string& AllocationData::average_prc() const {
  return *average_prc_;
}
inline void AllocationData::set_average_prc(const ::std::string& value) {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string;
  }
  average_prc_->assign(value);
}
inline void AllocationData::set_average_prc(const char* value) {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string;
  }
  average_prc_->assign(value);
}
inline void AllocationData::set_average_prc(const char* value, size_t size) {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string;
  }
  average_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocationData::mutable_average_prc() {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string(_default_average_prc_);
  }
  return average_prc_;
}
inline ::std::string* AllocationData::release_average_prc() {
  clear_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    return NULL;
  } else {
    ::std::string* temp = average_prc_;
    average_prc_ = const_cast< ::std::string*>(&_default_average_prc_);
    return temp;
  }
}

// optional string added_datetime = 11;
inline bool AllocationData::has_added_datetime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AllocationData::set_has_added_datetime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AllocationData::clear_has_added_datetime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AllocationData::clear_added_datetime() {
  if (added_datetime_ != &::google::protobuf::internal::kEmptyString) {
    added_datetime_->clear();
  }
  clear_has_added_datetime();
}
inline const ::std::string& AllocationData::added_datetime() const {
  return *added_datetime_;
}
inline void AllocationData::set_added_datetime(const ::std::string& value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void AllocationData::set_added_datetime(const char* value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void AllocationData::set_added_datetime(const char* value, size_t size) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocationData::mutable_added_datetime() {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  return added_datetime_;
}
inline ::std::string* AllocationData::release_added_datetime() {
  clear_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_datetime_;
    added_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string added_by = 12;
inline bool AllocationData::has_added_by() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AllocationData::set_has_added_by() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AllocationData::clear_has_added_by() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AllocationData::clear_added_by() {
  if (added_by_ != &::google::protobuf::internal::kEmptyString) {
    added_by_->clear();
  }
  clear_has_added_by();
}
inline const ::std::string& AllocationData::added_by() const {
  return *added_by_;
}
inline void AllocationData::set_added_by(const ::std::string& value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void AllocationData::set_added_by(const char* value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void AllocationData::set_added_by(const char* value, size_t size) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocationData::mutable_added_by() {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  return added_by_;
}
inline ::std::string* AllocationData::release_added_by() {
  clear_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_by_;
    added_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_datetime = 13;
inline bool AllocationData::has_updated_datetime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AllocationData::set_has_updated_datetime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AllocationData::clear_has_updated_datetime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AllocationData::clear_updated_datetime() {
  if (updated_datetime_ != &::google::protobuf::internal::kEmptyString) {
    updated_datetime_->clear();
  }
  clear_has_updated_datetime();
}
inline const ::std::string& AllocationData::updated_datetime() const {
  return *updated_datetime_;
}
inline void AllocationData::set_updated_datetime(const ::std::string& value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void AllocationData::set_updated_datetime(const char* value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void AllocationData::set_updated_datetime(const char* value, size_t size) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocationData::mutable_updated_datetime() {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  return updated_datetime_;
}
inline ::std::string* AllocationData::release_updated_datetime() {
  clear_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_datetime_;
    updated_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_by = 14;
inline bool AllocationData::has_updated_by() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AllocationData::set_has_updated_by() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AllocationData::clear_has_updated_by() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AllocationData::clear_updated_by() {
  if (updated_by_ != &::google::protobuf::internal::kEmptyString) {
    updated_by_->clear();
  }
  clear_has_updated_by();
}
inline const ::std::string& AllocationData::updated_by() const {
  return *updated_by_;
}
inline void AllocationData::set_updated_by(const ::std::string& value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void AllocationData::set_updated_by(const char* value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void AllocationData::set_updated_by(const char* value, size_t size) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllocationData::mutable_updated_by() {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  return updated_by_;
}
inline ::std::string* AllocationData::release_updated_by() {
  clear_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_by_;
    updated_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReleaseData

// optional string release_id = 1;
inline bool ReleaseData::has_release_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReleaseData::set_has_release_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReleaseData::clear_has_release_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReleaseData::clear_release_id() {
  if (release_id_ != &::google::protobuf::internal::kEmptyString) {
    release_id_->clear();
  }
  clear_has_release_id();
}
inline const ::std::string& ReleaseData::release_id() const {
  return *release_id_;
}
inline void ReleaseData::set_release_id(const ::std::string& value) {
  set_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    release_id_ = new ::std::string;
  }
  release_id_->assign(value);
}
inline void ReleaseData::set_release_id(const char* value) {
  set_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    release_id_ = new ::std::string;
  }
  release_id_->assign(value);
}
inline void ReleaseData::set_release_id(const char* value, size_t size) {
  set_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    release_id_ = new ::std::string;
  }
  release_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_release_id() {
  set_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    release_id_ = new ::std::string;
  }
  return release_id_;
}
inline ::std::string* ReleaseData::release_release_id() {
  clear_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = release_id_;
    release_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string session_id = 2;
inline bool ReleaseData::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReleaseData::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReleaseData::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReleaseData::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& ReleaseData::session_id() const {
  return *session_id_;
}
inline void ReleaseData::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void ReleaseData::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void ReleaseData::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* ReleaseData::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string account_id = 3;
inline bool ReleaseData::has_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReleaseData::set_has_account_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReleaseData::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReleaseData::clear_account_id() {
  if (account_id_ != &::google::protobuf::internal::kEmptyString) {
    account_id_->clear();
  }
  clear_has_account_id();
}
inline const ::std::string& ReleaseData::account_id() const {
  return *account_id_;
}
inline void ReleaseData::set_account_id(const ::std::string& value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void ReleaseData::set_account_id(const char* value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void ReleaseData::set_account_id(const char* value, size_t size) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  return account_id_;
}
inline ::std::string* ReleaseData::release_account_id() {
  clear_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_id_;
    account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string order_id = 4;
inline bool ReleaseData::has_order_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReleaseData::set_has_order_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReleaseData::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReleaseData::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& ReleaseData::order_id() const {
  return *order_id_;
}
inline void ReleaseData::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void ReleaseData::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void ReleaseData::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* ReleaseData::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string allocation_id = 5;
inline bool ReleaseData::has_allocation_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReleaseData::set_has_allocation_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReleaseData::clear_has_allocation_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReleaseData::clear_allocation_id() {
  if (allocation_id_ != &::google::protobuf::internal::kEmptyString) {
    allocation_id_->clear();
  }
  clear_has_allocation_id();
}
inline const ::std::string& ReleaseData::allocation_id() const {
  return *allocation_id_;
}
inline void ReleaseData::set_allocation_id(const ::std::string& value) {
  set_has_allocation_id();
  if (allocation_id_ == &::google::protobuf::internal::kEmptyString) {
    allocation_id_ = new ::std::string;
  }
  allocation_id_->assign(value);
}
inline void ReleaseData::set_allocation_id(const char* value) {
  set_has_allocation_id();
  if (allocation_id_ == &::google::protobuf::internal::kEmptyString) {
    allocation_id_ = new ::std::string;
  }
  allocation_id_->assign(value);
}
inline void ReleaseData::set_allocation_id(const char* value, size_t size) {
  set_has_allocation_id();
  if (allocation_id_ == &::google::protobuf::internal::kEmptyString) {
    allocation_id_ = new ::std::string;
  }
  allocation_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_allocation_id() {
  set_has_allocation_id();
  if (allocation_id_ == &::google::protobuf::internal::kEmptyString) {
    allocation_id_ = new ::std::string;
  }
  return allocation_id_;
}
inline ::std::string* ReleaseData::release_allocation_id() {
  clear_has_allocation_id();
  if (allocation_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = allocation_id_;
    allocation_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string investment_system_id = 6;
inline bool ReleaseData::has_investment_system_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReleaseData::set_has_investment_system_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReleaseData::clear_has_investment_system_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReleaseData::clear_investment_system_id() {
  if (investment_system_id_ != &::google::protobuf::internal::kEmptyString) {
    investment_system_id_->clear();
  }
  clear_has_investment_system_id();
}
inline const ::std::string& ReleaseData::investment_system_id() const {
  return *investment_system_id_;
}
inline void ReleaseData::set_investment_system_id(const ::std::string& value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void ReleaseData::set_investment_system_id(const char* value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void ReleaseData::set_investment_system_id(const char* value, size_t size) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_investment_system_id() {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  return investment_system_id_;
}
inline ::std::string* ReleaseData::release_investment_system_id() {
  clear_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = investment_system_id_;
    investment_system_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string instrument_id = 7;
inline bool ReleaseData::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReleaseData::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReleaseData::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReleaseData::clear_instrument_id() {
  if (instrument_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_id_->clear();
  }
  clear_has_instrument_id();
}
inline const ::std::string& ReleaseData::instrument_id() const {
  return *instrument_id_;
}
inline void ReleaseData::set_instrument_id(const ::std::string& value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void ReleaseData::set_instrument_id(const char* value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void ReleaseData::set_instrument_id(const char* value, size_t size) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_instrument_id() {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  return instrument_id_;
}
inline ::std::string* ReleaseData::release_instrument_id() {
  clear_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_id_;
    instrument_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string compliance_audit_id = 8;
inline bool ReleaseData::has_compliance_audit_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReleaseData::set_has_compliance_audit_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReleaseData::clear_has_compliance_audit_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReleaseData::clear_compliance_audit_id() {
  if (compliance_audit_id_ != &::google::protobuf::internal::kEmptyString) {
    compliance_audit_id_->clear();
  }
  clear_has_compliance_audit_id();
}
inline const ::std::string& ReleaseData::compliance_audit_id() const {
  return *compliance_audit_id_;
}
inline void ReleaseData::set_compliance_audit_id(const ::std::string& value) {
  set_has_compliance_audit_id();
  if (compliance_audit_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_audit_id_ = new ::std::string;
  }
  compliance_audit_id_->assign(value);
}
inline void ReleaseData::set_compliance_audit_id(const char* value) {
  set_has_compliance_audit_id();
  if (compliance_audit_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_audit_id_ = new ::std::string;
  }
  compliance_audit_id_->assign(value);
}
inline void ReleaseData::set_compliance_audit_id(const char* value, size_t size) {
  set_has_compliance_audit_id();
  if (compliance_audit_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_audit_id_ = new ::std::string;
  }
  compliance_audit_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_compliance_audit_id() {
  set_has_compliance_audit_id();
  if (compliance_audit_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_audit_id_ = new ::std::string;
  }
  return compliance_audit_id_;
}
inline ::std::string* ReleaseData::release_compliance_audit_id() {
  clear_has_compliance_audit_id();
  if (compliance_audit_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = compliance_audit_id_;
    compliance_audit_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string client_order_id = 9;
inline bool ReleaseData::has_client_order_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReleaseData::set_has_client_order_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReleaseData::clear_has_client_order_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReleaseData::clear_client_order_id() {
  if (client_order_id_ != &::google::protobuf::internal::kEmptyString) {
    client_order_id_->clear();
  }
  clear_has_client_order_id();
}
inline const ::std::string& ReleaseData::client_order_id() const {
  return *client_order_id_;
}
inline void ReleaseData::set_client_order_id(const ::std::string& value) {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::kEmptyString) {
    client_order_id_ = new ::std::string;
  }
  client_order_id_->assign(value);
}
inline void ReleaseData::set_client_order_id(const char* value) {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::kEmptyString) {
    client_order_id_ = new ::std::string;
  }
  client_order_id_->assign(value);
}
inline void ReleaseData::set_client_order_id(const char* value, size_t size) {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::kEmptyString) {
    client_order_id_ = new ::std::string;
  }
  client_order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_client_order_id() {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::kEmptyString) {
    client_order_id_ = new ::std::string;
  }
  return client_order_id_;
}
inline ::std::string* ReleaseData::release_client_order_id() {
  clear_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_order_id_;
    client_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string counterparty_order_id = 10;
inline bool ReleaseData::has_counterparty_order_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ReleaseData::set_has_counterparty_order_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ReleaseData::clear_has_counterparty_order_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ReleaseData::clear_counterparty_order_id() {
  if (counterparty_order_id_ != &::google::protobuf::internal::kEmptyString) {
    counterparty_order_id_->clear();
  }
  clear_has_counterparty_order_id();
}
inline const ::std::string& ReleaseData::counterparty_order_id() const {
  return *counterparty_order_id_;
}
inline void ReleaseData::set_counterparty_order_id(const ::std::string& value) {
  set_has_counterparty_order_id();
  if (counterparty_order_id_ == &::google::protobuf::internal::kEmptyString) {
    counterparty_order_id_ = new ::std::string;
  }
  counterparty_order_id_->assign(value);
}
inline void ReleaseData::set_counterparty_order_id(const char* value) {
  set_has_counterparty_order_id();
  if (counterparty_order_id_ == &::google::protobuf::internal::kEmptyString) {
    counterparty_order_id_ = new ::std::string;
  }
  counterparty_order_id_->assign(value);
}
inline void ReleaseData::set_counterparty_order_id(const char* value, size_t size) {
  set_has_counterparty_order_id();
  if (counterparty_order_id_ == &::google::protobuf::internal::kEmptyString) {
    counterparty_order_id_ = new ::std::string;
  }
  counterparty_order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_counterparty_order_id() {
  set_has_counterparty_order_id();
  if (counterparty_order_id_ == &::google::protobuf::internal::kEmptyString) {
    counterparty_order_id_ = new ::std::string;
  }
  return counterparty_order_id_;
}
inline ::std::string* ReleaseData::release_counterparty_order_id() {
  clear_has_counterparty_order_id();
  if (counterparty_order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = counterparty_order_id_;
    counterparty_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string release_status = 11;
inline bool ReleaseData::has_release_status() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ReleaseData::set_has_release_status() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ReleaseData::clear_has_release_status() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ReleaseData::clear_release_status() {
  if (release_status_ != &::google::protobuf::internal::kEmptyString) {
    release_status_->clear();
  }
  clear_has_release_status();
}
inline const ::std::string& ReleaseData::release_status() const {
  return *release_status_;
}
inline void ReleaseData::set_release_status(const ::std::string& value) {
  set_has_release_status();
  if (release_status_ == &::google::protobuf::internal::kEmptyString) {
    release_status_ = new ::std::string;
  }
  release_status_->assign(value);
}
inline void ReleaseData::set_release_status(const char* value) {
  set_has_release_status();
  if (release_status_ == &::google::protobuf::internal::kEmptyString) {
    release_status_ = new ::std::string;
  }
  release_status_->assign(value);
}
inline void ReleaseData::set_release_status(const char* value, size_t size) {
  set_has_release_status();
  if (release_status_ == &::google::protobuf::internal::kEmptyString) {
    release_status_ = new ::std::string;
  }
  release_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_release_status() {
  set_has_release_status();
  if (release_status_ == &::google::protobuf::internal::kEmptyString) {
    release_status_ = new ::std::string;
  }
  return release_status_;
}
inline ::std::string* ReleaseData::release_release_status() {
  clear_has_release_status();
  if (release_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = release_status_;
    release_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string release_type = 12;
inline bool ReleaseData::has_release_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ReleaseData::set_has_release_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ReleaseData::clear_has_release_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ReleaseData::clear_release_type() {
  if (release_type_ != &::google::protobuf::internal::kEmptyString) {
    release_type_->clear();
  }
  clear_has_release_type();
}
inline const ::std::string& ReleaseData::release_type() const {
  return *release_type_;
}
inline void ReleaseData::set_release_type(const ::std::string& value) {
  set_has_release_type();
  if (release_type_ == &::google::protobuf::internal::kEmptyString) {
    release_type_ = new ::std::string;
  }
  release_type_->assign(value);
}
inline void ReleaseData::set_release_type(const char* value) {
  set_has_release_type();
  if (release_type_ == &::google::protobuf::internal::kEmptyString) {
    release_type_ = new ::std::string;
  }
  release_type_->assign(value);
}
inline void ReleaseData::set_release_type(const char* value, size_t size) {
  set_has_release_type();
  if (release_type_ == &::google::protobuf::internal::kEmptyString) {
    release_type_ = new ::std::string;
  }
  release_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_release_type() {
  set_has_release_type();
  if (release_type_ == &::google::protobuf::internal::kEmptyString) {
    release_type_ = new ::std::string;
  }
  return release_type_;
}
inline ::std::string* ReleaseData::release_release_type() {
  clear_has_release_type();
  if (release_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = release_type_;
    release_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string tif = 13;
inline bool ReleaseData::has_tif() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ReleaseData::set_has_tif() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ReleaseData::clear_has_tif() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ReleaseData::clear_tif() {
  if (tif_ != &::google::protobuf::internal::kEmptyString) {
    tif_->clear();
  }
  clear_has_tif();
}
inline const ::std::string& ReleaseData::tif() const {
  return *tif_;
}
inline void ReleaseData::set_tif(const ::std::string& value) {
  set_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    tif_ = new ::std::string;
  }
  tif_->assign(value);
}
inline void ReleaseData::set_tif(const char* value) {
  set_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    tif_ = new ::std::string;
  }
  tif_->assign(value);
}
inline void ReleaseData::set_tif(const char* value, size_t size) {
  set_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    tif_ = new ::std::string;
  }
  tif_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_tif() {
  set_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    tif_ = new ::std::string;
  }
  return tif_;
}
inline ::std::string* ReleaseData::release_tif() {
  clear_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tif_;
    tif_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string side_code = 14;
inline bool ReleaseData::has_side_code() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ReleaseData::set_has_side_code() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ReleaseData::clear_has_side_code() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ReleaseData::clear_side_code() {
  if (side_code_ != &::google::protobuf::internal::kEmptyString) {
    side_code_->clear();
  }
  clear_has_side_code();
}
inline const ::std::string& ReleaseData::side_code() const {
  return *side_code_;
}
inline void ReleaseData::set_side_code(const ::std::string& value) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(value);
}
inline void ReleaseData::set_side_code(const char* value) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(value);
}
inline void ReleaseData::set_side_code(const char* value, size_t size) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_side_code() {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  return side_code_;
}
inline ::std::string* ReleaseData::release_side_code() {
  clear_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = side_code_;
    side_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string release_qty = 15 [default = "0"];
inline bool ReleaseData::has_release_qty() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ReleaseData::set_has_release_qty() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ReleaseData::clear_has_release_qty() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ReleaseData::clear_release_qty() {
  if (release_qty_ != &_default_release_qty_) {
    release_qty_->assign(_default_release_qty_);
  }
  clear_has_release_qty();
}
inline const ::std::string& ReleaseData::release_qty() const {
  return *release_qty_;
}
inline void ReleaseData::set_release_qty(const ::std::string& value) {
  set_has_release_qty();
  if (release_qty_ == &_default_release_qty_) {
    release_qty_ = new ::std::string;
  }
  release_qty_->assign(value);
}
inline void ReleaseData::set_release_qty(const char* value) {
  set_has_release_qty();
  if (release_qty_ == &_default_release_qty_) {
    release_qty_ = new ::std::string;
  }
  release_qty_->assign(value);
}
inline void ReleaseData::set_release_qty(const char* value, size_t size) {
  set_has_release_qty();
  if (release_qty_ == &_default_release_qty_) {
    release_qty_ = new ::std::string;
  }
  release_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_release_qty() {
  set_has_release_qty();
  if (release_qty_ == &_default_release_qty_) {
    release_qty_ = new ::std::string(_default_release_qty_);
  }
  return release_qty_;
}
inline ::std::string* ReleaseData::release_release_qty() {
  clear_has_release_qty();
  if (release_qty_ == &_default_release_qty_) {
    return NULL;
  } else {
    ::std::string* temp = release_qty_;
    release_qty_ = const_cast< ::std::string*>(&_default_release_qty_);
    return temp;
  }
}

// optional string limit_prc = 16 [default = "0"];
inline bool ReleaseData::has_limit_prc() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ReleaseData::set_has_limit_prc() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ReleaseData::clear_has_limit_prc() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ReleaseData::clear_limit_prc() {
  if (limit_prc_ != &_default_limit_prc_) {
    limit_prc_->assign(_default_limit_prc_);
  }
  clear_has_limit_prc();
}
inline const ::std::string& ReleaseData::limit_prc() const {
  return *limit_prc_;
}
inline void ReleaseData::set_limit_prc(const ::std::string& value) {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string;
  }
  limit_prc_->assign(value);
}
inline void ReleaseData::set_limit_prc(const char* value) {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string;
  }
  limit_prc_->assign(value);
}
inline void ReleaseData::set_limit_prc(const char* value, size_t size) {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string;
  }
  limit_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_limit_prc() {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string(_default_limit_prc_);
  }
  return limit_prc_;
}
inline ::std::string* ReleaseData::release_limit_prc() {
  clear_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    return NULL;
  } else {
    ::std::string* temp = limit_prc_;
    limit_prc_ = const_cast< ::std::string*>(&_default_limit_prc_);
    return temp;
  }
}

// optional string stop_prc = 17 [default = "0"];
inline bool ReleaseData::has_stop_prc() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ReleaseData::set_has_stop_prc() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ReleaseData::clear_has_stop_prc() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ReleaseData::clear_stop_prc() {
  if (stop_prc_ != &_default_stop_prc_) {
    stop_prc_->assign(_default_stop_prc_);
  }
  clear_has_stop_prc();
}
inline const ::std::string& ReleaseData::stop_prc() const {
  return *stop_prc_;
}
inline void ReleaseData::set_stop_prc(const ::std::string& value) {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string;
  }
  stop_prc_->assign(value);
}
inline void ReleaseData::set_stop_prc(const char* value) {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string;
  }
  stop_prc_->assign(value);
}
inline void ReleaseData::set_stop_prc(const char* value, size_t size) {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string;
  }
  stop_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_stop_prc() {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string(_default_stop_prc_);
  }
  return stop_prc_;
}
inline ::std::string* ReleaseData::release_stop_prc() {
  clear_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    return NULL;
  } else {
    ::std::string* temp = stop_prc_;
    stop_prc_ = const_cast< ::std::string*>(&_default_stop_prc_);
    return temp;
  }
}

// optional string average_prc = 18 [default = "0"];
inline bool ReleaseData::has_average_prc() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ReleaseData::set_has_average_prc() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ReleaseData::clear_has_average_prc() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ReleaseData::clear_average_prc() {
  if (average_prc_ != &_default_average_prc_) {
    average_prc_->assign(_default_average_prc_);
  }
  clear_has_average_prc();
}
inline const ::std::string& ReleaseData::average_prc() const {
  return *average_prc_;
}
inline void ReleaseData::set_average_prc(const ::std::string& value) {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string;
  }
  average_prc_->assign(value);
}
inline void ReleaseData::set_average_prc(const char* value) {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string;
  }
  average_prc_->assign(value);
}
inline void ReleaseData::set_average_prc(const char* value, size_t size) {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string;
  }
  average_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_average_prc() {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string(_default_average_prc_);
  }
  return average_prc_;
}
inline ::std::string* ReleaseData::release_average_prc() {
  clear_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    return NULL;
  } else {
    ::std::string* temp = average_prc_;
    average_prc_ = const_cast< ::std::string*>(&_default_average_prc_);
    return temp;
  }
}

// optional string executed_val = 19 [default = "0"];
inline bool ReleaseData::has_executed_val() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ReleaseData::set_has_executed_val() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ReleaseData::clear_has_executed_val() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ReleaseData::clear_executed_val() {
  if (executed_val_ != &_default_executed_val_) {
    executed_val_->assign(_default_executed_val_);
  }
  clear_has_executed_val();
}
inline const ::std::string& ReleaseData::executed_val() const {
  return *executed_val_;
}
inline void ReleaseData::set_executed_val(const ::std::string& value) {
  set_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    executed_val_ = new ::std::string;
  }
  executed_val_->assign(value);
}
inline void ReleaseData::set_executed_val(const char* value) {
  set_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    executed_val_ = new ::std::string;
  }
  executed_val_->assign(value);
}
inline void ReleaseData::set_executed_val(const char* value, size_t size) {
  set_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    executed_val_ = new ::std::string;
  }
  executed_val_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_executed_val() {
  set_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    executed_val_ = new ::std::string(_default_executed_val_);
  }
  return executed_val_;
}
inline ::std::string* ReleaseData::release_executed_val() {
  clear_has_executed_val();
  if (executed_val_ == &_default_executed_val_) {
    return NULL;
  } else {
    ::std::string* temp = executed_val_;
    executed_val_ = const_cast< ::std::string*>(&_default_executed_val_);
    return temp;
  }
}

// optional string executed_qty = 20 [default = "0"];
inline bool ReleaseData::has_executed_qty() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ReleaseData::set_has_executed_qty() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ReleaseData::clear_has_executed_qty() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ReleaseData::clear_executed_qty() {
  if (executed_qty_ != &_default_executed_qty_) {
    executed_qty_->assign(_default_executed_qty_);
  }
  clear_has_executed_qty();
}
inline const ::std::string& ReleaseData::executed_qty() const {
  return *executed_qty_;
}
inline void ReleaseData::set_executed_qty(const ::std::string& value) {
  set_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    executed_qty_ = new ::std::string;
  }
  executed_qty_->assign(value);
}
inline void ReleaseData::set_executed_qty(const char* value) {
  set_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    executed_qty_ = new ::std::string;
  }
  executed_qty_->assign(value);
}
inline void ReleaseData::set_executed_qty(const char* value, size_t size) {
  set_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    executed_qty_ = new ::std::string;
  }
  executed_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_executed_qty() {
  set_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    executed_qty_ = new ::std::string(_default_executed_qty_);
  }
  return executed_qty_;
}
inline ::std::string* ReleaseData::release_executed_qty() {
  clear_has_executed_qty();
  if (executed_qty_ == &_default_executed_qty_) {
    return NULL;
  } else {
    ::std::string* temp = executed_qty_;
    executed_qty_ = const_cast< ::std::string*>(&_default_executed_qty_);
    return temp;
  }
}

// optional string added_datetime = 21;
inline bool ReleaseData::has_added_datetime() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ReleaseData::set_has_added_datetime() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ReleaseData::clear_has_added_datetime() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ReleaseData::clear_added_datetime() {
  if (added_datetime_ != &::google::protobuf::internal::kEmptyString) {
    added_datetime_->clear();
  }
  clear_has_added_datetime();
}
inline const ::std::string& ReleaseData::added_datetime() const {
  return *added_datetime_;
}
inline void ReleaseData::set_added_datetime(const ::std::string& value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void ReleaseData::set_added_datetime(const char* value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void ReleaseData::set_added_datetime(const char* value, size_t size) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_added_datetime() {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  return added_datetime_;
}
inline ::std::string* ReleaseData::release_added_datetime() {
  clear_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_datetime_;
    added_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string added_by = 22;
inline bool ReleaseData::has_added_by() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ReleaseData::set_has_added_by() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ReleaseData::clear_has_added_by() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ReleaseData::clear_added_by() {
  if (added_by_ != &::google::protobuf::internal::kEmptyString) {
    added_by_->clear();
  }
  clear_has_added_by();
}
inline const ::std::string& ReleaseData::added_by() const {
  return *added_by_;
}
inline void ReleaseData::set_added_by(const ::std::string& value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void ReleaseData::set_added_by(const char* value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void ReleaseData::set_added_by(const char* value, size_t size) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_added_by() {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  return added_by_;
}
inline ::std::string* ReleaseData::release_added_by() {
  clear_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_by_;
    added_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_datetime = 23;
inline bool ReleaseData::has_updated_datetime() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ReleaseData::set_has_updated_datetime() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ReleaseData::clear_has_updated_datetime() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ReleaseData::clear_updated_datetime() {
  if (updated_datetime_ != &::google::protobuf::internal::kEmptyString) {
    updated_datetime_->clear();
  }
  clear_has_updated_datetime();
}
inline const ::std::string& ReleaseData::updated_datetime() const {
  return *updated_datetime_;
}
inline void ReleaseData::set_updated_datetime(const ::std::string& value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void ReleaseData::set_updated_datetime(const char* value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void ReleaseData::set_updated_datetime(const char* value, size_t size) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_updated_datetime() {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  return updated_datetime_;
}
inline ::std::string* ReleaseData::release_updated_datetime() {
  clear_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_datetime_;
    updated_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_by = 24;
inline bool ReleaseData::has_updated_by() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ReleaseData::set_has_updated_by() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ReleaseData::clear_has_updated_by() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ReleaseData::clear_updated_by() {
  if (updated_by_ != &::google::protobuf::internal::kEmptyString) {
    updated_by_->clear();
  }
  clear_has_updated_by();
}
inline const ::std::string& ReleaseData::updated_by() const {
  return *updated_by_;
}
inline void ReleaseData::set_updated_by(const ::std::string& value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void ReleaseData::set_updated_by(const char* value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void ReleaseData::set_updated_by(const char* value, size_t size) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReleaseData::mutable_updated_by() {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  return updated_by_;
}
inline ::std::string* ReleaseData::release_updated_by() {
  clear_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_by_;
    updated_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ExecutionData

// optional string execution_id = 1;
inline bool ExecutionData::has_execution_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutionData::set_has_execution_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutionData::clear_has_execution_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutionData::clear_execution_id() {
  if (execution_id_ != &::google::protobuf::internal::kEmptyString) {
    execution_id_->clear();
  }
  clear_has_execution_id();
}
inline const ::std::string& ExecutionData::execution_id() const {
  return *execution_id_;
}
inline void ExecutionData::set_execution_id(const ::std::string& value) {
  set_has_execution_id();
  if (execution_id_ == &::google::protobuf::internal::kEmptyString) {
    execution_id_ = new ::std::string;
  }
  execution_id_->assign(value);
}
inline void ExecutionData::set_execution_id(const char* value) {
  set_has_execution_id();
  if (execution_id_ == &::google::protobuf::internal::kEmptyString) {
    execution_id_ = new ::std::string;
  }
  execution_id_->assign(value);
}
inline void ExecutionData::set_execution_id(const char* value, size_t size) {
  set_has_execution_id();
  if (execution_id_ == &::google::protobuf::internal::kEmptyString) {
    execution_id_ = new ::std::string;
  }
  execution_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_execution_id() {
  set_has_execution_id();
  if (execution_id_ == &::google::protobuf::internal::kEmptyString) {
    execution_id_ = new ::std::string;
  }
  return execution_id_;
}
inline ::std::string* ExecutionData::release_execution_id() {
  clear_has_execution_id();
  if (execution_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = execution_id_;
    execution_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string session_id = 2;
inline bool ExecutionData::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutionData::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutionData::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutionData::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& ExecutionData::session_id() const {
  return *session_id_;
}
inline void ExecutionData::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void ExecutionData::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void ExecutionData::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* ExecutionData::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string account_id = 3;
inline bool ExecutionData::has_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecutionData::set_has_account_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecutionData::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecutionData::clear_account_id() {
  if (account_id_ != &::google::protobuf::internal::kEmptyString) {
    account_id_->clear();
  }
  clear_has_account_id();
}
inline const ::std::string& ExecutionData::account_id() const {
  return *account_id_;
}
inline void ExecutionData::set_account_id(const ::std::string& value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void ExecutionData::set_account_id(const char* value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void ExecutionData::set_account_id(const char* value, size_t size) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  return account_id_;
}
inline ::std::string* ExecutionData::release_account_id() {
  clear_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_id_;
    account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string order_id = 4;
inline bool ExecutionData::has_order_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecutionData::set_has_order_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecutionData::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecutionData::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& ExecutionData::order_id() const {
  return *order_id_;
}
inline void ExecutionData::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void ExecutionData::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void ExecutionData::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* ExecutionData::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string release_id = 5;
inline bool ExecutionData::has_release_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExecutionData::set_has_release_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExecutionData::clear_has_release_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExecutionData::clear_release_id() {
  if (release_id_ != &::google::protobuf::internal::kEmptyString) {
    release_id_->clear();
  }
  clear_has_release_id();
}
inline const ::std::string& ExecutionData::release_id() const {
  return *release_id_;
}
inline void ExecutionData::set_release_id(const ::std::string& value) {
  set_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    release_id_ = new ::std::string;
  }
  release_id_->assign(value);
}
inline void ExecutionData::set_release_id(const char* value) {
  set_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    release_id_ = new ::std::string;
  }
  release_id_->assign(value);
}
inline void ExecutionData::set_release_id(const char* value, size_t size) {
  set_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    release_id_ = new ::std::string;
  }
  release_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_release_id() {
  set_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    release_id_ = new ::std::string;
  }
  return release_id_;
}
inline ::std::string* ExecutionData::release_release_id() {
  clear_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = release_id_;
    release_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string investment_system_id = 6;
inline bool ExecutionData::has_investment_system_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExecutionData::set_has_investment_system_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExecutionData::clear_has_investment_system_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExecutionData::clear_investment_system_id() {
  if (investment_system_id_ != &::google::protobuf::internal::kEmptyString) {
    investment_system_id_->clear();
  }
  clear_has_investment_system_id();
}
inline const ::std::string& ExecutionData::investment_system_id() const {
  return *investment_system_id_;
}
inline void ExecutionData::set_investment_system_id(const ::std::string& value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void ExecutionData::set_investment_system_id(const char* value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void ExecutionData::set_investment_system_id(const char* value, size_t size) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_investment_system_id() {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  return investment_system_id_;
}
inline ::std::string* ExecutionData::release_investment_system_id() {
  clear_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = investment_system_id_;
    investment_system_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string instrument_id = 7;
inline bool ExecutionData::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExecutionData::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExecutionData::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExecutionData::clear_instrument_id() {
  if (instrument_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_id_->clear();
  }
  clear_has_instrument_id();
}
inline const ::std::string& ExecutionData::instrument_id() const {
  return *instrument_id_;
}
inline void ExecutionData::set_instrument_id(const ::std::string& value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void ExecutionData::set_instrument_id(const char* value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void ExecutionData::set_instrument_id(const char* value, size_t size) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_instrument_id() {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  return instrument_id_;
}
inline ::std::string* ExecutionData::release_instrument_id() {
  clear_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_id_;
    instrument_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string client_order_id = 8;
inline bool ExecutionData::has_client_order_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExecutionData::set_has_client_order_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExecutionData::clear_has_client_order_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExecutionData::clear_client_order_id() {
  if (client_order_id_ != &::google::protobuf::internal::kEmptyString) {
    client_order_id_->clear();
  }
  clear_has_client_order_id();
}
inline const ::std::string& ExecutionData::client_order_id() const {
  return *client_order_id_;
}
inline void ExecutionData::set_client_order_id(const ::std::string& value) {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::kEmptyString) {
    client_order_id_ = new ::std::string;
  }
  client_order_id_->assign(value);
}
inline void ExecutionData::set_client_order_id(const char* value) {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::kEmptyString) {
    client_order_id_ = new ::std::string;
  }
  client_order_id_->assign(value);
}
inline void ExecutionData::set_client_order_id(const char* value, size_t size) {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::kEmptyString) {
    client_order_id_ = new ::std::string;
  }
  client_order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_client_order_id() {
  set_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::kEmptyString) {
    client_order_id_ = new ::std::string;
  }
  return client_order_id_;
}
inline ::std::string* ExecutionData::release_client_order_id() {
  clear_has_client_order_id();
  if (client_order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_order_id_;
    client_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string counterparty_execution_id = 9;
inline bool ExecutionData::has_counterparty_execution_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExecutionData::set_has_counterparty_execution_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExecutionData::clear_has_counterparty_execution_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExecutionData::clear_counterparty_execution_id() {
  if (counterparty_execution_id_ != &::google::protobuf::internal::kEmptyString) {
    counterparty_execution_id_->clear();
  }
  clear_has_counterparty_execution_id();
}
inline const ::std::string& ExecutionData::counterparty_execution_id() const {
  return *counterparty_execution_id_;
}
inline void ExecutionData::set_counterparty_execution_id(const ::std::string& value) {
  set_has_counterparty_execution_id();
  if (counterparty_execution_id_ == &::google::protobuf::internal::kEmptyString) {
    counterparty_execution_id_ = new ::std::string;
  }
  counterparty_execution_id_->assign(value);
}
inline void ExecutionData::set_counterparty_execution_id(const char* value) {
  set_has_counterparty_execution_id();
  if (counterparty_execution_id_ == &::google::protobuf::internal::kEmptyString) {
    counterparty_execution_id_ = new ::std::string;
  }
  counterparty_execution_id_->assign(value);
}
inline void ExecutionData::set_counterparty_execution_id(const char* value, size_t size) {
  set_has_counterparty_execution_id();
  if (counterparty_execution_id_ == &::google::protobuf::internal::kEmptyString) {
    counterparty_execution_id_ = new ::std::string;
  }
  counterparty_execution_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_counterparty_execution_id() {
  set_has_counterparty_execution_id();
  if (counterparty_execution_id_ == &::google::protobuf::internal::kEmptyString) {
    counterparty_execution_id_ = new ::std::string;
  }
  return counterparty_execution_id_;
}
inline ::std::string* ExecutionData::release_counterparty_execution_id() {
  clear_has_counterparty_execution_id();
  if (counterparty_execution_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = counterparty_execution_id_;
    counterparty_execution_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string side_code = 10;
inline bool ExecutionData::has_side_code() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ExecutionData::set_has_side_code() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ExecutionData::clear_has_side_code() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ExecutionData::clear_side_code() {
  if (side_code_ != &::google::protobuf::internal::kEmptyString) {
    side_code_->clear();
  }
  clear_has_side_code();
}
inline const ::std::string& ExecutionData::side_code() const {
  return *side_code_;
}
inline void ExecutionData::set_side_code(const ::std::string& value) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(value);
}
inline void ExecutionData::set_side_code(const char* value) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(value);
}
inline void ExecutionData::set_side_code(const char* value, size_t size) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_side_code() {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  return side_code_;
}
inline ::std::string* ExecutionData::release_side_code() {
  clear_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = side_code_;
    side_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string execution_ccy = 11;
inline bool ExecutionData::has_execution_ccy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ExecutionData::set_has_execution_ccy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ExecutionData::clear_has_execution_ccy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ExecutionData::clear_execution_ccy() {
  if (execution_ccy_ != &::google::protobuf::internal::kEmptyString) {
    execution_ccy_->clear();
  }
  clear_has_execution_ccy();
}
inline const ::std::string& ExecutionData::execution_ccy() const {
  return *execution_ccy_;
}
inline void ExecutionData::set_execution_ccy(const ::std::string& value) {
  set_has_execution_ccy();
  if (execution_ccy_ == &::google::protobuf::internal::kEmptyString) {
    execution_ccy_ = new ::std::string;
  }
  execution_ccy_->assign(value);
}
inline void ExecutionData::set_execution_ccy(const char* value) {
  set_has_execution_ccy();
  if (execution_ccy_ == &::google::protobuf::internal::kEmptyString) {
    execution_ccy_ = new ::std::string;
  }
  execution_ccy_->assign(value);
}
inline void ExecutionData::set_execution_ccy(const char* value, size_t size) {
  set_has_execution_ccy();
  if (execution_ccy_ == &::google::protobuf::internal::kEmptyString) {
    execution_ccy_ = new ::std::string;
  }
  execution_ccy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_execution_ccy() {
  set_has_execution_ccy();
  if (execution_ccy_ == &::google::protobuf::internal::kEmptyString) {
    execution_ccy_ = new ::std::string;
  }
  return execution_ccy_;
}
inline ::std::string* ExecutionData::release_execution_ccy() {
  clear_has_execution_ccy();
  if (execution_ccy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = execution_ccy_;
    execution_ccy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string execution_status = 12;
inline bool ExecutionData::has_execution_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ExecutionData::set_has_execution_status() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ExecutionData::clear_has_execution_status() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ExecutionData::clear_execution_status() {
  if (execution_status_ != &::google::protobuf::internal::kEmptyString) {
    execution_status_->clear();
  }
  clear_has_execution_status();
}
inline const ::std::string& ExecutionData::execution_status() const {
  return *execution_status_;
}
inline void ExecutionData::set_execution_status(const ::std::string& value) {
  set_has_execution_status();
  if (execution_status_ == &::google::protobuf::internal::kEmptyString) {
    execution_status_ = new ::std::string;
  }
  execution_status_->assign(value);
}
inline void ExecutionData::set_execution_status(const char* value) {
  set_has_execution_status();
  if (execution_status_ == &::google::protobuf::internal::kEmptyString) {
    execution_status_ = new ::std::string;
  }
  execution_status_->assign(value);
}
inline void ExecutionData::set_execution_status(const char* value, size_t size) {
  set_has_execution_status();
  if (execution_status_ == &::google::protobuf::internal::kEmptyString) {
    execution_status_ = new ::std::string;
  }
  execution_status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_execution_status() {
  set_has_execution_status();
  if (execution_status_ == &::google::protobuf::internal::kEmptyString) {
    execution_status_ = new ::std::string;
  }
  return execution_status_;
}
inline ::std::string* ExecutionData::release_execution_status() {
  clear_has_execution_status();
  if (execution_status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = execution_status_;
    execution_status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string execution_prc = 13 [default = "0"];
inline bool ExecutionData::has_execution_prc() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ExecutionData::set_has_execution_prc() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ExecutionData::clear_has_execution_prc() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ExecutionData::clear_execution_prc() {
  if (execution_prc_ != &_default_execution_prc_) {
    execution_prc_->assign(_default_execution_prc_);
  }
  clear_has_execution_prc();
}
inline const ::std::string& ExecutionData::execution_prc() const {
  return *execution_prc_;
}
inline void ExecutionData::set_execution_prc(const ::std::string& value) {
  set_has_execution_prc();
  if (execution_prc_ == &_default_execution_prc_) {
    execution_prc_ = new ::std::string;
  }
  execution_prc_->assign(value);
}
inline void ExecutionData::set_execution_prc(const char* value) {
  set_has_execution_prc();
  if (execution_prc_ == &_default_execution_prc_) {
    execution_prc_ = new ::std::string;
  }
  execution_prc_->assign(value);
}
inline void ExecutionData::set_execution_prc(const char* value, size_t size) {
  set_has_execution_prc();
  if (execution_prc_ == &_default_execution_prc_) {
    execution_prc_ = new ::std::string;
  }
  execution_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_execution_prc() {
  set_has_execution_prc();
  if (execution_prc_ == &_default_execution_prc_) {
    execution_prc_ = new ::std::string(_default_execution_prc_);
  }
  return execution_prc_;
}
inline ::std::string* ExecutionData::release_execution_prc() {
  clear_has_execution_prc();
  if (execution_prc_ == &_default_execution_prc_) {
    return NULL;
  } else {
    ::std::string* temp = execution_prc_;
    execution_prc_ = const_cast< ::std::string*>(&_default_execution_prc_);
    return temp;
  }
}

// optional string execution_qty = 14 [default = "0"];
inline bool ExecutionData::has_execution_qty() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ExecutionData::set_has_execution_qty() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ExecutionData::clear_has_execution_qty() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ExecutionData::clear_execution_qty() {
  if (execution_qty_ != &_default_execution_qty_) {
    execution_qty_->assign(_default_execution_qty_);
  }
  clear_has_execution_qty();
}
inline const ::std::string& ExecutionData::execution_qty() const {
  return *execution_qty_;
}
inline void ExecutionData::set_execution_qty(const ::std::string& value) {
  set_has_execution_qty();
  if (execution_qty_ == &_default_execution_qty_) {
    execution_qty_ = new ::std::string;
  }
  execution_qty_->assign(value);
}
inline void ExecutionData::set_execution_qty(const char* value) {
  set_has_execution_qty();
  if (execution_qty_ == &_default_execution_qty_) {
    execution_qty_ = new ::std::string;
  }
  execution_qty_->assign(value);
}
inline void ExecutionData::set_execution_qty(const char* value, size_t size) {
  set_has_execution_qty();
  if (execution_qty_ == &_default_execution_qty_) {
    execution_qty_ = new ::std::string;
  }
  execution_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_execution_qty() {
  set_has_execution_qty();
  if (execution_qty_ == &_default_execution_qty_) {
    execution_qty_ = new ::std::string(_default_execution_qty_);
  }
  return execution_qty_;
}
inline ::std::string* ExecutionData::release_execution_qty() {
  clear_has_execution_qty();
  if (execution_qty_ == &_default_execution_qty_) {
    return NULL;
  } else {
    ::std::string* temp = execution_qty_;
    execution_qty_ = const_cast< ::std::string*>(&_default_execution_qty_);
    return temp;
  }
}

// optional string execution_val = 15 [default = "0"];
inline bool ExecutionData::has_execution_val() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ExecutionData::set_has_execution_val() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ExecutionData::clear_has_execution_val() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ExecutionData::clear_execution_val() {
  if (execution_val_ != &_default_execution_val_) {
    execution_val_->assign(_default_execution_val_);
  }
  clear_has_execution_val();
}
inline const ::std::string& ExecutionData::execution_val() const {
  return *execution_val_;
}
inline void ExecutionData::set_execution_val(const ::std::string& value) {
  set_has_execution_val();
  if (execution_val_ == &_default_execution_val_) {
    execution_val_ = new ::std::string;
  }
  execution_val_->assign(value);
}
inline void ExecutionData::set_execution_val(const char* value) {
  set_has_execution_val();
  if (execution_val_ == &_default_execution_val_) {
    execution_val_ = new ::std::string;
  }
  execution_val_->assign(value);
}
inline void ExecutionData::set_execution_val(const char* value, size_t size) {
  set_has_execution_val();
  if (execution_val_ == &_default_execution_val_) {
    execution_val_ = new ::std::string;
  }
  execution_val_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_execution_val() {
  set_has_execution_val();
  if (execution_val_ == &_default_execution_val_) {
    execution_val_ = new ::std::string(_default_execution_val_);
  }
  return execution_val_;
}
inline ::std::string* ExecutionData::release_execution_val() {
  clear_has_execution_val();
  if (execution_val_ == &_default_execution_val_) {
    return NULL;
  } else {
    ::std::string* temp = execution_val_;
    execution_val_ = const_cast< ::std::string*>(&_default_execution_val_);
    return temp;
  }
}

// optional string leaves_qty = 16 [default = "0"];
inline bool ExecutionData::has_leaves_qty() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ExecutionData::set_has_leaves_qty() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ExecutionData::clear_has_leaves_qty() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ExecutionData::clear_leaves_qty() {
  if (leaves_qty_ != &_default_leaves_qty_) {
    leaves_qty_->assign(_default_leaves_qty_);
  }
  clear_has_leaves_qty();
}
inline const ::std::string& ExecutionData::leaves_qty() const {
  return *leaves_qty_;
}
inline void ExecutionData::set_leaves_qty(const ::std::string& value) {
  set_has_leaves_qty();
  if (leaves_qty_ == &_default_leaves_qty_) {
    leaves_qty_ = new ::std::string;
  }
  leaves_qty_->assign(value);
}
inline void ExecutionData::set_leaves_qty(const char* value) {
  set_has_leaves_qty();
  if (leaves_qty_ == &_default_leaves_qty_) {
    leaves_qty_ = new ::std::string;
  }
  leaves_qty_->assign(value);
}
inline void ExecutionData::set_leaves_qty(const char* value, size_t size) {
  set_has_leaves_qty();
  if (leaves_qty_ == &_default_leaves_qty_) {
    leaves_qty_ = new ::std::string;
  }
  leaves_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_leaves_qty() {
  set_has_leaves_qty();
  if (leaves_qty_ == &_default_leaves_qty_) {
    leaves_qty_ = new ::std::string(_default_leaves_qty_);
  }
  return leaves_qty_;
}
inline ::std::string* ExecutionData::release_leaves_qty() {
  clear_has_leaves_qty();
  if (leaves_qty_ == &_default_leaves_qty_) {
    return NULL;
  } else {
    ::std::string* temp = leaves_qty_;
    leaves_qty_ = const_cast< ::std::string*>(&_default_leaves_qty_);
    return temp;
  }
}

// optional string average_prc = 17 [default = "0"];
inline bool ExecutionData::has_average_prc() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ExecutionData::set_has_average_prc() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ExecutionData::clear_has_average_prc() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ExecutionData::clear_average_prc() {
  if (average_prc_ != &_default_average_prc_) {
    average_prc_->assign(_default_average_prc_);
  }
  clear_has_average_prc();
}
inline const ::std::string& ExecutionData::average_prc() const {
  return *average_prc_;
}
inline void ExecutionData::set_average_prc(const ::std::string& value) {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string;
  }
  average_prc_->assign(value);
}
inline void ExecutionData::set_average_prc(const char* value) {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string;
  }
  average_prc_->assign(value);
}
inline void ExecutionData::set_average_prc(const char* value, size_t size) {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string;
  }
  average_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_average_prc() {
  set_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    average_prc_ = new ::std::string(_default_average_prc_);
  }
  return average_prc_;
}
inline ::std::string* ExecutionData::release_average_prc() {
  clear_has_average_prc();
  if (average_prc_ == &_default_average_prc_) {
    return NULL;
  } else {
    ::std::string* temp = average_prc_;
    average_prc_ = const_cast< ::std::string*>(&_default_average_prc_);
    return temp;
  }
}

// optional string leg_type = 18 [default = "1"];
inline bool ExecutionData::has_leg_type() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ExecutionData::set_has_leg_type() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ExecutionData::clear_has_leg_type() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ExecutionData::clear_leg_type() {
  if (leg_type_ != &_default_leg_type_) {
    leg_type_->assign(_default_leg_type_);
  }
  clear_has_leg_type();
}
inline const ::std::string& ExecutionData::leg_type() const {
  return *leg_type_;
}
inline void ExecutionData::set_leg_type(const ::std::string& value) {
  set_has_leg_type();
  if (leg_type_ == &_default_leg_type_) {
    leg_type_ = new ::std::string;
  }
  leg_type_->assign(value);
}
inline void ExecutionData::set_leg_type(const char* value) {
  set_has_leg_type();
  if (leg_type_ == &_default_leg_type_) {
    leg_type_ = new ::std::string;
  }
  leg_type_->assign(value);
}
inline void ExecutionData::set_leg_type(const char* value, size_t size) {
  set_has_leg_type();
  if (leg_type_ == &_default_leg_type_) {
    leg_type_ = new ::std::string;
  }
  leg_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_leg_type() {
  set_has_leg_type();
  if (leg_type_ == &_default_leg_type_) {
    leg_type_ = new ::std::string(_default_leg_type_);
  }
  return leg_type_;
}
inline ::std::string* ExecutionData::release_leg_type() {
  clear_has_leg_type();
  if (leg_type_ == &_default_leg_type_) {
    return NULL;
  } else {
    ::std::string* temp = leg_type_;
    leg_type_ = const_cast< ::std::string*>(&_default_leg_type_);
    return temp;
  }
}

// optional string added_datetime = 19;
inline bool ExecutionData::has_added_datetime() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ExecutionData::set_has_added_datetime() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ExecutionData::clear_has_added_datetime() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ExecutionData::clear_added_datetime() {
  if (added_datetime_ != &::google::protobuf::internal::kEmptyString) {
    added_datetime_->clear();
  }
  clear_has_added_datetime();
}
inline const ::std::string& ExecutionData::added_datetime() const {
  return *added_datetime_;
}
inline void ExecutionData::set_added_datetime(const ::std::string& value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void ExecutionData::set_added_datetime(const char* value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void ExecutionData::set_added_datetime(const char* value, size_t size) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_added_datetime() {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  return added_datetime_;
}
inline ::std::string* ExecutionData::release_added_datetime() {
  clear_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_datetime_;
    added_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string added_by = 20;
inline bool ExecutionData::has_added_by() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ExecutionData::set_has_added_by() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ExecutionData::clear_has_added_by() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ExecutionData::clear_added_by() {
  if (added_by_ != &::google::protobuf::internal::kEmptyString) {
    added_by_->clear();
  }
  clear_has_added_by();
}
inline const ::std::string& ExecutionData::added_by() const {
  return *added_by_;
}
inline void ExecutionData::set_added_by(const ::std::string& value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void ExecutionData::set_added_by(const char* value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void ExecutionData::set_added_by(const char* value, size_t size) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_added_by() {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  return added_by_;
}
inline ::std::string* ExecutionData::release_added_by() {
  clear_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_by_;
    added_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_datetime = 21;
inline bool ExecutionData::has_updated_datetime() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ExecutionData::set_has_updated_datetime() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ExecutionData::clear_has_updated_datetime() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ExecutionData::clear_updated_datetime() {
  if (updated_datetime_ != &::google::protobuf::internal::kEmptyString) {
    updated_datetime_->clear();
  }
  clear_has_updated_datetime();
}
inline const ::std::string& ExecutionData::updated_datetime() const {
  return *updated_datetime_;
}
inline void ExecutionData::set_updated_datetime(const ::std::string& value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void ExecutionData::set_updated_datetime(const char* value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void ExecutionData::set_updated_datetime(const char* value, size_t size) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_updated_datetime() {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  return updated_datetime_;
}
inline ::std::string* ExecutionData::release_updated_datetime() {
  clear_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_datetime_;
    updated_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_by = 22;
inline bool ExecutionData::has_updated_by() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ExecutionData::set_has_updated_by() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ExecutionData::clear_has_updated_by() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ExecutionData::clear_updated_by() {
  if (updated_by_ != &::google::protobuf::internal::kEmptyString) {
    updated_by_->clear();
  }
  clear_has_updated_by();
}
inline const ::std::string& ExecutionData::updated_by() const {
  return *updated_by_;
}
inline void ExecutionData::set_updated_by(const ::std::string& value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void ExecutionData::set_updated_by(const char* value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void ExecutionData::set_updated_by(const char* value, size_t size) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionData::mutable_updated_by() {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  return updated_by_;
}
inline ::std::string* ExecutionData::release_updated_by() {
  clear_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_by_;
    updated_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// InstrumentData

// optional string instrument_id = 1;
inline bool InstrumentData::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstrumentData::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstrumentData::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstrumentData::clear_instrument_id() {
  if (instrument_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_id_->clear();
  }
  clear_has_instrument_id();
}
inline const ::std::string& InstrumentData::instrument_id() const {
  return *instrument_id_;
}
inline void InstrumentData::set_instrument_id(const ::std::string& value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void InstrumentData::set_instrument_id(const char* value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void InstrumentData::set_instrument_id(const char* value, size_t size) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_instrument_id() {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  return instrument_id_;
}
inline ::std::string* InstrumentData::release_instrument_id() {
  clear_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_id_;
    instrument_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string instrument_type = 2;
inline bool InstrumentData::has_instrument_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstrumentData::set_has_instrument_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstrumentData::clear_has_instrument_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstrumentData::clear_instrument_type() {
  if (instrument_type_ != &::google::protobuf::internal::kEmptyString) {
    instrument_type_->clear();
  }
  clear_has_instrument_type();
}
inline const ::std::string& InstrumentData::instrument_type() const {
  return *instrument_type_;
}
inline void InstrumentData::set_instrument_type(const ::std::string& value) {
  set_has_instrument_type();
  if (instrument_type_ == &::google::protobuf::internal::kEmptyString) {
    instrument_type_ = new ::std::string;
  }
  instrument_type_->assign(value);
}
inline void InstrumentData::set_instrument_type(const char* value) {
  set_has_instrument_type();
  if (instrument_type_ == &::google::protobuf::internal::kEmptyString) {
    instrument_type_ = new ::std::string;
  }
  instrument_type_->assign(value);
}
inline void InstrumentData::set_instrument_type(const char* value, size_t size) {
  set_has_instrument_type();
  if (instrument_type_ == &::google::protobuf::internal::kEmptyString) {
    instrument_type_ = new ::std::string;
  }
  instrument_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_instrument_type() {
  set_has_instrument_type();
  if (instrument_type_ == &::google::protobuf::internal::kEmptyString) {
    instrument_type_ = new ::std::string;
  }
  return instrument_type_;
}
inline ::std::string* InstrumentData::release_instrument_type() {
  clear_has_instrument_type();
  if (instrument_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_type_;
    instrument_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string name = 3;
inline bool InstrumentData::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstrumentData::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstrumentData::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstrumentData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InstrumentData::name() const {
  return *name_;
}
inline void InstrumentData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InstrumentData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InstrumentData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* InstrumentData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string symbol = 4;
inline bool InstrumentData::has_symbol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstrumentData::set_has_symbol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstrumentData::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstrumentData::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& InstrumentData::symbol() const {
  return *symbol_;
}
inline void InstrumentData::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void InstrumentData::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void InstrumentData::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* InstrumentData::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string cusip = 5;
inline bool InstrumentData::has_cusip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstrumentData::set_has_cusip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstrumentData::clear_has_cusip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstrumentData::clear_cusip() {
  if (cusip_ != &::google::protobuf::internal::kEmptyString) {
    cusip_->clear();
  }
  clear_has_cusip();
}
inline const ::std::string& InstrumentData::cusip() const {
  return *cusip_;
}
inline void InstrumentData::set_cusip(const ::std::string& value) {
  set_has_cusip();
  if (cusip_ == &::google::protobuf::internal::kEmptyString) {
    cusip_ = new ::std::string;
  }
  cusip_->assign(value);
}
inline void InstrumentData::set_cusip(const char* value) {
  set_has_cusip();
  if (cusip_ == &::google::protobuf::internal::kEmptyString) {
    cusip_ = new ::std::string;
  }
  cusip_->assign(value);
}
inline void InstrumentData::set_cusip(const char* value, size_t size) {
  set_has_cusip();
  if (cusip_ == &::google::protobuf::internal::kEmptyString) {
    cusip_ = new ::std::string;
  }
  cusip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_cusip() {
  set_has_cusip();
  if (cusip_ == &::google::protobuf::internal::kEmptyString) {
    cusip_ = new ::std::string;
  }
  return cusip_;
}
inline ::std::string* InstrumentData::release_cusip() {
  clear_has_cusip();
  if (cusip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cusip_;
    cusip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sedol = 6;
inline bool InstrumentData::has_sedol() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InstrumentData::set_has_sedol() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InstrumentData::clear_has_sedol() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InstrumentData::clear_sedol() {
  if (sedol_ != &::google::protobuf::internal::kEmptyString) {
    sedol_->clear();
  }
  clear_has_sedol();
}
inline const ::std::string& InstrumentData::sedol() const {
  return *sedol_;
}
inline void InstrumentData::set_sedol(const ::std::string& value) {
  set_has_sedol();
  if (sedol_ == &::google::protobuf::internal::kEmptyString) {
    sedol_ = new ::std::string;
  }
  sedol_->assign(value);
}
inline void InstrumentData::set_sedol(const char* value) {
  set_has_sedol();
  if (sedol_ == &::google::protobuf::internal::kEmptyString) {
    sedol_ = new ::std::string;
  }
  sedol_->assign(value);
}
inline void InstrumentData::set_sedol(const char* value, size_t size) {
  set_has_sedol();
  if (sedol_ == &::google::protobuf::internal::kEmptyString) {
    sedol_ = new ::std::string;
  }
  sedol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_sedol() {
  set_has_sedol();
  if (sedol_ == &::google::protobuf::internal::kEmptyString) {
    sedol_ = new ::std::string;
  }
  return sedol_;
}
inline ::std::string* InstrumentData::release_sedol() {
  clear_has_sedol();
  if (sedol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sedol_;
    sedol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string isin = 7;
inline bool InstrumentData::has_isin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InstrumentData::set_has_isin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InstrumentData::clear_has_isin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InstrumentData::clear_isin() {
  if (isin_ != &::google::protobuf::internal::kEmptyString) {
    isin_->clear();
  }
  clear_has_isin();
}
inline const ::std::string& InstrumentData::isin() const {
  return *isin_;
}
inline void InstrumentData::set_isin(const ::std::string& value) {
  set_has_isin();
  if (isin_ == &::google::protobuf::internal::kEmptyString) {
    isin_ = new ::std::string;
  }
  isin_->assign(value);
}
inline void InstrumentData::set_isin(const char* value) {
  set_has_isin();
  if (isin_ == &::google::protobuf::internal::kEmptyString) {
    isin_ = new ::std::string;
  }
  isin_->assign(value);
}
inline void InstrumentData::set_isin(const char* value, size_t size) {
  set_has_isin();
  if (isin_ == &::google::protobuf::internal::kEmptyString) {
    isin_ = new ::std::string;
  }
  isin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_isin() {
  set_has_isin();
  if (isin_ == &::google::protobuf::internal::kEmptyString) {
    isin_ = new ::std::string;
  }
  return isin_;
}
inline ::std::string* InstrumentData::release_isin() {
  clear_has_isin();
  if (isin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = isin_;
    isin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ric = 8;
inline bool InstrumentData::has_ric() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InstrumentData::set_has_ric() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InstrumentData::clear_has_ric() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InstrumentData::clear_ric() {
  if (ric_ != &::google::protobuf::internal::kEmptyString) {
    ric_->clear();
  }
  clear_has_ric();
}
inline const ::std::string& InstrumentData::ric() const {
  return *ric_;
}
inline void InstrumentData::set_ric(const ::std::string& value) {
  set_has_ric();
  if (ric_ == &::google::protobuf::internal::kEmptyString) {
    ric_ = new ::std::string;
  }
  ric_->assign(value);
}
inline void InstrumentData::set_ric(const char* value) {
  set_has_ric();
  if (ric_ == &::google::protobuf::internal::kEmptyString) {
    ric_ = new ::std::string;
  }
  ric_->assign(value);
}
inline void InstrumentData::set_ric(const char* value, size_t size) {
  set_has_ric();
  if (ric_ == &::google::protobuf::internal::kEmptyString) {
    ric_ = new ::std::string;
  }
  ric_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_ric() {
  set_has_ric();
  if (ric_ == &::google::protobuf::internal::kEmptyString) {
    ric_ = new ::std::string;
  }
  return ric_;
}
inline ::std::string* InstrumentData::release_ric() {
  clear_has_ric();
  if (ric_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ric_;
    ric_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string cfi_code = 9;
inline bool InstrumentData::has_cfi_code() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InstrumentData::set_has_cfi_code() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InstrumentData::clear_has_cfi_code() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InstrumentData::clear_cfi_code() {
  if (cfi_code_ != &::google::protobuf::internal::kEmptyString) {
    cfi_code_->clear();
  }
  clear_has_cfi_code();
}
inline const ::std::string& InstrumentData::cfi_code() const {
  return *cfi_code_;
}
inline void InstrumentData::set_cfi_code(const ::std::string& value) {
  set_has_cfi_code();
  if (cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    cfi_code_ = new ::std::string;
  }
  cfi_code_->assign(value);
}
inline void InstrumentData::set_cfi_code(const char* value) {
  set_has_cfi_code();
  if (cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    cfi_code_ = new ::std::string;
  }
  cfi_code_->assign(value);
}
inline void InstrumentData::set_cfi_code(const char* value, size_t size) {
  set_has_cfi_code();
  if (cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    cfi_code_ = new ::std::string;
  }
  cfi_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_cfi_code() {
  set_has_cfi_code();
  if (cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    cfi_code_ = new ::std::string;
  }
  return cfi_code_;
}
inline ::std::string* InstrumentData::release_cfi_code() {
  clear_has_cfi_code();
  if (cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cfi_code_;
    cfi_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string security_id = 10;
inline bool InstrumentData::has_security_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InstrumentData::set_has_security_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InstrumentData::clear_has_security_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InstrumentData::clear_security_id() {
  if (security_id_ != &::google::protobuf::internal::kEmptyString) {
    security_id_->clear();
  }
  clear_has_security_id();
}
inline const ::std::string& InstrumentData::security_id() const {
  return *security_id_;
}
inline void InstrumentData::set_security_id(const ::std::string& value) {
  set_has_security_id();
  if (security_id_ == &::google::protobuf::internal::kEmptyString) {
    security_id_ = new ::std::string;
  }
  security_id_->assign(value);
}
inline void InstrumentData::set_security_id(const char* value) {
  set_has_security_id();
  if (security_id_ == &::google::protobuf::internal::kEmptyString) {
    security_id_ = new ::std::string;
  }
  security_id_->assign(value);
}
inline void InstrumentData::set_security_id(const char* value, size_t size) {
  set_has_security_id();
  if (security_id_ == &::google::protobuf::internal::kEmptyString) {
    security_id_ = new ::std::string;
  }
  security_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_security_id() {
  set_has_security_id();
  if (security_id_ == &::google::protobuf::internal::kEmptyString) {
    security_id_ = new ::std::string;
  }
  return security_id_;
}
inline ::std::string* InstrumentData::release_security_id() {
  clear_has_security_id();
  if (security_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_id_;
    security_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string security_type = 11;
inline bool InstrumentData::has_security_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InstrumentData::set_has_security_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InstrumentData::clear_has_security_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InstrumentData::clear_security_type() {
  if (security_type_ != &::google::protobuf::internal::kEmptyString) {
    security_type_->clear();
  }
  clear_has_security_type();
}
inline const ::std::string& InstrumentData::security_type() const {
  return *security_type_;
}
inline void InstrumentData::set_security_type(const ::std::string& value) {
  set_has_security_type();
  if (security_type_ == &::google::protobuf::internal::kEmptyString) {
    security_type_ = new ::std::string;
  }
  security_type_->assign(value);
}
inline void InstrumentData::set_security_type(const char* value) {
  set_has_security_type();
  if (security_type_ == &::google::protobuf::internal::kEmptyString) {
    security_type_ = new ::std::string;
  }
  security_type_->assign(value);
}
inline void InstrumentData::set_security_type(const char* value, size_t size) {
  set_has_security_type();
  if (security_type_ == &::google::protobuf::internal::kEmptyString) {
    security_type_ = new ::std::string;
  }
  security_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_security_type() {
  set_has_security_type();
  if (security_type_ == &::google::protobuf::internal::kEmptyString) {
    security_type_ = new ::std::string;
  }
  return security_type_;
}
inline ::std::string* InstrumentData::release_security_type() {
  clear_has_security_type();
  if (security_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_type_;
    security_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string security_desc = 12;
inline bool InstrumentData::has_security_desc() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InstrumentData::set_has_security_desc() {
  _has_bits_[0] |= 0x00000800u;
}
inline void InstrumentData::clear_has_security_desc() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void InstrumentData::clear_security_desc() {
  if (security_desc_ != &::google::protobuf::internal::kEmptyString) {
    security_desc_->clear();
  }
  clear_has_security_desc();
}
inline const ::std::string& InstrumentData::security_desc() const {
  return *security_desc_;
}
inline void InstrumentData::set_security_desc(const ::std::string& value) {
  set_has_security_desc();
  if (security_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_desc_ = new ::std::string;
  }
  security_desc_->assign(value);
}
inline void InstrumentData::set_security_desc(const char* value) {
  set_has_security_desc();
  if (security_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_desc_ = new ::std::string;
  }
  security_desc_->assign(value);
}
inline void InstrumentData::set_security_desc(const char* value, size_t size) {
  set_has_security_desc();
  if (security_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_desc_ = new ::std::string;
  }
  security_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_security_desc() {
  set_has_security_desc();
  if (security_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_desc_ = new ::std::string;
  }
  return security_desc_;
}
inline ::std::string* InstrumentData::release_security_desc() {
  clear_has_security_desc();
  if (security_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_desc_;
    security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string security_exchange = 13;
inline bool InstrumentData::has_security_exchange() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InstrumentData::set_has_security_exchange() {
  _has_bits_[0] |= 0x00001000u;
}
inline void InstrumentData::clear_has_security_exchange() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void InstrumentData::clear_security_exchange() {
  if (security_exchange_ != &::google::protobuf::internal::kEmptyString) {
    security_exchange_->clear();
  }
  clear_has_security_exchange();
}
inline const ::std::string& InstrumentData::security_exchange() const {
  return *security_exchange_;
}
inline void InstrumentData::set_security_exchange(const ::std::string& value) {
  set_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    security_exchange_ = new ::std::string;
  }
  security_exchange_->assign(value);
}
inline void InstrumentData::set_security_exchange(const char* value) {
  set_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    security_exchange_ = new ::std::string;
  }
  security_exchange_->assign(value);
}
inline void InstrumentData::set_security_exchange(const char* value, size_t size) {
  set_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    security_exchange_ = new ::std::string;
  }
  security_exchange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_security_exchange() {
  set_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    security_exchange_ = new ::std::string;
  }
  return security_exchange_;
}
inline ::std::string* InstrumentData::release_security_exchange() {
  clear_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_exchange_;
    security_exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string maturity_month_year = 14;
inline bool InstrumentData::has_maturity_month_year() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InstrumentData::set_has_maturity_month_year() {
  _has_bits_[0] |= 0x00002000u;
}
inline void InstrumentData::clear_has_maturity_month_year() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void InstrumentData::clear_maturity_month_year() {
  if (maturity_month_year_ != &::google::protobuf::internal::kEmptyString) {
    maturity_month_year_->clear();
  }
  clear_has_maturity_month_year();
}
inline const ::std::string& InstrumentData::maturity_month_year() const {
  return *maturity_month_year_;
}
inline void InstrumentData::set_maturity_month_year(const ::std::string& value) {
  set_has_maturity_month_year();
  if (maturity_month_year_ == &::google::protobuf::internal::kEmptyString) {
    maturity_month_year_ = new ::std::string;
  }
  maturity_month_year_->assign(value);
}
inline void InstrumentData::set_maturity_month_year(const char* value) {
  set_has_maturity_month_year();
  if (maturity_month_year_ == &::google::protobuf::internal::kEmptyString) {
    maturity_month_year_ = new ::std::string;
  }
  maturity_month_year_->assign(value);
}
inline void InstrumentData::set_maturity_month_year(const char* value, size_t size) {
  set_has_maturity_month_year();
  if (maturity_month_year_ == &::google::protobuf::internal::kEmptyString) {
    maturity_month_year_ = new ::std::string;
  }
  maturity_month_year_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_maturity_month_year() {
  set_has_maturity_month_year();
  if (maturity_month_year_ == &::google::protobuf::internal::kEmptyString) {
    maturity_month_year_ = new ::std::string;
  }
  return maturity_month_year_;
}
inline ::std::string* InstrumentData::release_maturity_month_year() {
  clear_has_maturity_month_year();
  if (maturity_month_year_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = maturity_month_year_;
    maturity_month_year_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string base_ccy = 15;
inline bool InstrumentData::has_base_ccy() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void InstrumentData::set_has_base_ccy() {
  _has_bits_[0] |= 0x00004000u;
}
inline void InstrumentData::clear_has_base_ccy() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void InstrumentData::clear_base_ccy() {
  if (base_ccy_ != &::google::protobuf::internal::kEmptyString) {
    base_ccy_->clear();
  }
  clear_has_base_ccy();
}
inline const ::std::string& InstrumentData::base_ccy() const {
  return *base_ccy_;
}
inline void InstrumentData::set_base_ccy(const ::std::string& value) {
  set_has_base_ccy();
  if (base_ccy_ == &::google::protobuf::internal::kEmptyString) {
    base_ccy_ = new ::std::string;
  }
  base_ccy_->assign(value);
}
inline void InstrumentData::set_base_ccy(const char* value) {
  set_has_base_ccy();
  if (base_ccy_ == &::google::protobuf::internal::kEmptyString) {
    base_ccy_ = new ::std::string;
  }
  base_ccy_->assign(value);
}
inline void InstrumentData::set_base_ccy(const char* value, size_t size) {
  set_has_base_ccy();
  if (base_ccy_ == &::google::protobuf::internal::kEmptyString) {
    base_ccy_ = new ::std::string;
  }
  base_ccy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_base_ccy() {
  set_has_base_ccy();
  if (base_ccy_ == &::google::protobuf::internal::kEmptyString) {
    base_ccy_ = new ::std::string;
  }
  return base_ccy_;
}
inline ::std::string* InstrumentData::release_base_ccy() {
  clear_has_base_ccy();
  if (base_ccy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = base_ccy_;
    base_ccy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string last_prc = 16 [default = "0"];
inline bool InstrumentData::has_last_prc() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void InstrumentData::set_has_last_prc() {
  _has_bits_[0] |= 0x00008000u;
}
inline void InstrumentData::clear_has_last_prc() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void InstrumentData::clear_last_prc() {
  if (last_prc_ != &_default_last_prc_) {
    last_prc_->assign(_default_last_prc_);
  }
  clear_has_last_prc();
}
inline const ::std::string& InstrumentData::last_prc() const {
  return *last_prc_;
}
inline void InstrumentData::set_last_prc(const ::std::string& value) {
  set_has_last_prc();
  if (last_prc_ == &_default_last_prc_) {
    last_prc_ = new ::std::string;
  }
  last_prc_->assign(value);
}
inline void InstrumentData::set_last_prc(const char* value) {
  set_has_last_prc();
  if (last_prc_ == &_default_last_prc_) {
    last_prc_ = new ::std::string;
  }
  last_prc_->assign(value);
}
inline void InstrumentData::set_last_prc(const char* value, size_t size) {
  set_has_last_prc();
  if (last_prc_ == &_default_last_prc_) {
    last_prc_ = new ::std::string;
  }
  last_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_last_prc() {
  set_has_last_prc();
  if (last_prc_ == &_default_last_prc_) {
    last_prc_ = new ::std::string(_default_last_prc_);
  }
  return last_prc_;
}
inline ::std::string* InstrumentData::release_last_prc() {
  clear_has_last_prc();
  if (last_prc_ == &_default_last_prc_) {
    return NULL;
  } else {
    ::std::string* temp = last_prc_;
    last_prc_ = const_cast< ::std::string*>(&_default_last_prc_);
    return temp;
  }
}

// optional string mark_prc = 17 [default = "0"];
inline bool InstrumentData::has_mark_prc() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void InstrumentData::set_has_mark_prc() {
  _has_bits_[0] |= 0x00010000u;
}
inline void InstrumentData::clear_has_mark_prc() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void InstrumentData::clear_mark_prc() {
  if (mark_prc_ != &_default_mark_prc_) {
    mark_prc_->assign(_default_mark_prc_);
  }
  clear_has_mark_prc();
}
inline const ::std::string& InstrumentData::mark_prc() const {
  return *mark_prc_;
}
inline void InstrumentData::set_mark_prc(const ::std::string& value) {
  set_has_mark_prc();
  if (mark_prc_ == &_default_mark_prc_) {
    mark_prc_ = new ::std::string;
  }
  mark_prc_->assign(value);
}
inline void InstrumentData::set_mark_prc(const char* value) {
  set_has_mark_prc();
  if (mark_prc_ == &_default_mark_prc_) {
    mark_prc_ = new ::std::string;
  }
  mark_prc_->assign(value);
}
inline void InstrumentData::set_mark_prc(const char* value, size_t size) {
  set_has_mark_prc();
  if (mark_prc_ == &_default_mark_prc_) {
    mark_prc_ = new ::std::string;
  }
  mark_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_mark_prc() {
  set_has_mark_prc();
  if (mark_prc_ == &_default_mark_prc_) {
    mark_prc_ = new ::std::string(_default_mark_prc_);
  }
  return mark_prc_;
}
inline ::std::string* InstrumentData::release_mark_prc() {
  clear_has_mark_prc();
  if (mark_prc_ == &_default_mark_prc_) {
    return NULL;
  } else {
    ::std::string* temp = mark_prc_;
    mark_prc_ = const_cast< ::std::string*>(&_default_mark_prc_);
    return temp;
  }
}

// optional string mark_datetime = 18;
inline bool InstrumentData::has_mark_datetime() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void InstrumentData::set_has_mark_datetime() {
  _has_bits_[0] |= 0x00020000u;
}
inline void InstrumentData::clear_has_mark_datetime() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void InstrumentData::clear_mark_datetime() {
  if (mark_datetime_ != &::google::protobuf::internal::kEmptyString) {
    mark_datetime_->clear();
  }
  clear_has_mark_datetime();
}
inline const ::std::string& InstrumentData::mark_datetime() const {
  return *mark_datetime_;
}
inline void InstrumentData::set_mark_datetime(const ::std::string& value) {
  set_has_mark_datetime();
  if (mark_datetime_ == &::google::protobuf::internal::kEmptyString) {
    mark_datetime_ = new ::std::string;
  }
  mark_datetime_->assign(value);
}
inline void InstrumentData::set_mark_datetime(const char* value) {
  set_has_mark_datetime();
  if (mark_datetime_ == &::google::protobuf::internal::kEmptyString) {
    mark_datetime_ = new ::std::string;
  }
  mark_datetime_->assign(value);
}
inline void InstrumentData::set_mark_datetime(const char* value, size_t size) {
  set_has_mark_datetime();
  if (mark_datetime_ == &::google::protobuf::internal::kEmptyString) {
    mark_datetime_ = new ::std::string;
  }
  mark_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_mark_datetime() {
  set_has_mark_datetime();
  if (mark_datetime_ == &::google::protobuf::internal::kEmptyString) {
    mark_datetime_ = new ::std::string;
  }
  return mark_datetime_;
}
inline ::std::string* InstrumentData::release_mark_datetime() {
  clear_has_mark_datetime();
  if (mark_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mark_datetime_;
    mark_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string multiplier = 19;
inline bool InstrumentData::has_multiplier() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void InstrumentData::set_has_multiplier() {
  _has_bits_[0] |= 0x00040000u;
}
inline void InstrumentData::clear_has_multiplier() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void InstrumentData::clear_multiplier() {
  if (multiplier_ != &::google::protobuf::internal::kEmptyString) {
    multiplier_->clear();
  }
  clear_has_multiplier();
}
inline const ::std::string& InstrumentData::multiplier() const {
  return *multiplier_;
}
inline void InstrumentData::set_multiplier(const ::std::string& value) {
  set_has_multiplier();
  if (multiplier_ == &::google::protobuf::internal::kEmptyString) {
    multiplier_ = new ::std::string;
  }
  multiplier_->assign(value);
}
inline void InstrumentData::set_multiplier(const char* value) {
  set_has_multiplier();
  if (multiplier_ == &::google::protobuf::internal::kEmptyString) {
    multiplier_ = new ::std::string;
  }
  multiplier_->assign(value);
}
inline void InstrumentData::set_multiplier(const char* value, size_t size) {
  set_has_multiplier();
  if (multiplier_ == &::google::protobuf::internal::kEmptyString) {
    multiplier_ = new ::std::string;
  }
  multiplier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_multiplier() {
  set_has_multiplier();
  if (multiplier_ == &::google::protobuf::internal::kEmptyString) {
    multiplier_ = new ::std::string;
  }
  return multiplier_;
}
inline ::std::string* InstrumentData::release_multiplier() {
  clear_has_multiplier();
  if (multiplier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = multiplier_;
    multiplier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string exchange_price_factor = 20;
inline bool InstrumentData::has_exchange_price_factor() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void InstrumentData::set_has_exchange_price_factor() {
  _has_bits_[0] |= 0x00080000u;
}
inline void InstrumentData::clear_has_exchange_price_factor() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void InstrumentData::clear_exchange_price_factor() {
  if (exchange_price_factor_ != &::google::protobuf::internal::kEmptyString) {
    exchange_price_factor_->clear();
  }
  clear_has_exchange_price_factor();
}
inline const ::std::string& InstrumentData::exchange_price_factor() const {
  return *exchange_price_factor_;
}
inline void InstrumentData::set_exchange_price_factor(const ::std::string& value) {
  set_has_exchange_price_factor();
  if (exchange_price_factor_ == &::google::protobuf::internal::kEmptyString) {
    exchange_price_factor_ = new ::std::string;
  }
  exchange_price_factor_->assign(value);
}
inline void InstrumentData::set_exchange_price_factor(const char* value) {
  set_has_exchange_price_factor();
  if (exchange_price_factor_ == &::google::protobuf::internal::kEmptyString) {
    exchange_price_factor_ = new ::std::string;
  }
  exchange_price_factor_->assign(value);
}
inline void InstrumentData::set_exchange_price_factor(const char* value, size_t size) {
  set_has_exchange_price_factor();
  if (exchange_price_factor_ == &::google::protobuf::internal::kEmptyString) {
    exchange_price_factor_ = new ::std::string;
  }
  exchange_price_factor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_exchange_price_factor() {
  set_has_exchange_price_factor();
  if (exchange_price_factor_ == &::google::protobuf::internal::kEmptyString) {
    exchange_price_factor_ = new ::std::string;
  }
  return exchange_price_factor_;
}
inline ::std::string* InstrumentData::release_exchange_price_factor() {
  clear_has_exchange_price_factor();
  if (exchange_price_factor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exchange_price_factor_;
    exchange_price_factor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string rollover_datetime = 21;
inline bool InstrumentData::has_rollover_datetime() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void InstrumentData::set_has_rollover_datetime() {
  _has_bits_[0] |= 0x00100000u;
}
inline void InstrumentData::clear_has_rollover_datetime() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void InstrumentData::clear_rollover_datetime() {
  if (rollover_datetime_ != &::google::protobuf::internal::kEmptyString) {
    rollover_datetime_->clear();
  }
  clear_has_rollover_datetime();
}
inline const ::std::string& InstrumentData::rollover_datetime() const {
  return *rollover_datetime_;
}
inline void InstrumentData::set_rollover_datetime(const ::std::string& value) {
  set_has_rollover_datetime();
  if (rollover_datetime_ == &::google::protobuf::internal::kEmptyString) {
    rollover_datetime_ = new ::std::string;
  }
  rollover_datetime_->assign(value);
}
inline void InstrumentData::set_rollover_datetime(const char* value) {
  set_has_rollover_datetime();
  if (rollover_datetime_ == &::google::protobuf::internal::kEmptyString) {
    rollover_datetime_ = new ::std::string;
  }
  rollover_datetime_->assign(value);
}
inline void InstrumentData::set_rollover_datetime(const char* value, size_t size) {
  set_has_rollover_datetime();
  if (rollover_datetime_ == &::google::protobuf::internal::kEmptyString) {
    rollover_datetime_ = new ::std::string;
  }
  rollover_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_rollover_datetime() {
  set_has_rollover_datetime();
  if (rollover_datetime_ == &::google::protobuf::internal::kEmptyString) {
    rollover_datetime_ = new ::std::string;
  }
  return rollover_datetime_;
}
inline ::std::string* InstrumentData::release_rollover_datetime() {
  clear_has_rollover_datetime();
  if (rollover_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rollover_datetime_;
    rollover_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string is_active = 22;
inline bool InstrumentData::has_is_active() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void InstrumentData::set_has_is_active() {
  _has_bits_[0] |= 0x00200000u;
}
inline void InstrumentData::clear_has_is_active() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void InstrumentData::clear_is_active() {
  if (is_active_ != &::google::protobuf::internal::kEmptyString) {
    is_active_->clear();
  }
  clear_has_is_active();
}
inline const ::std::string& InstrumentData::is_active() const {
  return *is_active_;
}
inline void InstrumentData::set_is_active(const ::std::string& value) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(value);
}
inline void InstrumentData::set_is_active(const char* value) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(value);
}
inline void InstrumentData::set_is_active(const char* value, size_t size) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_is_active() {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  return is_active_;
}
inline ::std::string* InstrumentData::release_is_active() {
  clear_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = is_active_;
    is_active_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string added_datetime = 23;
inline bool InstrumentData::has_added_datetime() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void InstrumentData::set_has_added_datetime() {
  _has_bits_[0] |= 0x00400000u;
}
inline void InstrumentData::clear_has_added_datetime() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void InstrumentData::clear_added_datetime() {
  if (added_datetime_ != &::google::protobuf::internal::kEmptyString) {
    added_datetime_->clear();
  }
  clear_has_added_datetime();
}
inline const ::std::string& InstrumentData::added_datetime() const {
  return *added_datetime_;
}
inline void InstrumentData::set_added_datetime(const ::std::string& value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void InstrumentData::set_added_datetime(const char* value) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(value);
}
inline void InstrumentData::set_added_datetime(const char* value, size_t size) {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  added_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_added_datetime() {
  set_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    added_datetime_ = new ::std::string;
  }
  return added_datetime_;
}
inline ::std::string* InstrumentData::release_added_datetime() {
  clear_has_added_datetime();
  if (added_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_datetime_;
    added_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string added_by = 24;
inline bool InstrumentData::has_added_by() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void InstrumentData::set_has_added_by() {
  _has_bits_[0] |= 0x00800000u;
}
inline void InstrumentData::clear_has_added_by() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void InstrumentData::clear_added_by() {
  if (added_by_ != &::google::protobuf::internal::kEmptyString) {
    added_by_->clear();
  }
  clear_has_added_by();
}
inline const ::std::string& InstrumentData::added_by() const {
  return *added_by_;
}
inline void InstrumentData::set_added_by(const ::std::string& value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void InstrumentData::set_added_by(const char* value) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(value);
}
inline void InstrumentData::set_added_by(const char* value, size_t size) {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  added_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_added_by() {
  set_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    added_by_ = new ::std::string;
  }
  return added_by_;
}
inline ::std::string* InstrumentData::release_added_by() {
  clear_has_added_by();
  if (added_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = added_by_;
    added_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_datetime = 25;
inline bool InstrumentData::has_updated_datetime() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void InstrumentData::set_has_updated_datetime() {
  _has_bits_[0] |= 0x01000000u;
}
inline void InstrumentData::clear_has_updated_datetime() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void InstrumentData::clear_updated_datetime() {
  if (updated_datetime_ != &::google::protobuf::internal::kEmptyString) {
    updated_datetime_->clear();
  }
  clear_has_updated_datetime();
}
inline const ::std::string& InstrumentData::updated_datetime() const {
  return *updated_datetime_;
}
inline void InstrumentData::set_updated_datetime(const ::std::string& value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void InstrumentData::set_updated_datetime(const char* value) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(value);
}
inline void InstrumentData::set_updated_datetime(const char* value, size_t size) {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  updated_datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_updated_datetime() {
  set_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    updated_datetime_ = new ::std::string;
  }
  return updated_datetime_;
}
inline ::std::string* InstrumentData::release_updated_datetime() {
  clear_has_updated_datetime();
  if (updated_datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_datetime_;
    updated_datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string updated_by = 26;
inline bool InstrumentData::has_updated_by() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void InstrumentData::set_has_updated_by() {
  _has_bits_[0] |= 0x02000000u;
}
inline void InstrumentData::clear_has_updated_by() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void InstrumentData::clear_updated_by() {
  if (updated_by_ != &::google::protobuf::internal::kEmptyString) {
    updated_by_->clear();
  }
  clear_has_updated_by();
}
inline const ::std::string& InstrumentData::updated_by() const {
  return *updated_by_;
}
inline void InstrumentData::set_updated_by(const ::std::string& value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void InstrumentData::set_updated_by(const char* value) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(value);
}
inline void InstrumentData::set_updated_by(const char* value, size_t size) {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  updated_by_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentData::mutable_updated_by() {
  set_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    updated_by_ = new ::std::string;
  }
  return updated_by_;
}
inline ::std::string* InstrumentData::release_updated_by() {
  clear_has_updated_by();
  if (updated_by_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updated_by_;
    updated_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SignalData

// optional string external_order_id = 1;
inline bool SignalData::has_external_order_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignalData::set_has_external_order_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignalData::clear_has_external_order_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignalData::clear_external_order_id() {
  if (external_order_id_ != &::google::protobuf::internal::kEmptyString) {
    external_order_id_->clear();
  }
  clear_has_external_order_id();
}
inline const ::std::string& SignalData::external_order_id() const {
  return *external_order_id_;
}
inline void SignalData::set_external_order_id(const ::std::string& value) {
  set_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    external_order_id_ = new ::std::string;
  }
  external_order_id_->assign(value);
}
inline void SignalData::set_external_order_id(const char* value) {
  set_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    external_order_id_ = new ::std::string;
  }
  external_order_id_->assign(value);
}
inline void SignalData::set_external_order_id(const char* value, size_t size) {
  set_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    external_order_id_ = new ::std::string;
  }
  external_order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalData::mutable_external_order_id() {
  set_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    external_order_id_ = new ::std::string;
  }
  return external_order_id_;
}
inline ::std::string* SignalData::release_external_order_id() {
  clear_has_external_order_id();
  if (external_order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = external_order_id_;
    external_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string investment_system_id = 2;
inline bool SignalData::has_investment_system_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignalData::set_has_investment_system_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignalData::clear_has_investment_system_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignalData::clear_investment_system_id() {
  if (investment_system_id_ != &::google::protobuf::internal::kEmptyString) {
    investment_system_id_->clear();
  }
  clear_has_investment_system_id();
}
inline const ::std::string& SignalData::investment_system_id() const {
  return *investment_system_id_;
}
inline void SignalData::set_investment_system_id(const ::std::string& value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void SignalData::set_investment_system_id(const char* value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void SignalData::set_investment_system_id(const char* value, size_t size) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalData::mutable_investment_system_id() {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  return investment_system_id_;
}
inline ::std::string* SignalData::release_investment_system_id() {
  clear_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = investment_system_id_;
    investment_system_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string signal_id = 3;
inline bool SignalData::has_signal_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignalData::set_has_signal_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignalData::clear_has_signal_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignalData::clear_signal_id() {
  if (signal_id_ != &::google::protobuf::internal::kEmptyString) {
    signal_id_->clear();
  }
  clear_has_signal_id();
}
inline const ::std::string& SignalData::signal_id() const {
  return *signal_id_;
}
inline void SignalData::set_signal_id(const ::std::string& value) {
  set_has_signal_id();
  if (signal_id_ == &::google::protobuf::internal::kEmptyString) {
    signal_id_ = new ::std::string;
  }
  signal_id_->assign(value);
}
inline void SignalData::set_signal_id(const char* value) {
  set_has_signal_id();
  if (signal_id_ == &::google::protobuf::internal::kEmptyString) {
    signal_id_ = new ::std::string;
  }
  signal_id_->assign(value);
}
inline void SignalData::set_signal_id(const char* value, size_t size) {
  set_has_signal_id();
  if (signal_id_ == &::google::protobuf::internal::kEmptyString) {
    signal_id_ = new ::std::string;
  }
  signal_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalData::mutable_signal_id() {
  set_has_signal_id();
  if (signal_id_ == &::google::protobuf::internal::kEmptyString) {
    signal_id_ = new ::std::string;
  }
  return signal_id_;
}
inline ::std::string* SignalData::release_signal_id() {
  clear_has_signal_id();
  if (signal_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signal_id_;
    signal_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string instrument_id = 4;
inline bool SignalData::has_instrument_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignalData::set_has_instrument_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignalData::clear_has_instrument_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignalData::clear_instrument_id() {
  if (instrument_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_id_->clear();
  }
  clear_has_instrument_id();
}
inline const ::std::string& SignalData::instrument_id() const {
  return *instrument_id_;
}
inline void SignalData::set_instrument_id(const ::std::string& value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void SignalData::set_instrument_id(const char* value) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(value);
}
inline void SignalData::set_instrument_id(const char* value, size_t size) {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  instrument_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalData::mutable_instrument_id() {
  set_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_id_ = new ::std::string;
  }
  return instrument_id_;
}
inline ::std::string* SignalData::release_instrument_id() {
  clear_has_instrument_id();
  if (instrument_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_id_;
    instrument_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string side_code = 5;
inline bool SignalData::has_side_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignalData::set_has_side_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignalData::clear_has_side_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignalData::clear_side_code() {
  if (side_code_ != &::google::protobuf::internal::kEmptyString) {
    side_code_->clear();
  }
  clear_has_side_code();
}
inline const ::std::string& SignalData::side_code() const {
  return *side_code_;
}
inline void SignalData::set_side_code(const ::std::string& value) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(value);
}
inline void SignalData::set_side_code(const char* value) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(value);
}
inline void SignalData::set_side_code(const char* value, size_t size) {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  side_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalData::mutable_side_code() {
  set_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    side_code_ = new ::std::string;
  }
  return side_code_;
}
inline ::std::string* SignalData::release_side_code() {
  clear_has_side_code();
  if (side_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = side_code_;
    side_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string signal_qty = 6;
inline bool SignalData::has_signal_qty() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignalData::set_has_signal_qty() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignalData::clear_has_signal_qty() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignalData::clear_signal_qty() {
  if (signal_qty_ != &::google::protobuf::internal::kEmptyString) {
    signal_qty_->clear();
  }
  clear_has_signal_qty();
}
inline const ::std::string& SignalData::signal_qty() const {
  return *signal_qty_;
}
inline void SignalData::set_signal_qty(const ::std::string& value) {
  set_has_signal_qty();
  if (signal_qty_ == &::google::protobuf::internal::kEmptyString) {
    signal_qty_ = new ::std::string;
  }
  signal_qty_->assign(value);
}
inline void SignalData::set_signal_qty(const char* value) {
  set_has_signal_qty();
  if (signal_qty_ == &::google::protobuf::internal::kEmptyString) {
    signal_qty_ = new ::std::string;
  }
  signal_qty_->assign(value);
}
inline void SignalData::set_signal_qty(const char* value, size_t size) {
  set_has_signal_qty();
  if (signal_qty_ == &::google::protobuf::internal::kEmptyString) {
    signal_qty_ = new ::std::string;
  }
  signal_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalData::mutable_signal_qty() {
  set_has_signal_qty();
  if (signal_qty_ == &::google::protobuf::internal::kEmptyString) {
    signal_qty_ = new ::std::string;
  }
  return signal_qty_;
}
inline ::std::string* SignalData::release_signal_qty() {
  clear_has_signal_qty();
  if (signal_qty_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signal_qty_;
    signal_qty_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string order_type = 7;
inline bool SignalData::has_order_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SignalData::set_has_order_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SignalData::clear_has_order_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SignalData::clear_order_type() {
  if (order_type_ != &::google::protobuf::internal::kEmptyString) {
    order_type_->clear();
  }
  clear_has_order_type();
}
inline const ::std::string& SignalData::order_type() const {
  return *order_type_;
}
inline void SignalData::set_order_type(const ::std::string& value) {
  set_has_order_type();
  if (order_type_ == &::google::protobuf::internal::kEmptyString) {
    order_type_ = new ::std::string;
  }
  order_type_->assign(value);
}
inline void SignalData::set_order_type(const char* value) {
  set_has_order_type();
  if (order_type_ == &::google::protobuf::internal::kEmptyString) {
    order_type_ = new ::std::string;
  }
  order_type_->assign(value);
}
inline void SignalData::set_order_type(const char* value, size_t size) {
  set_has_order_type();
  if (order_type_ == &::google::protobuf::internal::kEmptyString) {
    order_type_ = new ::std::string;
  }
  order_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalData::mutable_order_type() {
  set_has_order_type();
  if (order_type_ == &::google::protobuf::internal::kEmptyString) {
    order_type_ = new ::std::string;
  }
  return order_type_;
}
inline ::std::string* SignalData::release_order_type() {
  clear_has_order_type();
  if (order_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_type_;
    order_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string limit_prc = 8 [default = "0"];
inline bool SignalData::has_limit_prc() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SignalData::set_has_limit_prc() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SignalData::clear_has_limit_prc() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SignalData::clear_limit_prc() {
  if (limit_prc_ != &_default_limit_prc_) {
    limit_prc_->assign(_default_limit_prc_);
  }
  clear_has_limit_prc();
}
inline const ::std::string& SignalData::limit_prc() const {
  return *limit_prc_;
}
inline void SignalData::set_limit_prc(const ::std::string& value) {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string;
  }
  limit_prc_->assign(value);
}
inline void SignalData::set_limit_prc(const char* value) {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string;
  }
  limit_prc_->assign(value);
}
inline void SignalData::set_limit_prc(const char* value, size_t size) {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string;
  }
  limit_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalData::mutable_limit_prc() {
  set_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    limit_prc_ = new ::std::string(_default_limit_prc_);
  }
  return limit_prc_;
}
inline ::std::string* SignalData::release_limit_prc() {
  clear_has_limit_prc();
  if (limit_prc_ == &_default_limit_prc_) {
    return NULL;
  } else {
    ::std::string* temp = limit_prc_;
    limit_prc_ = const_cast< ::std::string*>(&_default_limit_prc_);
    return temp;
  }
}

// optional string stop_prc = 9 [default = "0"];
inline bool SignalData::has_stop_prc() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SignalData::set_has_stop_prc() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SignalData::clear_has_stop_prc() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SignalData::clear_stop_prc() {
  if (stop_prc_ != &_default_stop_prc_) {
    stop_prc_->assign(_default_stop_prc_);
  }
  clear_has_stop_prc();
}
inline const ::std::string& SignalData::stop_prc() const {
  return *stop_prc_;
}
inline void SignalData::set_stop_prc(const ::std::string& value) {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string;
  }
  stop_prc_->assign(value);
}
inline void SignalData::set_stop_prc(const char* value) {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string;
  }
  stop_prc_->assign(value);
}
inline void SignalData::set_stop_prc(const char* value, size_t size) {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string;
  }
  stop_prc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignalData::mutable_stop_prc() {
  set_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    stop_prc_ = new ::std::string(_default_stop_prc_);
  }
  return stop_prc_;
}
inline ::std::string* SignalData::release_stop_prc() {
  clear_has_stop_prc();
  if (stop_prc_ == &_default_stop_prc_) {
    return NULL;
  } else {
    ::std::string* temp = stop_prc_;
    stop_prc_ = const_cast< ::std::string*>(&_default_stop_prc_);
    return temp;
  }
}

// -------------------------------------------------------------------

// InvestmentSystemData

// optional string investment_system_id = 1;
inline bool InvestmentSystemData::has_investment_system_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvestmentSystemData::set_has_investment_system_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvestmentSystemData::clear_has_investment_system_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvestmentSystemData::clear_investment_system_id() {
  if (investment_system_id_ != &::google::protobuf::internal::kEmptyString) {
    investment_system_id_->clear();
  }
  clear_has_investment_system_id();
}
inline const ::std::string& InvestmentSystemData::investment_system_id() const {
  return *investment_system_id_;
}
inline void InvestmentSystemData::set_investment_system_id(const ::std::string& value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void InvestmentSystemData::set_investment_system_id(const char* value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void InvestmentSystemData::set_investment_system_id(const char* value, size_t size) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemData::mutable_investment_system_id() {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  return investment_system_id_;
}
inline ::std::string* InvestmentSystemData::release_investment_system_id() {
  clear_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = investment_system_id_;
    investment_system_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string name = 2;
inline bool InvestmentSystemData::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvestmentSystemData::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvestmentSystemData::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvestmentSystemData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& InvestmentSystemData::name() const {
  return *name_;
}
inline void InvestmentSystemData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InvestmentSystemData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void InvestmentSystemData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* InvestmentSystemData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string is_active = 3;
inline bool InvestmentSystemData::has_is_active() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvestmentSystemData::set_has_is_active() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvestmentSystemData::clear_has_is_active() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvestmentSystemData::clear_is_active() {
  if (is_active_ != &::google::protobuf::internal::kEmptyString) {
    is_active_->clear();
  }
  clear_has_is_active();
}
inline const ::std::string& InvestmentSystemData::is_active() const {
  return *is_active_;
}
inline void InvestmentSystemData::set_is_active(const ::std::string& value) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(value);
}
inline void InvestmentSystemData::set_is_active(const char* value) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(value);
}
inline void InvestmentSystemData::set_is_active(const char* value, size_t size) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemData::mutable_is_active() {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  return is_active_;
}
inline ::std::string* InvestmentSystemData::release_is_active() {
  clear_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = is_active_;
    is_active_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StrategyData

// optional string strategy_id = 1;
inline bool StrategyData::has_strategy_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StrategyData::set_has_strategy_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StrategyData::clear_has_strategy_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StrategyData::clear_strategy_id() {
  if (strategy_id_ != &::google::protobuf::internal::kEmptyString) {
    strategy_id_->clear();
  }
  clear_has_strategy_id();
}
inline const ::std::string& StrategyData::strategy_id() const {
  return *strategy_id_;
}
inline void StrategyData::set_strategy_id(const ::std::string& value) {
  set_has_strategy_id();
  if (strategy_id_ == &::google::protobuf::internal::kEmptyString) {
    strategy_id_ = new ::std::string;
  }
  strategy_id_->assign(value);
}
inline void StrategyData::set_strategy_id(const char* value) {
  set_has_strategy_id();
  if (strategy_id_ == &::google::protobuf::internal::kEmptyString) {
    strategy_id_ = new ::std::string;
  }
  strategy_id_->assign(value);
}
inline void StrategyData::set_strategy_id(const char* value, size_t size) {
  set_has_strategy_id();
  if (strategy_id_ == &::google::protobuf::internal::kEmptyString) {
    strategy_id_ = new ::std::string;
  }
  strategy_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrategyData::mutable_strategy_id() {
  set_has_strategy_id();
  if (strategy_id_ == &::google::protobuf::internal::kEmptyString) {
    strategy_id_ = new ::std::string;
  }
  return strategy_id_;
}
inline ::std::string* StrategyData::release_strategy_id() {
  clear_has_strategy_id();
  if (strategy_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strategy_id_;
    strategy_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string investment_system_id = 2;
inline bool StrategyData::has_investment_system_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StrategyData::set_has_investment_system_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StrategyData::clear_has_investment_system_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StrategyData::clear_investment_system_id() {
  if (investment_system_id_ != &::google::protobuf::internal::kEmptyString) {
    investment_system_id_->clear();
  }
  clear_has_investment_system_id();
}
inline const ::std::string& StrategyData::investment_system_id() const {
  return *investment_system_id_;
}
inline void StrategyData::set_investment_system_id(const ::std::string& value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void StrategyData::set_investment_system_id(const char* value) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(value);
}
inline void StrategyData::set_investment_system_id(const char* value, size_t size) {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  investment_system_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrategyData::mutable_investment_system_id() {
  set_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    investment_system_id_ = new ::std::string;
  }
  return investment_system_id_;
}
inline ::std::string* StrategyData::release_investment_system_id() {
  clear_has_investment_system_id();
  if (investment_system_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = investment_system_id_;
    investment_system_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string signal_id = 3;
inline bool StrategyData::has_signal_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StrategyData::set_has_signal_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StrategyData::clear_has_signal_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StrategyData::clear_signal_id() {
  if (signal_id_ != &::google::protobuf::internal::kEmptyString) {
    signal_id_->clear();
  }
  clear_has_signal_id();
}
inline const ::std::string& StrategyData::signal_id() const {
  return *signal_id_;
}
inline void StrategyData::set_signal_id(const ::std::string& value) {
  set_has_signal_id();
  if (signal_id_ == &::google::protobuf::internal::kEmptyString) {
    signal_id_ = new ::std::string;
  }
  signal_id_->assign(value);
}
inline void StrategyData::set_signal_id(const char* value) {
  set_has_signal_id();
  if (signal_id_ == &::google::protobuf::internal::kEmptyString) {
    signal_id_ = new ::std::string;
  }
  signal_id_->assign(value);
}
inline void StrategyData::set_signal_id(const char* value, size_t size) {
  set_has_signal_id();
  if (signal_id_ == &::google::protobuf::internal::kEmptyString) {
    signal_id_ = new ::std::string;
  }
  signal_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrategyData::mutable_signal_id() {
  set_has_signal_id();
  if (signal_id_ == &::google::protobuf::internal::kEmptyString) {
    signal_id_ = new ::std::string;
  }
  return signal_id_;
}
inline ::std::string* StrategyData::release_signal_id() {
  clear_has_signal_id();
  if (signal_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signal_id_;
    signal_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string name = 4;
inline bool StrategyData::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StrategyData::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StrategyData::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StrategyData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StrategyData::name() const {
  return *name_;
}
inline void StrategyData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StrategyData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StrategyData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrategyData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* StrategyData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string default_weight = 5;
inline bool StrategyData::has_default_weight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StrategyData::set_has_default_weight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StrategyData::clear_has_default_weight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StrategyData::clear_default_weight() {
  if (default_weight_ != &::google::protobuf::internal::kEmptyString) {
    default_weight_->clear();
  }
  clear_has_default_weight();
}
inline const ::std::string& StrategyData::default_weight() const {
  return *default_weight_;
}
inline void StrategyData::set_default_weight(const ::std::string& value) {
  set_has_default_weight();
  if (default_weight_ == &::google::protobuf::internal::kEmptyString) {
    default_weight_ = new ::std::string;
  }
  default_weight_->assign(value);
}
inline void StrategyData::set_default_weight(const char* value) {
  set_has_default_weight();
  if (default_weight_ == &::google::protobuf::internal::kEmptyString) {
    default_weight_ = new ::std::string;
  }
  default_weight_->assign(value);
}
inline void StrategyData::set_default_weight(const char* value, size_t size) {
  set_has_default_weight();
  if (default_weight_ == &::google::protobuf::internal::kEmptyString) {
    default_weight_ = new ::std::string;
  }
  default_weight_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrategyData::mutable_default_weight() {
  set_has_default_weight();
  if (default_weight_ == &::google::protobuf::internal::kEmptyString) {
    default_weight_ = new ::std::string;
  }
  return default_weight_;
}
inline ::std::string* StrategyData::release_default_weight() {
  clear_has_default_weight();
  if (default_weight_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = default_weight_;
    default_weight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string is_active = 6;
inline bool StrategyData::has_is_active() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StrategyData::set_has_is_active() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StrategyData::clear_has_is_active() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StrategyData::clear_is_active() {
  if (is_active_ != &::google::protobuf::internal::kEmptyString) {
    is_active_->clear();
  }
  clear_has_is_active();
}
inline const ::std::string& StrategyData::is_active() const {
  return *is_active_;
}
inline void StrategyData::set_is_active(const ::std::string& value) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(value);
}
inline void StrategyData::set_is_active(const char* value) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(value);
}
inline void StrategyData::set_is_active(const char* value, size_t size) {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  is_active_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrategyData::mutable_is_active() {
  set_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    is_active_ = new ::std::string;
  }
  return is_active_;
}
inline ::std::string* StrategyData::release_is_active() {
  clear_has_is_active();
  if (is_active_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = is_active_;
    is_active_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AccountStrategyData

// optional string account_id = 1;
inline bool AccountStrategyData::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountStrategyData::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountStrategyData::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountStrategyData::clear_account_id() {
  if (account_id_ != &::google::protobuf::internal::kEmptyString) {
    account_id_->clear();
  }
  clear_has_account_id();
}
inline const ::std::string& AccountStrategyData::account_id() const {
  return *account_id_;
}
inline void AccountStrategyData::set_account_id(const ::std::string& value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void AccountStrategyData::set_account_id(const char* value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void AccountStrategyData::set_account_id(const char* value, size_t size) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountStrategyData::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  return account_id_;
}
inline ::std::string* AccountStrategyData::release_account_id() {
  clear_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_id_;
    account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string strategy_id = 2;
inline bool AccountStrategyData::has_strategy_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountStrategyData::set_has_strategy_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountStrategyData::clear_has_strategy_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountStrategyData::clear_strategy_id() {
  if (strategy_id_ != &::google::protobuf::internal::kEmptyString) {
    strategy_id_->clear();
  }
  clear_has_strategy_id();
}
inline const ::std::string& AccountStrategyData::strategy_id() const {
  return *strategy_id_;
}
inline void AccountStrategyData::set_strategy_id(const ::std::string& value) {
  set_has_strategy_id();
  if (strategy_id_ == &::google::protobuf::internal::kEmptyString) {
    strategy_id_ = new ::std::string;
  }
  strategy_id_->assign(value);
}
inline void AccountStrategyData::set_strategy_id(const char* value) {
  set_has_strategy_id();
  if (strategy_id_ == &::google::protobuf::internal::kEmptyString) {
    strategy_id_ = new ::std::string;
  }
  strategy_id_->assign(value);
}
inline void AccountStrategyData::set_strategy_id(const char* value, size_t size) {
  set_has_strategy_id();
  if (strategy_id_ == &::google::protobuf::internal::kEmptyString) {
    strategy_id_ = new ::std::string;
  }
  strategy_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountStrategyData::mutable_strategy_id() {
  set_has_strategy_id();
  if (strategy_id_ == &::google::protobuf::internal::kEmptyString) {
    strategy_id_ = new ::std::string;
  }
  return strategy_id_;
}
inline ::std::string* AccountStrategyData::release_strategy_id() {
  clear_has_strategy_id();
  if (strategy_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strategy_id_;
    strategy_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string weight = 3;
inline bool AccountStrategyData::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountStrategyData::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountStrategyData::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountStrategyData::clear_weight() {
  if (weight_ != &::google::protobuf::internal::kEmptyString) {
    weight_->clear();
  }
  clear_has_weight();
}
inline const ::std::string& AccountStrategyData::weight() const {
  return *weight_;
}
inline void AccountStrategyData::set_weight(const ::std::string& value) {
  set_has_weight();
  if (weight_ == &::google::protobuf::internal::kEmptyString) {
    weight_ = new ::std::string;
  }
  weight_->assign(value);
}
inline void AccountStrategyData::set_weight(const char* value) {
  set_has_weight();
  if (weight_ == &::google::protobuf::internal::kEmptyString) {
    weight_ = new ::std::string;
  }
  weight_->assign(value);
}
inline void AccountStrategyData::set_weight(const char* value, size_t size) {
  set_has_weight();
  if (weight_ == &::google::protobuf::internal::kEmptyString) {
    weight_ = new ::std::string;
  }
  weight_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountStrategyData::mutable_weight() {
  set_has_weight();
  if (weight_ == &::google::protobuf::internal::kEmptyString) {
    weight_ = new ::std::string;
  }
  return weight_;
}
inline ::std::string* AccountStrategyData::release_weight() {
  clear_has_weight();
  if (weight_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weight_;
    weight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string is_enabled = 4;
inline bool AccountStrategyData::has_is_enabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountStrategyData::set_has_is_enabled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountStrategyData::clear_has_is_enabled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountStrategyData::clear_is_enabled() {
  if (is_enabled_ != &::google::protobuf::internal::kEmptyString) {
    is_enabled_->clear();
  }
  clear_has_is_enabled();
}
inline const ::std::string& AccountStrategyData::is_enabled() const {
  return *is_enabled_;
}
inline void AccountStrategyData::set_is_enabled(const ::std::string& value) {
  set_has_is_enabled();
  if (is_enabled_ == &::google::protobuf::internal::kEmptyString) {
    is_enabled_ = new ::std::string;
  }
  is_enabled_->assign(value);
}
inline void AccountStrategyData::set_is_enabled(const char* value) {
  set_has_is_enabled();
  if (is_enabled_ == &::google::protobuf::internal::kEmptyString) {
    is_enabled_ = new ::std::string;
  }
  is_enabled_->assign(value);
}
inline void AccountStrategyData::set_is_enabled(const char* value, size_t size) {
  set_has_is_enabled();
  if (is_enabled_ == &::google::protobuf::internal::kEmptyString) {
    is_enabled_ = new ::std::string;
  }
  is_enabled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountStrategyData::mutable_is_enabled() {
  set_has_is_enabled();
  if (is_enabled_ == &::google::protobuf::internal::kEmptyString) {
    is_enabled_ = new ::std::string;
  }
  return is_enabled_;
}
inline ::std::string* AccountStrategyData::release_is_enabled() {
  clear_has_is_enabled();
  if (is_enabled_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = is_enabled_;
    is_enabled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ExecutionReportData

// optional string release_id = 1;
inline bool ExecutionReportData::has_release_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutionReportData::set_has_release_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutionReportData::clear_has_release_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutionReportData::clear_release_id() {
  if (release_id_ != &::google::protobuf::internal::kEmptyString) {
    release_id_->clear();
  }
  clear_has_release_id();
}
inline const ::std::string& ExecutionReportData::release_id() const {
  return *release_id_;
}
inline void ExecutionReportData::set_release_id(const ::std::string& value) {
  set_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    release_id_ = new ::std::string;
  }
  release_id_->assign(value);
}
inline void ExecutionReportData::set_release_id(const char* value) {
  set_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    release_id_ = new ::std::string;
  }
  release_id_->assign(value);
}
inline void ExecutionReportData::set_release_id(const char* value, size_t size) {
  set_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    release_id_ = new ::std::string;
  }
  release_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_release_id() {
  set_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    release_id_ = new ::std::string;
  }
  return release_id_;
}
inline ::std::string* ExecutionReportData::release_release_id() {
  clear_has_release_id();
  if (release_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = release_id_;
    release_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string session_id = 2;
inline bool ExecutionReportData::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutionReportData::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutionReportData::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutionReportData::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& ExecutionReportData::session_id() const {
  return *session_id_;
}
inline void ExecutionReportData::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void ExecutionReportData::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void ExecutionReportData::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* ExecutionReportData::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sending_tm = 3;
inline bool ExecutionReportData::has_sending_tm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecutionReportData::set_has_sending_tm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecutionReportData::clear_has_sending_tm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecutionReportData::clear_sending_tm() {
  if (sending_tm_ != &::google::protobuf::internal::kEmptyString) {
    sending_tm_->clear();
  }
  clear_has_sending_tm();
}
inline const ::std::string& ExecutionReportData::sending_tm() const {
  return *sending_tm_;
}
inline void ExecutionReportData::set_sending_tm(const ::std::string& value) {
  set_has_sending_tm();
  if (sending_tm_ == &::google::protobuf::internal::kEmptyString) {
    sending_tm_ = new ::std::string;
  }
  sending_tm_->assign(value);
}
inline void ExecutionReportData::set_sending_tm(const char* value) {
  set_has_sending_tm();
  if (sending_tm_ == &::google::protobuf::internal::kEmptyString) {
    sending_tm_ = new ::std::string;
  }
  sending_tm_->assign(value);
}
inline void ExecutionReportData::set_sending_tm(const char* value, size_t size) {
  set_has_sending_tm();
  if (sending_tm_ == &::google::protobuf::internal::kEmptyString) {
    sending_tm_ = new ::std::string;
  }
  sending_tm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_sending_tm() {
  set_has_sending_tm();
  if (sending_tm_ == &::google::protobuf::internal::kEmptyString) {
    sending_tm_ = new ::std::string;
  }
  return sending_tm_;
}
inline ::std::string* ExecutionReportData::release_sending_tm() {
  clear_has_sending_tm();
  if (sending_tm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sending_tm_;
    sending_tm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ExecID = 4;
inline bool ExecutionReportData::has_execid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecutionReportData::set_has_execid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecutionReportData::clear_has_execid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecutionReportData::clear_execid() {
  if (execid_ != &::google::protobuf::internal::kEmptyString) {
    execid_->clear();
  }
  clear_has_execid();
}
inline const ::std::string& ExecutionReportData::execid() const {
  return *execid_;
}
inline void ExecutionReportData::set_execid(const ::std::string& value) {
  set_has_execid();
  if (execid_ == &::google::protobuf::internal::kEmptyString) {
    execid_ = new ::std::string;
  }
  execid_->assign(value);
}
inline void ExecutionReportData::set_execid(const char* value) {
  set_has_execid();
  if (execid_ == &::google::protobuf::internal::kEmptyString) {
    execid_ = new ::std::string;
  }
  execid_->assign(value);
}
inline void ExecutionReportData::set_execid(const char* value, size_t size) {
  set_has_execid();
  if (execid_ == &::google::protobuf::internal::kEmptyString) {
    execid_ = new ::std::string;
  }
  execid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_execid() {
  set_has_execid();
  if (execid_ == &::google::protobuf::internal::kEmptyString) {
    execid_ = new ::std::string;
  }
  return execid_;
}
inline ::std::string* ExecutionReportData::release_execid() {
  clear_has_execid();
  if (execid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = execid_;
    execid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string OrderID = 5;
inline bool ExecutionReportData::has_orderid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExecutionReportData::set_has_orderid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExecutionReportData::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExecutionReportData::clear_orderid() {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    orderid_->clear();
  }
  clear_has_orderid();
}
inline const ::std::string& ExecutionReportData::orderid() const {
  return *orderid_;
}
inline void ExecutionReportData::set_orderid(const ::std::string& value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void ExecutionReportData::set_orderid(const char* value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void ExecutionReportData::set_orderid(const char* value, size_t size) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_orderid() {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  return orderid_;
}
inline ::std::string* ExecutionReportData::release_orderid() {
  clear_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderid_;
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ClOrdID = 6;
inline bool ExecutionReportData::has_clordid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExecutionReportData::set_has_clordid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExecutionReportData::clear_has_clordid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExecutionReportData::clear_clordid() {
  if (clordid_ != &::google::protobuf::internal::kEmptyString) {
    clordid_->clear();
  }
  clear_has_clordid();
}
inline const ::std::string& ExecutionReportData::clordid() const {
  return *clordid_;
}
inline void ExecutionReportData::set_clordid(const ::std::string& value) {
  set_has_clordid();
  if (clordid_ == &::google::protobuf::internal::kEmptyString) {
    clordid_ = new ::std::string;
  }
  clordid_->assign(value);
}
inline void ExecutionReportData::set_clordid(const char* value) {
  set_has_clordid();
  if (clordid_ == &::google::protobuf::internal::kEmptyString) {
    clordid_ = new ::std::string;
  }
  clordid_->assign(value);
}
inline void ExecutionReportData::set_clordid(const char* value, size_t size) {
  set_has_clordid();
  if (clordid_ == &::google::protobuf::internal::kEmptyString) {
    clordid_ = new ::std::string;
  }
  clordid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_clordid() {
  set_has_clordid();
  if (clordid_ == &::google::protobuf::internal::kEmptyString) {
    clordid_ = new ::std::string;
  }
  return clordid_;
}
inline ::std::string* ExecutionReportData::release_clordid() {
  clear_has_clordid();
  if (clordid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clordid_;
    clordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string OrigClOrdID = 7;
inline bool ExecutionReportData::has_origclordid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExecutionReportData::set_has_origclordid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExecutionReportData::clear_has_origclordid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExecutionReportData::clear_origclordid() {
  if (origclordid_ != &::google::protobuf::internal::kEmptyString) {
    origclordid_->clear();
  }
  clear_has_origclordid();
}
inline const ::std::string& ExecutionReportData::origclordid() const {
  return *origclordid_;
}
inline void ExecutionReportData::set_origclordid(const ::std::string& value) {
  set_has_origclordid();
  if (origclordid_ == &::google::protobuf::internal::kEmptyString) {
    origclordid_ = new ::std::string;
  }
  origclordid_->assign(value);
}
inline void ExecutionReportData::set_origclordid(const char* value) {
  set_has_origclordid();
  if (origclordid_ == &::google::protobuf::internal::kEmptyString) {
    origclordid_ = new ::std::string;
  }
  origclordid_->assign(value);
}
inline void ExecutionReportData::set_origclordid(const char* value, size_t size) {
  set_has_origclordid();
  if (origclordid_ == &::google::protobuf::internal::kEmptyString) {
    origclordid_ = new ::std::string;
  }
  origclordid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_origclordid() {
  set_has_origclordid();
  if (origclordid_ == &::google::protobuf::internal::kEmptyString) {
    origclordid_ = new ::std::string;
  }
  return origclordid_;
}
inline ::std::string* ExecutionReportData::release_origclordid() {
  clear_has_origclordid();
  if (origclordid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = origclordid_;
    origclordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ExecRefID = 8;
inline bool ExecutionReportData::has_execrefid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExecutionReportData::set_has_execrefid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExecutionReportData::clear_has_execrefid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExecutionReportData::clear_execrefid() {
  if (execrefid_ != &::google::protobuf::internal::kEmptyString) {
    execrefid_->clear();
  }
  clear_has_execrefid();
}
inline const ::std::string& ExecutionReportData::execrefid() const {
  return *execrefid_;
}
inline void ExecutionReportData::set_execrefid(const ::std::string& value) {
  set_has_execrefid();
  if (execrefid_ == &::google::protobuf::internal::kEmptyString) {
    execrefid_ = new ::std::string;
  }
  execrefid_->assign(value);
}
inline void ExecutionReportData::set_execrefid(const char* value) {
  set_has_execrefid();
  if (execrefid_ == &::google::protobuf::internal::kEmptyString) {
    execrefid_ = new ::std::string;
  }
  execrefid_->assign(value);
}
inline void ExecutionReportData::set_execrefid(const char* value, size_t size) {
  set_has_execrefid();
  if (execrefid_ == &::google::protobuf::internal::kEmptyString) {
    execrefid_ = new ::std::string;
  }
  execrefid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_execrefid() {
  set_has_execrefid();
  if (execrefid_ == &::google::protobuf::internal::kEmptyString) {
    execrefid_ = new ::std::string;
  }
  return execrefid_;
}
inline ::std::string* ExecutionReportData::release_execrefid() {
  clear_has_execrefid();
  if (execrefid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = execrefid_;
    execrefid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string OrdType = 9;
inline bool ExecutionReportData::has_ordtype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExecutionReportData::set_has_ordtype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExecutionReportData::clear_has_ordtype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExecutionReportData::clear_ordtype() {
  if (ordtype_ != &::google::protobuf::internal::kEmptyString) {
    ordtype_->clear();
  }
  clear_has_ordtype();
}
inline const ::std::string& ExecutionReportData::ordtype() const {
  return *ordtype_;
}
inline void ExecutionReportData::set_ordtype(const ::std::string& value) {
  set_has_ordtype();
  if (ordtype_ == &::google::protobuf::internal::kEmptyString) {
    ordtype_ = new ::std::string;
  }
  ordtype_->assign(value);
}
inline void ExecutionReportData::set_ordtype(const char* value) {
  set_has_ordtype();
  if (ordtype_ == &::google::protobuf::internal::kEmptyString) {
    ordtype_ = new ::std::string;
  }
  ordtype_->assign(value);
}
inline void ExecutionReportData::set_ordtype(const char* value, size_t size) {
  set_has_ordtype();
  if (ordtype_ == &::google::protobuf::internal::kEmptyString) {
    ordtype_ = new ::std::string;
  }
  ordtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_ordtype() {
  set_has_ordtype();
  if (ordtype_ == &::google::protobuf::internal::kEmptyString) {
    ordtype_ = new ::std::string;
  }
  return ordtype_;
}
inline ::std::string* ExecutionReportData::release_ordtype() {
  clear_has_ordtype();
  if (ordtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ordtype_;
    ordtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ExecType = 10;
inline bool ExecutionReportData::has_exectype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ExecutionReportData::set_has_exectype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ExecutionReportData::clear_has_exectype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ExecutionReportData::clear_exectype() {
  if (exectype_ != &::google::protobuf::internal::kEmptyString) {
    exectype_->clear();
  }
  clear_has_exectype();
}
inline const ::std::string& ExecutionReportData::exectype() const {
  return *exectype_;
}
inline void ExecutionReportData::set_exectype(const ::std::string& value) {
  set_has_exectype();
  if (exectype_ == &::google::protobuf::internal::kEmptyString) {
    exectype_ = new ::std::string;
  }
  exectype_->assign(value);
}
inline void ExecutionReportData::set_exectype(const char* value) {
  set_has_exectype();
  if (exectype_ == &::google::protobuf::internal::kEmptyString) {
    exectype_ = new ::std::string;
  }
  exectype_->assign(value);
}
inline void ExecutionReportData::set_exectype(const char* value, size_t size) {
  set_has_exectype();
  if (exectype_ == &::google::protobuf::internal::kEmptyString) {
    exectype_ = new ::std::string;
  }
  exectype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_exectype() {
  set_has_exectype();
  if (exectype_ == &::google::protobuf::internal::kEmptyString) {
    exectype_ = new ::std::string;
  }
  return exectype_;
}
inline ::std::string* ExecutionReportData::release_exectype() {
  clear_has_exectype();
  if (exectype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exectype_;
    exectype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ExecTransType = 11;
inline bool ExecutionReportData::has_exectranstype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ExecutionReportData::set_has_exectranstype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ExecutionReportData::clear_has_exectranstype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ExecutionReportData::clear_exectranstype() {
  if (exectranstype_ != &::google::protobuf::internal::kEmptyString) {
    exectranstype_->clear();
  }
  clear_has_exectranstype();
}
inline const ::std::string& ExecutionReportData::exectranstype() const {
  return *exectranstype_;
}
inline void ExecutionReportData::set_exectranstype(const ::std::string& value) {
  set_has_exectranstype();
  if (exectranstype_ == &::google::protobuf::internal::kEmptyString) {
    exectranstype_ = new ::std::string;
  }
  exectranstype_->assign(value);
}
inline void ExecutionReportData::set_exectranstype(const char* value) {
  set_has_exectranstype();
  if (exectranstype_ == &::google::protobuf::internal::kEmptyString) {
    exectranstype_ = new ::std::string;
  }
  exectranstype_->assign(value);
}
inline void ExecutionReportData::set_exectranstype(const char* value, size_t size) {
  set_has_exectranstype();
  if (exectranstype_ == &::google::protobuf::internal::kEmptyString) {
    exectranstype_ = new ::std::string;
  }
  exectranstype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_exectranstype() {
  set_has_exectranstype();
  if (exectranstype_ == &::google::protobuf::internal::kEmptyString) {
    exectranstype_ = new ::std::string;
  }
  return exectranstype_;
}
inline ::std::string* ExecutionReportData::release_exectranstype() {
  clear_has_exectranstype();
  if (exectranstype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exectranstype_;
    exectranstype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MultiLegReportingType = 12 [default = "1"];
inline bool ExecutionReportData::has_multilegreportingtype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ExecutionReportData::set_has_multilegreportingtype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ExecutionReportData::clear_has_multilegreportingtype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ExecutionReportData::clear_multilegreportingtype() {
  if (multilegreportingtype_ != &_default_multilegreportingtype_) {
    multilegreportingtype_->assign(_default_multilegreportingtype_);
  }
  clear_has_multilegreportingtype();
}
inline const ::std::string& ExecutionReportData::multilegreportingtype() const {
  return *multilegreportingtype_;
}
inline void ExecutionReportData::set_multilegreportingtype(const ::std::string& value) {
  set_has_multilegreportingtype();
  if (multilegreportingtype_ == &_default_multilegreportingtype_) {
    multilegreportingtype_ = new ::std::string;
  }
  multilegreportingtype_->assign(value);
}
inline void ExecutionReportData::set_multilegreportingtype(const char* value) {
  set_has_multilegreportingtype();
  if (multilegreportingtype_ == &_default_multilegreportingtype_) {
    multilegreportingtype_ = new ::std::string;
  }
  multilegreportingtype_->assign(value);
}
inline void ExecutionReportData::set_multilegreportingtype(const char* value, size_t size) {
  set_has_multilegreportingtype();
  if (multilegreportingtype_ == &_default_multilegreportingtype_) {
    multilegreportingtype_ = new ::std::string;
  }
  multilegreportingtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_multilegreportingtype() {
  set_has_multilegreportingtype();
  if (multilegreportingtype_ == &_default_multilegreportingtype_) {
    multilegreportingtype_ = new ::std::string(_default_multilegreportingtype_);
  }
  return multilegreportingtype_;
}
inline ::std::string* ExecutionReportData::release_multilegreportingtype() {
  clear_has_multilegreportingtype();
  if (multilegreportingtype_ == &_default_multilegreportingtype_) {
    return NULL;
  } else {
    ::std::string* temp = multilegreportingtype_;
    multilegreportingtype_ = const_cast< ::std::string*>(&_default_multilegreportingtype_);
    return temp;
  }
}

// optional string SecurityID = 13;
inline bool ExecutionReportData::has_securityid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ExecutionReportData::set_has_securityid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ExecutionReportData::clear_has_securityid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ExecutionReportData::clear_securityid() {
  if (securityid_ != &::google::protobuf::internal::kEmptyString) {
    securityid_->clear();
  }
  clear_has_securityid();
}
inline const ::std::string& ExecutionReportData::securityid() const {
  return *securityid_;
}
inline void ExecutionReportData::set_securityid(const ::std::string& value) {
  set_has_securityid();
  if (securityid_ == &::google::protobuf::internal::kEmptyString) {
    securityid_ = new ::std::string;
  }
  securityid_->assign(value);
}
inline void ExecutionReportData::set_securityid(const char* value) {
  set_has_securityid();
  if (securityid_ == &::google::protobuf::internal::kEmptyString) {
    securityid_ = new ::std::string;
  }
  securityid_->assign(value);
}
inline void ExecutionReportData::set_securityid(const char* value, size_t size) {
  set_has_securityid();
  if (securityid_ == &::google::protobuf::internal::kEmptyString) {
    securityid_ = new ::std::string;
  }
  securityid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_securityid() {
  set_has_securityid();
  if (securityid_ == &::google::protobuf::internal::kEmptyString) {
    securityid_ = new ::std::string;
  }
  return securityid_;
}
inline ::std::string* ExecutionReportData::release_securityid() {
  clear_has_securityid();
  if (securityid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securityid_;
    securityid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string SecurityType = 14;
inline bool ExecutionReportData::has_securitytype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ExecutionReportData::set_has_securitytype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ExecutionReportData::clear_has_securitytype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ExecutionReportData::clear_securitytype() {
  if (securitytype_ != &::google::protobuf::internal::kEmptyString) {
    securitytype_->clear();
  }
  clear_has_securitytype();
}
inline const ::std::string& ExecutionReportData::securitytype() const {
  return *securitytype_;
}
inline void ExecutionReportData::set_securitytype(const ::std::string& value) {
  set_has_securitytype();
  if (securitytype_ == &::google::protobuf::internal::kEmptyString) {
    securitytype_ = new ::std::string;
  }
  securitytype_->assign(value);
}
inline void ExecutionReportData::set_securitytype(const char* value) {
  set_has_securitytype();
  if (securitytype_ == &::google::protobuf::internal::kEmptyString) {
    securitytype_ = new ::std::string;
  }
  securitytype_->assign(value);
}
inline void ExecutionReportData::set_securitytype(const char* value, size_t size) {
  set_has_securitytype();
  if (securitytype_ == &::google::protobuf::internal::kEmptyString) {
    securitytype_ = new ::std::string;
  }
  securitytype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_securitytype() {
  set_has_securitytype();
  if (securitytype_ == &::google::protobuf::internal::kEmptyString) {
    securitytype_ = new ::std::string;
  }
  return securitytype_;
}
inline ::std::string* ExecutionReportData::release_securitytype() {
  clear_has_securitytype();
  if (securitytype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitytype_;
    securitytype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string IDSource = 15;
inline bool ExecutionReportData::has_idsource() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ExecutionReportData::set_has_idsource() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ExecutionReportData::clear_has_idsource() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ExecutionReportData::clear_idsource() {
  if (idsource_ != &::google::protobuf::internal::kEmptyString) {
    idsource_->clear();
  }
  clear_has_idsource();
}
inline const ::std::string& ExecutionReportData::idsource() const {
  return *idsource_;
}
inline void ExecutionReportData::set_idsource(const ::std::string& value) {
  set_has_idsource();
  if (idsource_ == &::google::protobuf::internal::kEmptyString) {
    idsource_ = new ::std::string;
  }
  idsource_->assign(value);
}
inline void ExecutionReportData::set_idsource(const char* value) {
  set_has_idsource();
  if (idsource_ == &::google::protobuf::internal::kEmptyString) {
    idsource_ = new ::std::string;
  }
  idsource_->assign(value);
}
inline void ExecutionReportData::set_idsource(const char* value, size_t size) {
  set_has_idsource();
  if (idsource_ == &::google::protobuf::internal::kEmptyString) {
    idsource_ = new ::std::string;
  }
  idsource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_idsource() {
  set_has_idsource();
  if (idsource_ == &::google::protobuf::internal::kEmptyString) {
    idsource_ = new ::std::string;
  }
  return idsource_;
}
inline ::std::string* ExecutionReportData::release_idsource() {
  clear_has_idsource();
  if (idsource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = idsource_;
    idsource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Account = 16;
inline bool ExecutionReportData::has_account() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ExecutionReportData::set_has_account() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ExecutionReportData::clear_has_account() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ExecutionReportData::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ExecutionReportData::account() const {
  return *account_;
}
inline void ExecutionReportData::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ExecutionReportData::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ExecutionReportData::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ExecutionReportData::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string OrdStatus = 17;
inline bool ExecutionReportData::has_ordstatus() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ExecutionReportData::set_has_ordstatus() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ExecutionReportData::clear_has_ordstatus() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ExecutionReportData::clear_ordstatus() {
  if (ordstatus_ != &::google::protobuf::internal::kEmptyString) {
    ordstatus_->clear();
  }
  clear_has_ordstatus();
}
inline const ::std::string& ExecutionReportData::ordstatus() const {
  return *ordstatus_;
}
inline void ExecutionReportData::set_ordstatus(const ::std::string& value) {
  set_has_ordstatus();
  if (ordstatus_ == &::google::protobuf::internal::kEmptyString) {
    ordstatus_ = new ::std::string;
  }
  ordstatus_->assign(value);
}
inline void ExecutionReportData::set_ordstatus(const char* value) {
  set_has_ordstatus();
  if (ordstatus_ == &::google::protobuf::internal::kEmptyString) {
    ordstatus_ = new ::std::string;
  }
  ordstatus_->assign(value);
}
inline void ExecutionReportData::set_ordstatus(const char* value, size_t size) {
  set_has_ordstatus();
  if (ordstatus_ == &::google::protobuf::internal::kEmptyString) {
    ordstatus_ = new ::std::string;
  }
  ordstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_ordstatus() {
  set_has_ordstatus();
  if (ordstatus_ == &::google::protobuf::internal::kEmptyString) {
    ordstatus_ = new ::std::string;
  }
  return ordstatus_;
}
inline ::std::string* ExecutionReportData::release_ordstatus() {
  clear_has_ordstatus();
  if (ordstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ordstatus_;
    ordstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Symbol = 18;
inline bool ExecutionReportData::has_symbol() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ExecutionReportData::set_has_symbol() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ExecutionReportData::clear_has_symbol() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ExecutionReportData::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& ExecutionReportData::symbol() const {
  return *symbol_;
}
inline void ExecutionReportData::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void ExecutionReportData::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void ExecutionReportData::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* ExecutionReportData::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Side = 19;
inline bool ExecutionReportData::has_side() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ExecutionReportData::set_has_side() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ExecutionReportData::clear_has_side() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ExecutionReportData::clear_side() {
  if (side_ != &::google::protobuf::internal::kEmptyString) {
    side_->clear();
  }
  clear_has_side();
}
inline const ::std::string& ExecutionReportData::side() const {
  return *side_;
}
inline void ExecutionReportData::set_side(const ::std::string& value) {
  set_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    side_ = new ::std::string;
  }
  side_->assign(value);
}
inline void ExecutionReportData::set_side(const char* value) {
  set_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    side_ = new ::std::string;
  }
  side_->assign(value);
}
inline void ExecutionReportData::set_side(const char* value, size_t size) {
  set_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    side_ = new ::std::string;
  }
  side_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_side() {
  set_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    side_ = new ::std::string;
  }
  return side_;
}
inline ::std::string* ExecutionReportData::release_side() {
  clear_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = side_;
    side_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string TimeInForce = 20;
inline bool ExecutionReportData::has_timeinforce() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ExecutionReportData::set_has_timeinforce() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ExecutionReportData::clear_has_timeinforce() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ExecutionReportData::clear_timeinforce() {
  if (timeinforce_ != &::google::protobuf::internal::kEmptyString) {
    timeinforce_->clear();
  }
  clear_has_timeinforce();
}
inline const ::std::string& ExecutionReportData::timeinforce() const {
  return *timeinforce_;
}
inline void ExecutionReportData::set_timeinforce(const ::std::string& value) {
  set_has_timeinforce();
  if (timeinforce_ == &::google::protobuf::internal::kEmptyString) {
    timeinforce_ = new ::std::string;
  }
  timeinforce_->assign(value);
}
inline void ExecutionReportData::set_timeinforce(const char* value) {
  set_has_timeinforce();
  if (timeinforce_ == &::google::protobuf::internal::kEmptyString) {
    timeinforce_ = new ::std::string;
  }
  timeinforce_->assign(value);
}
inline void ExecutionReportData::set_timeinforce(const char* value, size_t size) {
  set_has_timeinforce();
  if (timeinforce_ == &::google::protobuf::internal::kEmptyString) {
    timeinforce_ = new ::std::string;
  }
  timeinforce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_timeinforce() {
  set_has_timeinforce();
  if (timeinforce_ == &::google::protobuf::internal::kEmptyString) {
    timeinforce_ = new ::std::string;
  }
  return timeinforce_;
}
inline ::std::string* ExecutionReportData::release_timeinforce() {
  clear_has_timeinforce();
  if (timeinforce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timeinforce_;
    timeinforce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string MaturityMonthYear = 21;
inline bool ExecutionReportData::has_maturitymonthyear() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ExecutionReportData::set_has_maturitymonthyear() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ExecutionReportData::clear_has_maturitymonthyear() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ExecutionReportData::clear_maturitymonthyear() {
  if (maturitymonthyear_ != &::google::protobuf::internal::kEmptyString) {
    maturitymonthyear_->clear();
  }
  clear_has_maturitymonthyear();
}
inline const ::std::string& ExecutionReportData::maturitymonthyear() const {
  return *maturitymonthyear_;
}
inline void ExecutionReportData::set_maturitymonthyear(const ::std::string& value) {
  set_has_maturitymonthyear();
  if (maturitymonthyear_ == &::google::protobuf::internal::kEmptyString) {
    maturitymonthyear_ = new ::std::string;
  }
  maturitymonthyear_->assign(value);
}
inline void ExecutionReportData::set_maturitymonthyear(const char* value) {
  set_has_maturitymonthyear();
  if (maturitymonthyear_ == &::google::protobuf::internal::kEmptyString) {
    maturitymonthyear_ = new ::std::string;
  }
  maturitymonthyear_->assign(value);
}
inline void ExecutionReportData::set_maturitymonthyear(const char* value, size_t size) {
  set_has_maturitymonthyear();
  if (maturitymonthyear_ == &::google::protobuf::internal::kEmptyString) {
    maturitymonthyear_ = new ::std::string;
  }
  maturitymonthyear_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_maturitymonthyear() {
  set_has_maturitymonthyear();
  if (maturitymonthyear_ == &::google::protobuf::internal::kEmptyString) {
    maturitymonthyear_ = new ::std::string;
  }
  return maturitymonthyear_;
}
inline ::std::string* ExecutionReportData::release_maturitymonthyear() {
  clear_has_maturitymonthyear();
  if (maturitymonthyear_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = maturitymonthyear_;
    maturitymonthyear_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string TransactTime = 22;
inline bool ExecutionReportData::has_transacttime() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ExecutionReportData::set_has_transacttime() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ExecutionReportData::clear_has_transacttime() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ExecutionReportData::clear_transacttime() {
  if (transacttime_ != &::google::protobuf::internal::kEmptyString) {
    transacttime_->clear();
  }
  clear_has_transacttime();
}
inline const ::std::string& ExecutionReportData::transacttime() const {
  return *transacttime_;
}
inline void ExecutionReportData::set_transacttime(const ::std::string& value) {
  set_has_transacttime();
  if (transacttime_ == &::google::protobuf::internal::kEmptyString) {
    transacttime_ = new ::std::string;
  }
  transacttime_->assign(value);
}
inline void ExecutionReportData::set_transacttime(const char* value) {
  set_has_transacttime();
  if (transacttime_ == &::google::protobuf::internal::kEmptyString) {
    transacttime_ = new ::std::string;
  }
  transacttime_->assign(value);
}
inline void ExecutionReportData::set_transacttime(const char* value, size_t size) {
  set_has_transacttime();
  if (transacttime_ == &::google::protobuf::internal::kEmptyString) {
    transacttime_ = new ::std::string;
  }
  transacttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_transacttime() {
  set_has_transacttime();
  if (transacttime_ == &::google::protobuf::internal::kEmptyString) {
    transacttime_ = new ::std::string;
  }
  return transacttime_;
}
inline ::std::string* ExecutionReportData::release_transacttime() {
  clear_has_transacttime();
  if (transacttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transacttime_;
    transacttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string Text = 23;
inline bool ExecutionReportData::has_text() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ExecutionReportData::set_has_text() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ExecutionReportData::clear_has_text() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ExecutionReportData::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& ExecutionReportData::text() const {
  return *text_;
}
inline void ExecutionReportData::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ExecutionReportData::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ExecutionReportData::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* ExecutionReportData::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string CumQty = 24 [default = "0"];
inline bool ExecutionReportData::has_cumqty() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ExecutionReportData::set_has_cumqty() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ExecutionReportData::clear_has_cumqty() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ExecutionReportData::clear_cumqty() {
  if (cumqty_ != &_default_cumqty_) {
    cumqty_->assign(_default_cumqty_);
  }
  clear_has_cumqty();
}
inline const ::std::string& ExecutionReportData::cumqty() const {
  return *cumqty_;
}
inline void ExecutionReportData::set_cumqty(const ::std::string& value) {
  set_has_cumqty();
  if (cumqty_ == &_default_cumqty_) {
    cumqty_ = new ::std::string;
  }
  cumqty_->assign(value);
}
inline void ExecutionReportData::set_cumqty(const char* value) {
  set_has_cumqty();
  if (cumqty_ == &_default_cumqty_) {
    cumqty_ = new ::std::string;
  }
  cumqty_->assign(value);
}
inline void ExecutionReportData::set_cumqty(const char* value, size_t size) {
  set_has_cumqty();
  if (cumqty_ == &_default_cumqty_) {
    cumqty_ = new ::std::string;
  }
  cumqty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_cumqty() {
  set_has_cumqty();
  if (cumqty_ == &_default_cumqty_) {
    cumqty_ = new ::std::string(_default_cumqty_);
  }
  return cumqty_;
}
inline ::std::string* ExecutionReportData::release_cumqty() {
  clear_has_cumqty();
  if (cumqty_ == &_default_cumqty_) {
    return NULL;
  } else {
    ::std::string* temp = cumqty_;
    cumqty_ = const_cast< ::std::string*>(&_default_cumqty_);
    return temp;
  }
}

// optional string OrderQty = 25 [default = "0"];
inline bool ExecutionReportData::has_orderqty() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ExecutionReportData::set_has_orderqty() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ExecutionReportData::clear_has_orderqty() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ExecutionReportData::clear_orderqty() {
  if (orderqty_ != &_default_orderqty_) {
    orderqty_->assign(_default_orderqty_);
  }
  clear_has_orderqty();
}
inline const ::std::string& ExecutionReportData::orderqty() const {
  return *orderqty_;
}
inline void ExecutionReportData::set_orderqty(const ::std::string& value) {
  set_has_orderqty();
  if (orderqty_ == &_default_orderqty_) {
    orderqty_ = new ::std::string;
  }
  orderqty_->assign(value);
}
inline void ExecutionReportData::set_orderqty(const char* value) {
  set_has_orderqty();
  if (orderqty_ == &_default_orderqty_) {
    orderqty_ = new ::std::string;
  }
  orderqty_->assign(value);
}
inline void ExecutionReportData::set_orderqty(const char* value, size_t size) {
  set_has_orderqty();
  if (orderqty_ == &_default_orderqty_) {
    orderqty_ = new ::std::string;
  }
  orderqty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_orderqty() {
  set_has_orderqty();
  if (orderqty_ == &_default_orderqty_) {
    orderqty_ = new ::std::string(_default_orderqty_);
  }
  return orderqty_;
}
inline ::std::string* ExecutionReportData::release_orderqty() {
  clear_has_orderqty();
  if (orderqty_ == &_default_orderqty_) {
    return NULL;
  } else {
    ::std::string* temp = orderqty_;
    orderqty_ = const_cast< ::std::string*>(&_default_orderqty_);
    return temp;
  }
}

// optional string LeavesQty = 26 [default = "0"];
inline bool ExecutionReportData::has_leavesqty() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ExecutionReportData::set_has_leavesqty() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ExecutionReportData::clear_has_leavesqty() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ExecutionReportData::clear_leavesqty() {
  if (leavesqty_ != &_default_leavesqty_) {
    leavesqty_->assign(_default_leavesqty_);
  }
  clear_has_leavesqty();
}
inline const ::std::string& ExecutionReportData::leavesqty() const {
  return *leavesqty_;
}
inline void ExecutionReportData::set_leavesqty(const ::std::string& value) {
  set_has_leavesqty();
  if (leavesqty_ == &_default_leavesqty_) {
    leavesqty_ = new ::std::string;
  }
  leavesqty_->assign(value);
}
inline void ExecutionReportData::set_leavesqty(const char* value) {
  set_has_leavesqty();
  if (leavesqty_ == &_default_leavesqty_) {
    leavesqty_ = new ::std::string;
  }
  leavesqty_->assign(value);
}
inline void ExecutionReportData::set_leavesqty(const char* value, size_t size) {
  set_has_leavesqty();
  if (leavesqty_ == &_default_leavesqty_) {
    leavesqty_ = new ::std::string;
  }
  leavesqty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_leavesqty() {
  set_has_leavesqty();
  if (leavesqty_ == &_default_leavesqty_) {
    leavesqty_ = new ::std::string(_default_leavesqty_);
  }
  return leavesqty_;
}
inline ::std::string* ExecutionReportData::release_leavesqty() {
  clear_has_leavesqty();
  if (leavesqty_ == &_default_leavesqty_) {
    return NULL;
  } else {
    ::std::string* temp = leavesqty_;
    leavesqty_ = const_cast< ::std::string*>(&_default_leavesqty_);
    return temp;
  }
}

// optional string LastShares = 27 [default = "0"];
inline bool ExecutionReportData::has_lastshares() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ExecutionReportData::set_has_lastshares() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ExecutionReportData::clear_has_lastshares() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ExecutionReportData::clear_lastshares() {
  if (lastshares_ != &_default_lastshares_) {
    lastshares_->assign(_default_lastshares_);
  }
  clear_has_lastshares();
}
inline const ::std::string& ExecutionReportData::lastshares() const {
  return *lastshares_;
}
inline void ExecutionReportData::set_lastshares(const ::std::string& value) {
  set_has_lastshares();
  if (lastshares_ == &_default_lastshares_) {
    lastshares_ = new ::std::string;
  }
  lastshares_->assign(value);
}
inline void ExecutionReportData::set_lastshares(const char* value) {
  set_has_lastshares();
  if (lastshares_ == &_default_lastshares_) {
    lastshares_ = new ::std::string;
  }
  lastshares_->assign(value);
}
inline void ExecutionReportData::set_lastshares(const char* value, size_t size) {
  set_has_lastshares();
  if (lastshares_ == &_default_lastshares_) {
    lastshares_ = new ::std::string;
  }
  lastshares_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_lastshares() {
  set_has_lastshares();
  if (lastshares_ == &_default_lastshares_) {
    lastshares_ = new ::std::string(_default_lastshares_);
  }
  return lastshares_;
}
inline ::std::string* ExecutionReportData::release_lastshares() {
  clear_has_lastshares();
  if (lastshares_ == &_default_lastshares_) {
    return NULL;
  } else {
    ::std::string* temp = lastshares_;
    lastshares_ = const_cast< ::std::string*>(&_default_lastshares_);
    return temp;
  }
}

// optional string Price = 28 [default = "0"];
inline bool ExecutionReportData::has_price() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ExecutionReportData::set_has_price() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ExecutionReportData::clear_has_price() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ExecutionReportData::clear_price() {
  if (price_ != &_default_price_) {
    price_->assign(_default_price_);
  }
  clear_has_price();
}
inline const ::std::string& ExecutionReportData::price() const {
  return *price_;
}
inline void ExecutionReportData::set_price(const ::std::string& value) {
  set_has_price();
  if (price_ == &_default_price_) {
    price_ = new ::std::string;
  }
  price_->assign(value);
}
inline void ExecutionReportData::set_price(const char* value) {
  set_has_price();
  if (price_ == &_default_price_) {
    price_ = new ::std::string;
  }
  price_->assign(value);
}
inline void ExecutionReportData::set_price(const char* value, size_t size) {
  set_has_price();
  if (price_ == &_default_price_) {
    price_ = new ::std::string;
  }
  price_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_price() {
  set_has_price();
  if (price_ == &_default_price_) {
    price_ = new ::std::string(_default_price_);
  }
  return price_;
}
inline ::std::string* ExecutionReportData::release_price() {
  clear_has_price();
  if (price_ == &_default_price_) {
    return NULL;
  } else {
    ::std::string* temp = price_;
    price_ = const_cast< ::std::string*>(&_default_price_);
    return temp;
  }
}

// optional string AvgPx = 29 [default = "0"];
inline bool ExecutionReportData::has_avgpx() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ExecutionReportData::set_has_avgpx() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ExecutionReportData::clear_has_avgpx() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ExecutionReportData::clear_avgpx() {
  if (avgpx_ != &_default_avgpx_) {
    avgpx_->assign(_default_avgpx_);
  }
  clear_has_avgpx();
}
inline const ::std::string& ExecutionReportData::avgpx() const {
  return *avgpx_;
}
inline void ExecutionReportData::set_avgpx(const ::std::string& value) {
  set_has_avgpx();
  if (avgpx_ == &_default_avgpx_) {
    avgpx_ = new ::std::string;
  }
  avgpx_->assign(value);
}
inline void ExecutionReportData::set_avgpx(const char* value) {
  set_has_avgpx();
  if (avgpx_ == &_default_avgpx_) {
    avgpx_ = new ::std::string;
  }
  avgpx_->assign(value);
}
inline void ExecutionReportData::set_avgpx(const char* value, size_t size) {
  set_has_avgpx();
  if (avgpx_ == &_default_avgpx_) {
    avgpx_ = new ::std::string;
  }
  avgpx_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_avgpx() {
  set_has_avgpx();
  if (avgpx_ == &_default_avgpx_) {
    avgpx_ = new ::std::string(_default_avgpx_);
  }
  return avgpx_;
}
inline ::std::string* ExecutionReportData::release_avgpx() {
  clear_has_avgpx();
  if (avgpx_ == &_default_avgpx_) {
    return NULL;
  } else {
    ::std::string* temp = avgpx_;
    avgpx_ = const_cast< ::std::string*>(&_default_avgpx_);
    return temp;
  }
}

// optional string LastPx = 30 [default = "0"];
inline bool ExecutionReportData::has_lastpx() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ExecutionReportData::set_has_lastpx() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ExecutionReportData::clear_has_lastpx() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ExecutionReportData::clear_lastpx() {
  if (lastpx_ != &_default_lastpx_) {
    lastpx_->assign(_default_lastpx_);
  }
  clear_has_lastpx();
}
inline const ::std::string& ExecutionReportData::lastpx() const {
  return *lastpx_;
}
inline void ExecutionReportData::set_lastpx(const ::std::string& value) {
  set_has_lastpx();
  if (lastpx_ == &_default_lastpx_) {
    lastpx_ = new ::std::string;
  }
  lastpx_->assign(value);
}
inline void ExecutionReportData::set_lastpx(const char* value) {
  set_has_lastpx();
  if (lastpx_ == &_default_lastpx_) {
    lastpx_ = new ::std::string;
  }
  lastpx_->assign(value);
}
inline void ExecutionReportData::set_lastpx(const char* value, size_t size) {
  set_has_lastpx();
  if (lastpx_ == &_default_lastpx_) {
    lastpx_ = new ::std::string;
  }
  lastpx_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_lastpx() {
  set_has_lastpx();
  if (lastpx_ == &_default_lastpx_) {
    lastpx_ = new ::std::string(_default_lastpx_);
  }
  return lastpx_;
}
inline ::std::string* ExecutionReportData::release_lastpx() {
  clear_has_lastpx();
  if (lastpx_ == &_default_lastpx_) {
    return NULL;
  } else {
    ::std::string* temp = lastpx_;
    lastpx_ = const_cast< ::std::string*>(&_default_lastpx_);
    return temp;
  }
}

// optional string StopPx = 31 [default = "0"];
inline bool ExecutionReportData::has_stoppx() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ExecutionReportData::set_has_stoppx() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ExecutionReportData::clear_has_stoppx() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ExecutionReportData::clear_stoppx() {
  if (stoppx_ != &_default_stoppx_) {
    stoppx_->assign(_default_stoppx_);
  }
  clear_has_stoppx();
}
inline const ::std::string& ExecutionReportData::stoppx() const {
  return *stoppx_;
}
inline void ExecutionReportData::set_stoppx(const ::std::string& value) {
  set_has_stoppx();
  if (stoppx_ == &_default_stoppx_) {
    stoppx_ = new ::std::string;
  }
  stoppx_->assign(value);
}
inline void ExecutionReportData::set_stoppx(const char* value) {
  set_has_stoppx();
  if (stoppx_ == &_default_stoppx_) {
    stoppx_ = new ::std::string;
  }
  stoppx_->assign(value);
}
inline void ExecutionReportData::set_stoppx(const char* value, size_t size) {
  set_has_stoppx();
  if (stoppx_ == &_default_stoppx_) {
    stoppx_ = new ::std::string;
  }
  stoppx_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReportData::mutable_stoppx() {
  set_has_stoppx();
  if (stoppx_ == &_default_stoppx_) {
    stoppx_ = new ::std::string(_default_stoppx_);
  }
  return stoppx_;
}
inline ::std::string* ExecutionReportData::release_stoppx() {
  clear_has_stoppx();
  if (stoppx_ == &_default_stoppx_) {
    return NULL;
  } else {
    ::std::string* temp = stoppx_;
    stoppx_ = const_cast< ::std::string*>(&_default_stoppx_);
    return temp;
  }
}

// -------------------------------------------------------------------

// DraftOrderMessage

// optional .quantmodel.DraftOrderData draft_order_data = 1;
inline bool DraftOrderMessage::has_draft_order_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DraftOrderMessage::set_has_draft_order_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DraftOrderMessage::clear_has_draft_order_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DraftOrderMessage::clear_draft_order_data() {
  if (draft_order_data_ != NULL) draft_order_data_->::quantmodel::DraftOrderData::Clear();
  clear_has_draft_order_data();
}
inline const ::quantmodel::DraftOrderData& DraftOrderMessage::draft_order_data() const {
  return draft_order_data_ != NULL ? *draft_order_data_ : *default_instance_->draft_order_data_;
}
inline ::quantmodel::DraftOrderData* DraftOrderMessage::mutable_draft_order_data() {
  set_has_draft_order_data();
  if (draft_order_data_ == NULL) draft_order_data_ = new ::quantmodel::DraftOrderData;
  return draft_order_data_;
}
inline ::quantmodel::DraftOrderData* DraftOrderMessage::release_draft_order_data() {
  clear_has_draft_order_data();
  ::quantmodel::DraftOrderData* temp = draft_order_data_;
  draft_order_data_ = NULL;
  return temp;
}

// repeated .quantmodel.DraftAllocationData draft_allocation_data = 2;
inline int DraftOrderMessage::draft_allocation_data_size() const {
  return draft_allocation_data_.size();
}
inline void DraftOrderMessage::clear_draft_allocation_data() {
  draft_allocation_data_.Clear();
}
inline const ::quantmodel::DraftAllocationData& DraftOrderMessage::draft_allocation_data(int index) const {
  return draft_allocation_data_.Get(index);
}
inline ::quantmodel::DraftAllocationData* DraftOrderMessage::mutable_draft_allocation_data(int index) {
  return draft_allocation_data_.Mutable(index);
}
inline ::quantmodel::DraftAllocationData* DraftOrderMessage::add_draft_allocation_data() {
  return draft_allocation_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::DraftAllocationData >&
DraftOrderMessage::draft_allocation_data() const {
  return draft_allocation_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::DraftAllocationData >*
DraftOrderMessage::mutable_draft_allocation_data() {
  return &draft_allocation_data_;
}

// -------------------------------------------------------------------

// OrderMessage

// optional .quantmodel.OrderData order_data = 1;
inline bool OrderMessage::has_order_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderMessage::set_has_order_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderMessage::clear_has_order_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderMessage::clear_order_data() {
  if (order_data_ != NULL) order_data_->::quantmodel::OrderData::Clear();
  clear_has_order_data();
}
inline const ::quantmodel::OrderData& OrderMessage::order_data() const {
  return order_data_ != NULL ? *order_data_ : *default_instance_->order_data_;
}
inline ::quantmodel::OrderData* OrderMessage::mutable_order_data() {
  set_has_order_data();
  if (order_data_ == NULL) order_data_ = new ::quantmodel::OrderData;
  return order_data_;
}
inline ::quantmodel::OrderData* OrderMessage::release_order_data() {
  clear_has_order_data();
  ::quantmodel::OrderData* temp = order_data_;
  order_data_ = NULL;
  return temp;
}

// repeated .quantmodel.AllocationData allocation_data = 2;
inline int OrderMessage::allocation_data_size() const {
  return allocation_data_.size();
}
inline void OrderMessage::clear_allocation_data() {
  allocation_data_.Clear();
}
inline const ::quantmodel::AllocationData& OrderMessage::allocation_data(int index) const {
  return allocation_data_.Get(index);
}
inline ::quantmodel::AllocationData* OrderMessage::mutable_allocation_data(int index) {
  return allocation_data_.Mutable(index);
}
inline ::quantmodel::AllocationData* OrderMessage::add_allocation_data() {
  return allocation_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::AllocationData >&
OrderMessage::allocation_data() const {
  return allocation_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::AllocationData >*
OrderMessage::mutable_allocation_data() {
  return &allocation_data_;
}

// repeated .quantmodel.ReleaseData release_data = 3;
inline int OrderMessage::release_data_size() const {
  return release_data_.size();
}
inline void OrderMessage::clear_release_data() {
  release_data_.Clear();
}
inline const ::quantmodel::ReleaseData& OrderMessage::release_data(int index) const {
  return release_data_.Get(index);
}
inline ::quantmodel::ReleaseData* OrderMessage::mutable_release_data(int index) {
  return release_data_.Mutable(index);
}
inline ::quantmodel::ReleaseData* OrderMessage::add_release_data() {
  return release_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::ReleaseData >&
OrderMessage::release_data() const {
  return release_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::ReleaseData >*
OrderMessage::mutable_release_data() {
  return &release_data_;
}

// repeated .quantmodel.ExecutionData execution_data = 4;
inline int OrderMessage::execution_data_size() const {
  return execution_data_.size();
}
inline void OrderMessage::clear_execution_data() {
  execution_data_.Clear();
}
inline const ::quantmodel::ExecutionData& OrderMessage::execution_data(int index) const {
  return execution_data_.Get(index);
}
inline ::quantmodel::ExecutionData* OrderMessage::mutable_execution_data(int index) {
  return execution_data_.Mutable(index);
}
inline ::quantmodel::ExecutionData* OrderMessage::add_execution_data() {
  return execution_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::ExecutionData >&
OrderMessage::execution_data() const {
  return execution_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::ExecutionData >*
OrderMessage::mutable_execution_data() {
  return &execution_data_;
}

// -------------------------------------------------------------------

// DatabaseEngineRequest_Query

// optional .quantmodel.DatabaseEngineRequest.QueryType type = 1;
inline bool DatabaseEngineRequest_Query::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatabaseEngineRequest_Query::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatabaseEngineRequest_Query::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatabaseEngineRequest_Query::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::quantmodel::DatabaseEngineRequest_QueryType DatabaseEngineRequest_Query::type() const {
  return static_cast< ::quantmodel::DatabaseEngineRequest_QueryType >(type_);
}
inline void DatabaseEngineRequest_Query::set_type(::quantmodel::DatabaseEngineRequest_QueryType value) {
  GOOGLE_DCHECK(::quantmodel::DatabaseEngineRequest_QueryType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string query_id = 2;
inline bool DatabaseEngineRequest_Query::has_query_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatabaseEngineRequest_Query::set_has_query_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatabaseEngineRequest_Query::clear_has_query_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatabaseEngineRequest_Query::clear_query_id() {
  if (query_id_ != &::google::protobuf::internal::kEmptyString) {
    query_id_->clear();
  }
  clear_has_query_id();
}
inline const ::std::string& DatabaseEngineRequest_Query::query_id() const {
  return *query_id_;
}
inline void DatabaseEngineRequest_Query::set_query_id(const ::std::string& value) {
  set_has_query_id();
  if (query_id_ == &::google::protobuf::internal::kEmptyString) {
    query_id_ = new ::std::string;
  }
  query_id_->assign(value);
}
inline void DatabaseEngineRequest_Query::set_query_id(const char* value) {
  set_has_query_id();
  if (query_id_ == &::google::protobuf::internal::kEmptyString) {
    query_id_ = new ::std::string;
  }
  query_id_->assign(value);
}
inline void DatabaseEngineRequest_Query::set_query_id(const char* value, size_t size) {
  set_has_query_id();
  if (query_id_ == &::google::protobuf::internal::kEmptyString) {
    query_id_ = new ::std::string;
  }
  query_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatabaseEngineRequest_Query::mutable_query_id() {
  set_has_query_id();
  if (query_id_ == &::google::protobuf::internal::kEmptyString) {
    query_id_ = new ::std::string;
  }
  return query_id_;
}
inline ::std::string* DatabaseEngineRequest_Query::release_query_id() {
  clear_has_query_id();
  if (query_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = query_id_;
    query_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string query_str = 3;
inline bool DatabaseEngineRequest_Query::has_query_str() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DatabaseEngineRequest_Query::set_has_query_str() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DatabaseEngineRequest_Query::clear_has_query_str() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DatabaseEngineRequest_Query::clear_query_str() {
  if (query_str_ != &::google::protobuf::internal::kEmptyString) {
    query_str_->clear();
  }
  clear_has_query_str();
}
inline const ::std::string& DatabaseEngineRequest_Query::query_str() const {
  return *query_str_;
}
inline void DatabaseEngineRequest_Query::set_query_str(const ::std::string& value) {
  set_has_query_str();
  if (query_str_ == &::google::protobuf::internal::kEmptyString) {
    query_str_ = new ::std::string;
  }
  query_str_->assign(value);
}
inline void DatabaseEngineRequest_Query::set_query_str(const char* value) {
  set_has_query_str();
  if (query_str_ == &::google::protobuf::internal::kEmptyString) {
    query_str_ = new ::std::string;
  }
  query_str_->assign(value);
}
inline void DatabaseEngineRequest_Query::set_query_str(const char* value, size_t size) {
  set_has_query_str();
  if (query_str_ == &::google::protobuf::internal::kEmptyString) {
    query_str_ = new ::std::string;
  }
  query_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatabaseEngineRequest_Query::mutable_query_str() {
  set_has_query_str();
  if (query_str_ == &::google::protobuf::internal::kEmptyString) {
    query_str_ = new ::std::string;
  }
  return query_str_;
}
inline ::std::string* DatabaseEngineRequest_Query::release_query_str() {
  clear_has_query_str();
  if (query_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = query_str_;
    query_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DatabaseEngineRequest

// optional string request_id = 1;
inline bool DatabaseEngineRequest::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatabaseEngineRequest::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatabaseEngineRequest::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatabaseEngineRequest::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& DatabaseEngineRequest::request_id() const {
  return *request_id_;
}
inline void DatabaseEngineRequest::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void DatabaseEngineRequest::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void DatabaseEngineRequest::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatabaseEngineRequest::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* DatabaseEngineRequest::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 2;
inline bool DatabaseEngineRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatabaseEngineRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatabaseEngineRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatabaseEngineRequest::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& DatabaseEngineRequest::timestamp() const {
  return *timestamp_;
}
inline void DatabaseEngineRequest::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void DatabaseEngineRequest::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void DatabaseEngineRequest::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatabaseEngineRequest::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* DatabaseEngineRequest::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .quantmodel.DatabaseEngineRequest.Query query = 3;
inline int DatabaseEngineRequest::query_size() const {
  return query_.size();
}
inline void DatabaseEngineRequest::clear_query() {
  query_.Clear();
}
inline const ::quantmodel::DatabaseEngineRequest_Query& DatabaseEngineRequest::query(int index) const {
  return query_.Get(index);
}
inline ::quantmodel::DatabaseEngineRequest_Query* DatabaseEngineRequest::mutable_query(int index) {
  return query_.Mutable(index);
}
inline ::quantmodel::DatabaseEngineRequest_Query* DatabaseEngineRequest::add_query() {
  return query_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineRequest_Query >&
DatabaseEngineRequest::query() const {
  return query_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineRequest_Query >*
DatabaseEngineRequest::mutable_query() {
  return &query_;
}

// -------------------------------------------------------------------

// DatabaseEngineResponse_ResultSet_Row_Column

// optional int32 column_id = 1;
inline bool DatabaseEngineResponse_ResultSet_Row_Column::has_column_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::set_has_column_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::clear_has_column_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::clear_column_id() {
  column_id_ = 0;
  clear_has_column_id();
}
inline ::google::protobuf::int32 DatabaseEngineResponse_ResultSet_Row_Column::column_id() const {
  return column_id_;
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::set_column_id(::google::protobuf::int32 value) {
  set_has_column_id();
  column_id_ = value;
}

// optional string name = 2;
inline bool DatabaseEngineResponse_ResultSet_Row_Column::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DatabaseEngineResponse_ResultSet_Row_Column::name() const {
  return *name_;
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatabaseEngineResponse_ResultSet_Row_Column::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* DatabaseEngineResponse_ResultSet_Row_Column::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string value = 3;
inline bool DatabaseEngineResponse_ResultSet_Row_Column::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& DatabaseEngineResponse_ResultSet_Row_Column::value() const {
  return *value_;
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void DatabaseEngineResponse_ResultSet_Row_Column::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatabaseEngineResponse_ResultSet_Row_Column::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* DatabaseEngineResponse_ResultSet_Row_Column::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// DatabaseEngineResponse_ResultSet_Row

// optional int32 row_id = 1;
inline bool DatabaseEngineResponse_ResultSet_Row::has_row_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatabaseEngineResponse_ResultSet_Row::set_has_row_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatabaseEngineResponse_ResultSet_Row::clear_has_row_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatabaseEngineResponse_ResultSet_Row::clear_row_id() {
  row_id_ = 0;
  clear_has_row_id();
}
inline ::google::protobuf::int32 DatabaseEngineResponse_ResultSet_Row::row_id() const {
  return row_id_;
}
inline void DatabaseEngineResponse_ResultSet_Row::set_row_id(::google::protobuf::int32 value) {
  set_has_row_id();
  row_id_ = value;
}

// repeated .quantmodel.DatabaseEngineResponse.ResultSet.Row.Column column = 2;
inline int DatabaseEngineResponse_ResultSet_Row::column_size() const {
  return column_.size();
}
inline void DatabaseEngineResponse_ResultSet_Row::clear_column() {
  column_.Clear();
}
inline const ::quantmodel::DatabaseEngineResponse_ResultSet_Row_Column& DatabaseEngineResponse_ResultSet_Row::column(int index) const {
  return column_.Get(index);
}
inline ::quantmodel::DatabaseEngineResponse_ResultSet_Row_Column* DatabaseEngineResponse_ResultSet_Row::mutable_column(int index) {
  return column_.Mutable(index);
}
inline ::quantmodel::DatabaseEngineResponse_ResultSet_Row_Column* DatabaseEngineResponse_ResultSet_Row::add_column() {
  return column_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet_Row_Column >&
DatabaseEngineResponse_ResultSet_Row::column() const {
  return column_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet_Row_Column >*
DatabaseEngineResponse_ResultSet_Row::mutable_column() {
  return &column_;
}

// -------------------------------------------------------------------

// DatabaseEngineResponse_ResultSet

// optional string query_id = 1;
inline bool DatabaseEngineResponse_ResultSet::has_query_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatabaseEngineResponse_ResultSet::set_has_query_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatabaseEngineResponse_ResultSet::clear_has_query_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatabaseEngineResponse_ResultSet::clear_query_id() {
  if (query_id_ != &::google::protobuf::internal::kEmptyString) {
    query_id_->clear();
  }
  clear_has_query_id();
}
inline const ::std::string& DatabaseEngineResponse_ResultSet::query_id() const {
  return *query_id_;
}
inline void DatabaseEngineResponse_ResultSet::set_query_id(const ::std::string& value) {
  set_has_query_id();
  if (query_id_ == &::google::protobuf::internal::kEmptyString) {
    query_id_ = new ::std::string;
  }
  query_id_->assign(value);
}
inline void DatabaseEngineResponse_ResultSet::set_query_id(const char* value) {
  set_has_query_id();
  if (query_id_ == &::google::protobuf::internal::kEmptyString) {
    query_id_ = new ::std::string;
  }
  query_id_->assign(value);
}
inline void DatabaseEngineResponse_ResultSet::set_query_id(const char* value, size_t size) {
  set_has_query_id();
  if (query_id_ == &::google::protobuf::internal::kEmptyString) {
    query_id_ = new ::std::string;
  }
  query_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatabaseEngineResponse_ResultSet::mutable_query_id() {
  set_has_query_id();
  if (query_id_ == &::google::protobuf::internal::kEmptyString) {
    query_id_ = new ::std::string;
  }
  return query_id_;
}
inline ::std::string* DatabaseEngineResponse_ResultSet::release_query_id() {
  clear_has_query_id();
  if (query_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = query_id_;
    query_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .quantmodel.DatabaseEngineResponse.ResultSet.Row row = 2;
inline int DatabaseEngineResponse_ResultSet::row_size() const {
  return row_.size();
}
inline void DatabaseEngineResponse_ResultSet::clear_row() {
  row_.Clear();
}
inline const ::quantmodel::DatabaseEngineResponse_ResultSet_Row& DatabaseEngineResponse_ResultSet::row(int index) const {
  return row_.Get(index);
}
inline ::quantmodel::DatabaseEngineResponse_ResultSet_Row* DatabaseEngineResponse_ResultSet::mutable_row(int index) {
  return row_.Mutable(index);
}
inline ::quantmodel::DatabaseEngineResponse_ResultSet_Row* DatabaseEngineResponse_ResultSet::add_row() {
  return row_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet_Row >&
DatabaseEngineResponse_ResultSet::row() const {
  return row_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet_Row >*
DatabaseEngineResponse_ResultSet::mutable_row() {
  return &row_;
}

// -------------------------------------------------------------------

// DatabaseEngineResponse

// optional string response_id = 1;
inline bool DatabaseEngineResponse::has_response_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatabaseEngineResponse::set_has_response_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatabaseEngineResponse::clear_has_response_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatabaseEngineResponse::clear_response_id() {
  if (response_id_ != &::google::protobuf::internal::kEmptyString) {
    response_id_->clear();
  }
  clear_has_response_id();
}
inline const ::std::string& DatabaseEngineResponse::response_id() const {
  return *response_id_;
}
inline void DatabaseEngineResponse::set_response_id(const ::std::string& value) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(value);
}
inline void DatabaseEngineResponse::set_response_id(const char* value) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(value);
}
inline void DatabaseEngineResponse::set_response_id(const char* value, size_t size) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatabaseEngineResponse::mutable_response_id() {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  return response_id_;
}
inline ::std::string* DatabaseEngineResponse::release_response_id() {
  clear_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_id_;
    response_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string request_id = 2;
inline bool DatabaseEngineResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatabaseEngineResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatabaseEngineResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatabaseEngineResponse::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& DatabaseEngineResponse::request_id() const {
  return *request_id_;
}
inline void DatabaseEngineResponse::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void DatabaseEngineResponse::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void DatabaseEngineResponse::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatabaseEngineResponse::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* DatabaseEngineResponse::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 3;
inline bool DatabaseEngineResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DatabaseEngineResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DatabaseEngineResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DatabaseEngineResponse::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& DatabaseEngineResponse::timestamp() const {
  return *timestamp_;
}
inline void DatabaseEngineResponse::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void DatabaseEngineResponse::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void DatabaseEngineResponse::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DatabaseEngineResponse::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* DatabaseEngineResponse::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .quantmodel.DatabaseEngineResponse.ResultSet result_set = 4;
inline int DatabaseEngineResponse::result_set_size() const {
  return result_set_.size();
}
inline void DatabaseEngineResponse::clear_result_set() {
  result_set_.Clear();
}
inline const ::quantmodel::DatabaseEngineResponse_ResultSet& DatabaseEngineResponse::result_set(int index) const {
  return result_set_.Get(index);
}
inline ::quantmodel::DatabaseEngineResponse_ResultSet* DatabaseEngineResponse::mutable_result_set(int index) {
  return result_set_.Mutable(index);
}
inline ::quantmodel::DatabaseEngineResponse_ResultSet* DatabaseEngineResponse::add_result_set() {
  return result_set_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet >&
DatabaseEngineResponse::result_set() const {
  return result_set_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::DatabaseEngineResponse_ResultSet >*
DatabaseEngineResponse::mutable_result_set() {
  return &result_set_;
}

// -------------------------------------------------------------------

// DealingEngineRequest

// optional string request_id = 1;
inline bool DealingEngineRequest::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DealingEngineRequest::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DealingEngineRequest::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DealingEngineRequest::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& DealingEngineRequest::request_id() const {
  return *request_id_;
}
inline void DealingEngineRequest::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void DealingEngineRequest::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void DealingEngineRequest::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DealingEngineRequest::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* DealingEngineRequest::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 2;
inline bool DealingEngineRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DealingEngineRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DealingEngineRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DealingEngineRequest::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& DealingEngineRequest::timestamp() const {
  return *timestamp_;
}
inline void DealingEngineRequest::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void DealingEngineRequest::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void DealingEngineRequest::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DealingEngineRequest::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* DealingEngineRequest::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.DealingEngineRequest.RequestType type = 3;
inline bool DealingEngineRequest::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DealingEngineRequest::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DealingEngineRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DealingEngineRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::quantmodel::DealingEngineRequest_RequestType DealingEngineRequest::type() const {
  return static_cast< ::quantmodel::DealingEngineRequest_RequestType >(type_);
}
inline void DealingEngineRequest::set_type(::quantmodel::DealingEngineRequest_RequestType value) {
  GOOGLE_DCHECK(::quantmodel::DealingEngineRequest_RequestType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .quantmodel.DraftOrderMessage draft_order = 4;
inline bool DealingEngineRequest::has_draft_order() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DealingEngineRequest::set_has_draft_order() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DealingEngineRequest::clear_has_draft_order() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DealingEngineRequest::clear_draft_order() {
  if (draft_order_ != NULL) draft_order_->::quantmodel::DraftOrderMessage::Clear();
  clear_has_draft_order();
}
inline const ::quantmodel::DraftOrderMessage& DealingEngineRequest::draft_order() const {
  return draft_order_ != NULL ? *draft_order_ : *default_instance_->draft_order_;
}
inline ::quantmodel::DraftOrderMessage* DealingEngineRequest::mutable_draft_order() {
  set_has_draft_order();
  if (draft_order_ == NULL) draft_order_ = new ::quantmodel::DraftOrderMessage;
  return draft_order_;
}
inline ::quantmodel::DraftOrderMessage* DealingEngineRequest::release_draft_order() {
  clear_has_draft_order();
  ::quantmodel::DraftOrderMessage* temp = draft_order_;
  draft_order_ = NULL;
  return temp;
}

// optional .quantmodel.OrderMessage order = 5;
inline bool DealingEngineRequest::has_order() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DealingEngineRequest::set_has_order() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DealingEngineRequest::clear_has_order() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DealingEngineRequest::clear_order() {
  if (order_ != NULL) order_->::quantmodel::OrderMessage::Clear();
  clear_has_order();
}
inline const ::quantmodel::OrderMessage& DealingEngineRequest::order() const {
  return order_ != NULL ? *order_ : *default_instance_->order_;
}
inline ::quantmodel::OrderMessage* DealingEngineRequest::mutable_order() {
  set_has_order();
  if (order_ == NULL) order_ = new ::quantmodel::OrderMessage;
  return order_;
}
inline ::quantmodel::OrderMessage* DealingEngineRequest::release_order() {
  clear_has_order();
  ::quantmodel::OrderMessage* temp = order_;
  order_ = NULL;
  return temp;
}

// optional .quantmodel.ExecutionReportData execution_report_data = 6;
inline bool DealingEngineRequest::has_execution_report_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DealingEngineRequest::set_has_execution_report_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DealingEngineRequest::clear_has_execution_report_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DealingEngineRequest::clear_execution_report_data() {
  if (execution_report_data_ != NULL) execution_report_data_->::quantmodel::ExecutionReportData::Clear();
  clear_has_execution_report_data();
}
inline const ::quantmodel::ExecutionReportData& DealingEngineRequest::execution_report_data() const {
  return execution_report_data_ != NULL ? *execution_report_data_ : *default_instance_->execution_report_data_;
}
inline ::quantmodel::ExecutionReportData* DealingEngineRequest::mutable_execution_report_data() {
  set_has_execution_report_data();
  if (execution_report_data_ == NULL) execution_report_data_ = new ::quantmodel::ExecutionReportData;
  return execution_report_data_;
}
inline ::quantmodel::ExecutionReportData* DealingEngineRequest::release_execution_report_data() {
  clear_has_execution_report_data();
  ::quantmodel::ExecutionReportData* temp = execution_report_data_;
  execution_report_data_ = NULL;
  return temp;
}

// optional .quantmodel.FixEngineData fix_engine_data = 7;
inline bool DealingEngineRequest::has_fix_engine_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DealingEngineRequest::set_has_fix_engine_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DealingEngineRequest::clear_has_fix_engine_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DealingEngineRequest::clear_fix_engine_data() {
  if (fix_engine_data_ != NULL) fix_engine_data_->::quantmodel::FixEngineData::Clear();
  clear_has_fix_engine_data();
}
inline const ::quantmodel::FixEngineData& DealingEngineRequest::fix_engine_data() const {
  return fix_engine_data_ != NULL ? *fix_engine_data_ : *default_instance_->fix_engine_data_;
}
inline ::quantmodel::FixEngineData* DealingEngineRequest::mutable_fix_engine_data() {
  set_has_fix_engine_data();
  if (fix_engine_data_ == NULL) fix_engine_data_ = new ::quantmodel::FixEngineData;
  return fix_engine_data_;
}
inline ::quantmodel::FixEngineData* DealingEngineRequest::release_fix_engine_data() {
  clear_has_fix_engine_data();
  ::quantmodel::FixEngineData* temp = fix_engine_data_;
  fix_engine_data_ = NULL;
  return temp;
}

// repeated .quantmodel.InstrumentData instrument_data = 8;
inline int DealingEngineRequest::instrument_data_size() const {
  return instrument_data_.size();
}
inline void DealingEngineRequest::clear_instrument_data() {
  instrument_data_.Clear();
}
inline const ::quantmodel::InstrumentData& DealingEngineRequest::instrument_data(int index) const {
  return instrument_data_.Get(index);
}
inline ::quantmodel::InstrumentData* DealingEngineRequest::mutable_instrument_data(int index) {
  return instrument_data_.Mutable(index);
}
inline ::quantmodel::InstrumentData* DealingEngineRequest::add_instrument_data() {
  return instrument_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::InstrumentData >&
DealingEngineRequest::instrument_data() const {
  return instrument_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::InstrumentData >*
DealingEngineRequest::mutable_instrument_data() {
  return &instrument_data_;
}

// repeated .quantmodel.AccountData account_data = 9;
inline int DealingEngineRequest::account_data_size() const {
  return account_data_.size();
}
inline void DealingEngineRequest::clear_account_data() {
  account_data_.Clear();
}
inline const ::quantmodel::AccountData& DealingEngineRequest::account_data(int index) const {
  return account_data_.Get(index);
}
inline ::quantmodel::AccountData* DealingEngineRequest::mutable_account_data(int index) {
  return account_data_.Mutable(index);
}
inline ::quantmodel::AccountData* DealingEngineRequest::add_account_data() {
  return account_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::AccountData >&
DealingEngineRequest::account_data() const {
  return account_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::AccountData >*
DealingEngineRequest::mutable_account_data() {
  return &account_data_;
}

// repeated .quantmodel.InvestmentSystemData investment_system_data = 10;
inline int DealingEngineRequest::investment_system_data_size() const {
  return investment_system_data_.size();
}
inline void DealingEngineRequest::clear_investment_system_data() {
  investment_system_data_.Clear();
}
inline const ::quantmodel::InvestmentSystemData& DealingEngineRequest::investment_system_data(int index) const {
  return investment_system_data_.Get(index);
}
inline ::quantmodel::InvestmentSystemData* DealingEngineRequest::mutable_investment_system_data(int index) {
  return investment_system_data_.Mutable(index);
}
inline ::quantmodel::InvestmentSystemData* DealingEngineRequest::add_investment_system_data() {
  return investment_system_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::InvestmentSystemData >&
DealingEngineRequest::investment_system_data() const {
  return investment_system_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::InvestmentSystemData >*
DealingEngineRequest::mutable_investment_system_data() {
  return &investment_system_data_;
}

// repeated .quantmodel.SignalData signal_data = 11;
inline int DealingEngineRequest::signal_data_size() const {
  return signal_data_.size();
}
inline void DealingEngineRequest::clear_signal_data() {
  signal_data_.Clear();
}
inline const ::quantmodel::SignalData& DealingEngineRequest::signal_data(int index) const {
  return signal_data_.Get(index);
}
inline ::quantmodel::SignalData* DealingEngineRequest::mutable_signal_data(int index) {
  return signal_data_.Mutable(index);
}
inline ::quantmodel::SignalData* DealingEngineRequest::add_signal_data() {
  return signal_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::SignalData >&
DealingEngineRequest::signal_data() const {
  return signal_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::SignalData >*
DealingEngineRequest::mutable_signal_data() {
  return &signal_data_;
}

// optional .quantmodel.SystemParameterData system_parameter_data = 12;
inline bool DealingEngineRequest::has_system_parameter_data() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DealingEngineRequest::set_has_system_parameter_data() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DealingEngineRequest::clear_has_system_parameter_data() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DealingEngineRequest::clear_system_parameter_data() {
  if (system_parameter_data_ != NULL) system_parameter_data_->::quantmodel::SystemParameterData::Clear();
  clear_has_system_parameter_data();
}
inline const ::quantmodel::SystemParameterData& DealingEngineRequest::system_parameter_data() const {
  return system_parameter_data_ != NULL ? *system_parameter_data_ : *default_instance_->system_parameter_data_;
}
inline ::quantmodel::SystemParameterData* DealingEngineRequest::mutable_system_parameter_data() {
  set_has_system_parameter_data();
  if (system_parameter_data_ == NULL) system_parameter_data_ = new ::quantmodel::SystemParameterData;
  return system_parameter_data_;
}
inline ::quantmodel::SystemParameterData* DealingEngineRequest::release_system_parameter_data() {
  clear_has_system_parameter_data();
  ::quantmodel::SystemParameterData* temp = system_parameter_data_;
  system_parameter_data_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// DealingEngineResponse

// optional string response_id = 1;
inline bool DealingEngineResponse::has_response_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DealingEngineResponse::set_has_response_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DealingEngineResponse::clear_has_response_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DealingEngineResponse::clear_response_id() {
  if (response_id_ != &::google::protobuf::internal::kEmptyString) {
    response_id_->clear();
  }
  clear_has_response_id();
}
inline const ::std::string& DealingEngineResponse::response_id() const {
  return *response_id_;
}
inline void DealingEngineResponse::set_response_id(const ::std::string& value) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(value);
}
inline void DealingEngineResponse::set_response_id(const char* value) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(value);
}
inline void DealingEngineResponse::set_response_id(const char* value, size_t size) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DealingEngineResponse::mutable_response_id() {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  return response_id_;
}
inline ::std::string* DealingEngineResponse::release_response_id() {
  clear_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_id_;
    response_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string request_id = 2;
inline bool DealingEngineResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DealingEngineResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DealingEngineResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DealingEngineResponse::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& DealingEngineResponse::request_id() const {
  return *request_id_;
}
inline void DealingEngineResponse::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void DealingEngineResponse::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void DealingEngineResponse::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DealingEngineResponse::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* DealingEngineResponse::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 3;
inline bool DealingEngineResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DealingEngineResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DealingEngineResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DealingEngineResponse::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& DealingEngineResponse::timestamp() const {
  return *timestamp_;
}
inline void DealingEngineResponse::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void DealingEngineResponse::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void DealingEngineResponse::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DealingEngineResponse::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* DealingEngineResponse::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.DealingEngineResponse.ResponseType type = 4;
inline bool DealingEngineResponse::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DealingEngineResponse::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DealingEngineResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DealingEngineResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::quantmodel::DealingEngineResponse_ResponseType DealingEngineResponse::type() const {
  return static_cast< ::quantmodel::DealingEngineResponse_ResponseType >(type_);
}
inline void DealingEngineResponse::set_type(::quantmodel::DealingEngineResponse_ResponseType value) {
  GOOGLE_DCHECK(::quantmodel::DealingEngineResponse_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string error_msg = 5;
inline bool DealingEngineResponse::has_error_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DealingEngineResponse::set_has_error_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DealingEngineResponse::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DealingEngineResponse::clear_error_msg() {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    error_msg_->clear();
  }
  clear_has_error_msg();
}
inline const ::std::string& DealingEngineResponse::error_msg() const {
  return *error_msg_;
}
inline void DealingEngineResponse::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void DealingEngineResponse::set_error_msg(const char* value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void DealingEngineResponse::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DealingEngineResponse::mutable_error_msg() {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  return error_msg_;
}
inline ::std::string* DealingEngineResponse::release_error_msg() {
  clear_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_msg_;
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .quantmodel.DraftOrderMessage draft_order = 6;
inline int DealingEngineResponse::draft_order_size() const {
  return draft_order_.size();
}
inline void DealingEngineResponse::clear_draft_order() {
  draft_order_.Clear();
}
inline const ::quantmodel::DraftOrderMessage& DealingEngineResponse::draft_order(int index) const {
  return draft_order_.Get(index);
}
inline ::quantmodel::DraftOrderMessage* DealingEngineResponse::mutable_draft_order(int index) {
  return draft_order_.Mutable(index);
}
inline ::quantmodel::DraftOrderMessage* DealingEngineResponse::add_draft_order() {
  return draft_order_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::DraftOrderMessage >&
DealingEngineResponse::draft_order() const {
  return draft_order_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::DraftOrderMessage >*
DealingEngineResponse::mutable_draft_order() {
  return &draft_order_;
}

// repeated .quantmodel.OrderMessage order = 7;
inline int DealingEngineResponse::order_size() const {
  return order_.size();
}
inline void DealingEngineResponse::clear_order() {
  order_.Clear();
}
inline const ::quantmodel::OrderMessage& DealingEngineResponse::order(int index) const {
  return order_.Get(index);
}
inline ::quantmodel::OrderMessage* DealingEngineResponse::mutable_order(int index) {
  return order_.Mutable(index);
}
inline ::quantmodel::OrderMessage* DealingEngineResponse::add_order() {
  return order_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::OrderMessage >&
DealingEngineResponse::order() const {
  return order_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::OrderMessage >*
DealingEngineResponse::mutable_order() {
  return &order_;
}

// repeated .quantmodel.PositionOvernightData position = 8;
inline int DealingEngineResponse::position_size() const {
  return position_.size();
}
inline void DealingEngineResponse::clear_position() {
  position_.Clear();
}
inline const ::quantmodel::PositionOvernightData& DealingEngineResponse::position(int index) const {
  return position_.Get(index);
}
inline ::quantmodel::PositionOvernightData* DealingEngineResponse::mutable_position(int index) {
  return position_.Mutable(index);
}
inline ::quantmodel::PositionOvernightData* DealingEngineResponse::add_position() {
  return position_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::PositionOvernightData >&
DealingEngineResponse::position() const {
  return position_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::PositionOvernightData >*
DealingEngineResponse::mutable_position() {
  return &position_;
}

// repeated .quantmodel.SystemParameterData system_parameter = 9;
inline int DealingEngineResponse::system_parameter_size() const {
  return system_parameter_.size();
}
inline void DealingEngineResponse::clear_system_parameter() {
  system_parameter_.Clear();
}
inline const ::quantmodel::SystemParameterData& DealingEngineResponse::system_parameter(int index) const {
  return system_parameter_.Get(index);
}
inline ::quantmodel::SystemParameterData* DealingEngineResponse::mutable_system_parameter(int index) {
  return system_parameter_.Mutable(index);
}
inline ::quantmodel::SystemParameterData* DealingEngineResponse::add_system_parameter() {
  return system_parameter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::SystemParameterData >&
DealingEngineResponse::system_parameter() const {
  return system_parameter_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::SystemParameterData >*
DealingEngineResponse::mutable_system_parameter() {
  return &system_parameter_;
}

// optional .quantmodel.AccountLimitData account_limit = 10;
inline bool DealingEngineResponse::has_account_limit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DealingEngineResponse::set_has_account_limit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DealingEngineResponse::clear_has_account_limit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DealingEngineResponse::clear_account_limit() {
  if (account_limit_ != NULL) account_limit_->::quantmodel::AccountLimitData::Clear();
  clear_has_account_limit();
}
inline const ::quantmodel::AccountLimitData& DealingEngineResponse::account_limit() const {
  return account_limit_ != NULL ? *account_limit_ : *default_instance_->account_limit_;
}
inline ::quantmodel::AccountLimitData* DealingEngineResponse::mutable_account_limit() {
  set_has_account_limit();
  if (account_limit_ == NULL) account_limit_ = new ::quantmodel::AccountLimitData;
  return account_limit_;
}
inline ::quantmodel::AccountLimitData* DealingEngineResponse::release_account_limit() {
  clear_has_account_limit();
  ::quantmodel::AccountLimitData* temp = account_limit_;
  account_limit_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// DealingEngineBroadcast

// optional string broadcast_id = 1;
inline bool DealingEngineBroadcast::has_broadcast_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DealingEngineBroadcast::set_has_broadcast_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DealingEngineBroadcast::clear_has_broadcast_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DealingEngineBroadcast::clear_broadcast_id() {
  if (broadcast_id_ != &::google::protobuf::internal::kEmptyString) {
    broadcast_id_->clear();
  }
  clear_has_broadcast_id();
}
inline const ::std::string& DealingEngineBroadcast::broadcast_id() const {
  return *broadcast_id_;
}
inline void DealingEngineBroadcast::set_broadcast_id(const ::std::string& value) {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  broadcast_id_->assign(value);
}
inline void DealingEngineBroadcast::set_broadcast_id(const char* value) {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  broadcast_id_->assign(value);
}
inline void DealingEngineBroadcast::set_broadcast_id(const char* value, size_t size) {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  broadcast_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DealingEngineBroadcast::mutable_broadcast_id() {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  return broadcast_id_;
}
inline ::std::string* DealingEngineBroadcast::release_broadcast_id() {
  clear_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = broadcast_id_;
    broadcast_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.DealingEngineBroadcast.BroadcastType type = 2;
inline bool DealingEngineBroadcast::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DealingEngineBroadcast::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DealingEngineBroadcast::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DealingEngineBroadcast::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::quantmodel::DealingEngineBroadcast_BroadcastType DealingEngineBroadcast::type() const {
  return static_cast< ::quantmodel::DealingEngineBroadcast_BroadcastType >(type_);
}
inline void DealingEngineBroadcast::set_type(::quantmodel::DealingEngineBroadcast_BroadcastType value) {
  GOOGLE_DCHECK(::quantmodel::DealingEngineBroadcast_BroadcastType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string timestamp = 3;
inline bool DealingEngineBroadcast::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DealingEngineBroadcast::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DealingEngineBroadcast::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DealingEngineBroadcast::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& DealingEngineBroadcast::timestamp() const {
  return *timestamp_;
}
inline void DealingEngineBroadcast::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void DealingEngineBroadcast::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void DealingEngineBroadcast::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DealingEngineBroadcast::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* DealingEngineBroadcast::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .quantmodel.OrderMessage order = 4;
inline int DealingEngineBroadcast::order_size() const {
  return order_.size();
}
inline void DealingEngineBroadcast::clear_order() {
  order_.Clear();
}
inline const ::quantmodel::OrderMessage& DealingEngineBroadcast::order(int index) const {
  return order_.Get(index);
}
inline ::quantmodel::OrderMessage* DealingEngineBroadcast::mutable_order(int index) {
  return order_.Mutable(index);
}
inline ::quantmodel::OrderMessage* DealingEngineBroadcast::add_order() {
  return order_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::OrderMessage >&
DealingEngineBroadcast::order() const {
  return order_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::OrderMessage >*
DealingEngineBroadcast::mutable_order() {
  return &order_;
}

// repeated .quantmodel.FixEngineData fix_engine_data = 5;
inline int DealingEngineBroadcast::fix_engine_data_size() const {
  return fix_engine_data_.size();
}
inline void DealingEngineBroadcast::clear_fix_engine_data() {
  fix_engine_data_.Clear();
}
inline const ::quantmodel::FixEngineData& DealingEngineBroadcast::fix_engine_data(int index) const {
  return fix_engine_data_.Get(index);
}
inline ::quantmodel::FixEngineData* DealingEngineBroadcast::mutable_fix_engine_data(int index) {
  return fix_engine_data_.Mutable(index);
}
inline ::quantmodel::FixEngineData* DealingEngineBroadcast::add_fix_engine_data() {
  return fix_engine_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::FixEngineData >&
DealingEngineBroadcast::fix_engine_data() const {
  return fix_engine_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::FixEngineData >*
DealingEngineBroadcast::mutable_fix_engine_data() {
  return &fix_engine_data_;
}

// repeated .quantmodel.PositionOvernightData position = 6;
inline int DealingEngineBroadcast::position_size() const {
  return position_.size();
}
inline void DealingEngineBroadcast::clear_position() {
  position_.Clear();
}
inline const ::quantmodel::PositionOvernightData& DealingEngineBroadcast::position(int index) const {
  return position_.Get(index);
}
inline ::quantmodel::PositionOvernightData* DealingEngineBroadcast::mutable_position(int index) {
  return position_.Mutable(index);
}
inline ::quantmodel::PositionOvernightData* DealingEngineBroadcast::add_position() {
  return position_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::PositionOvernightData >&
DealingEngineBroadcast::position() const {
  return position_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::PositionOvernightData >*
DealingEngineBroadcast::mutable_position() {
  return &position_;
}

// repeated .quantmodel.SystemParameterData system_parameter = 7;
inline int DealingEngineBroadcast::system_parameter_size() const {
  return system_parameter_.size();
}
inline void DealingEngineBroadcast::clear_system_parameter() {
  system_parameter_.Clear();
}
inline const ::quantmodel::SystemParameterData& DealingEngineBroadcast::system_parameter(int index) const {
  return system_parameter_.Get(index);
}
inline ::quantmodel::SystemParameterData* DealingEngineBroadcast::mutable_system_parameter(int index) {
  return system_parameter_.Mutable(index);
}
inline ::quantmodel::SystemParameterData* DealingEngineBroadcast::add_system_parameter() {
  return system_parameter_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::quantmodel::SystemParameterData >&
DealingEngineBroadcast::system_parameter() const {
  return system_parameter_;
}
inline ::google::protobuf::RepeatedPtrField< ::quantmodel::SystemParameterData >*
DealingEngineBroadcast::mutable_system_parameter() {
  return &system_parameter_;
}

// -------------------------------------------------------------------

// FixEngineRequest

// optional string request_id = 1;
inline bool FixEngineRequest::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FixEngineRequest::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FixEngineRequest::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FixEngineRequest::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& FixEngineRequest::request_id() const {
  return *request_id_;
}
inline void FixEngineRequest::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void FixEngineRequest::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void FixEngineRequest::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixEngineRequest::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* FixEngineRequest::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 2;
inline bool FixEngineRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FixEngineRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FixEngineRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FixEngineRequest::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& FixEngineRequest::timestamp() const {
  return *timestamp_;
}
inline void FixEngineRequest::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void FixEngineRequest::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void FixEngineRequest::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixEngineRequest::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* FixEngineRequest::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.FixEngineRequest.RequestType type = 3;
inline bool FixEngineRequest::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FixEngineRequest::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FixEngineRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FixEngineRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::quantmodel::FixEngineRequest_RequestType FixEngineRequest::type() const {
  return static_cast< ::quantmodel::FixEngineRequest_RequestType >(type_);
}
inline void FixEngineRequest::set_type(::quantmodel::FixEngineRequest_RequestType value) {
  GOOGLE_DCHECK(::quantmodel::FixEngineRequest_RequestType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string session_id = 4;
inline bool FixEngineRequest::has_session_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FixEngineRequest::set_has_session_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FixEngineRequest::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FixEngineRequest::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& FixEngineRequest::session_id() const {
  return *session_id_;
}
inline void FixEngineRequest::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void FixEngineRequest::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void FixEngineRequest::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixEngineRequest::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* FixEngineRequest::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.ReleaseData release_data = 5;
inline bool FixEngineRequest::has_release_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FixEngineRequest::set_has_release_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FixEngineRequest::clear_has_release_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FixEngineRequest::clear_release_data() {
  if (release_data_ != NULL) release_data_->::quantmodel::ReleaseData::Clear();
  clear_has_release_data();
}
inline const ::quantmodel::ReleaseData& FixEngineRequest::release_data() const {
  return release_data_ != NULL ? *release_data_ : *default_instance_->release_data_;
}
inline ::quantmodel::ReleaseData* FixEngineRequest::mutable_release_data() {
  set_has_release_data();
  if (release_data_ == NULL) release_data_ = new ::quantmodel::ReleaseData;
  return release_data_;
}
inline ::quantmodel::ReleaseData* FixEngineRequest::release_release_data() {
  clear_has_release_data();
  ::quantmodel::ReleaseData* temp = release_data_;
  release_data_ = NULL;
  return temp;
}

// optional .quantmodel.InstrumentData instrument_data = 6;
inline bool FixEngineRequest::has_instrument_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FixEngineRequest::set_has_instrument_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FixEngineRequest::clear_has_instrument_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FixEngineRequest::clear_instrument_data() {
  if (instrument_data_ != NULL) instrument_data_->::quantmodel::InstrumentData::Clear();
  clear_has_instrument_data();
}
inline const ::quantmodel::InstrumentData& FixEngineRequest::instrument_data() const {
  return instrument_data_ != NULL ? *instrument_data_ : *default_instance_->instrument_data_;
}
inline ::quantmodel::InstrumentData* FixEngineRequest::mutable_instrument_data() {
  set_has_instrument_data();
  if (instrument_data_ == NULL) instrument_data_ = new ::quantmodel::InstrumentData;
  return instrument_data_;
}
inline ::quantmodel::InstrumentData* FixEngineRequest::release_instrument_data() {
  clear_has_instrument_data();
  ::quantmodel::InstrumentData* temp = instrument_data_;
  instrument_data_ = NULL;
  return temp;
}

// optional .quantmodel.AccountData account_data = 7;
inline bool FixEngineRequest::has_account_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FixEngineRequest::set_has_account_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FixEngineRequest::clear_has_account_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FixEngineRequest::clear_account_data() {
  if (account_data_ != NULL) account_data_->::quantmodel::AccountData::Clear();
  clear_has_account_data();
}
inline const ::quantmodel::AccountData& FixEngineRequest::account_data() const {
  return account_data_ != NULL ? *account_data_ : *default_instance_->account_data_;
}
inline ::quantmodel::AccountData* FixEngineRequest::mutable_account_data() {
  set_has_account_data();
  if (account_data_ == NULL) account_data_ = new ::quantmodel::AccountData;
  return account_data_;
}
inline ::quantmodel::AccountData* FixEngineRequest::release_account_data() {
  clear_has_account_data();
  ::quantmodel::AccountData* temp = account_data_;
  account_data_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// FixEngineResponse

// optional string response_id = 1;
inline bool FixEngineResponse::has_response_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FixEngineResponse::set_has_response_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FixEngineResponse::clear_has_response_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FixEngineResponse::clear_response_id() {
  if (response_id_ != &::google::protobuf::internal::kEmptyString) {
    response_id_->clear();
  }
  clear_has_response_id();
}
inline const ::std::string& FixEngineResponse::response_id() const {
  return *response_id_;
}
inline void FixEngineResponse::set_response_id(const ::std::string& value) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(value);
}
inline void FixEngineResponse::set_response_id(const char* value) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(value);
}
inline void FixEngineResponse::set_response_id(const char* value, size_t size) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixEngineResponse::mutable_response_id() {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  return response_id_;
}
inline ::std::string* FixEngineResponse::release_response_id() {
  clear_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_id_;
    response_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string request_id = 2;
inline bool FixEngineResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FixEngineResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FixEngineResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FixEngineResponse::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& FixEngineResponse::request_id() const {
  return *request_id_;
}
inline void FixEngineResponse::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void FixEngineResponse::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void FixEngineResponse::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixEngineResponse::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* FixEngineResponse::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 3;
inline bool FixEngineResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FixEngineResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FixEngineResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FixEngineResponse::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& FixEngineResponse::timestamp() const {
  return *timestamp_;
}
inline void FixEngineResponse::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void FixEngineResponse::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void FixEngineResponse::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixEngineResponse::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* FixEngineResponse::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.FixEngineResponse.ResponseType type = 4;
inline bool FixEngineResponse::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FixEngineResponse::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FixEngineResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FixEngineResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::quantmodel::FixEngineResponse_ResponseType FixEngineResponse::type() const {
  return static_cast< ::quantmodel::FixEngineResponse_ResponseType >(type_);
}
inline void FixEngineResponse::set_type(::quantmodel::FixEngineResponse_ResponseType value) {
  GOOGLE_DCHECK(::quantmodel::FixEngineResponse_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string error_msg = 5;
inline bool FixEngineResponse::has_error_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FixEngineResponse::set_has_error_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FixEngineResponse::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FixEngineResponse::clear_error_msg() {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    error_msg_->clear();
  }
  clear_has_error_msg();
}
inline const ::std::string& FixEngineResponse::error_msg() const {
  return *error_msg_;
}
inline void FixEngineResponse::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void FixEngineResponse::set_error_msg(const char* value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void FixEngineResponse::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FixEngineResponse::mutable_error_msg() {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  return error_msg_;
}
inline ::std::string* FixEngineResponse::release_error_msg() {
  clear_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_msg_;
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ClientAdapterRequest

// optional string request_id = 1;
inline bool ClientAdapterRequest::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientAdapterRequest::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientAdapterRequest::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientAdapterRequest::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& ClientAdapterRequest::request_id() const {
  return *request_id_;
}
inline void ClientAdapterRequest::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void ClientAdapterRequest::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void ClientAdapterRequest::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientAdapterRequest::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* ClientAdapterRequest::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string session_id = 2;
inline bool ClientAdapterRequest::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientAdapterRequest::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientAdapterRequest::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientAdapterRequest::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& ClientAdapterRequest::session_id() const {
  return *session_id_;
}
inline void ClientAdapterRequest::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void ClientAdapterRequest::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void ClientAdapterRequest::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientAdapterRequest::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* ClientAdapterRequest::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 3;
inline bool ClientAdapterRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientAdapterRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientAdapterRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientAdapterRequest::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& ClientAdapterRequest::timestamp() const {
  return *timestamp_;
}
inline void ClientAdapterRequest::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void ClientAdapterRequest::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void ClientAdapterRequest::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientAdapterRequest::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* ClientAdapterRequest::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.ClientAdapterRequest.RequestType type = 4;
inline bool ClientAdapterRequest::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientAdapterRequest::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientAdapterRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientAdapterRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::quantmodel::ClientAdapterRequest_RequestType ClientAdapterRequest::type() const {
  return static_cast< ::quantmodel::ClientAdapterRequest_RequestType >(type_);
}
inline void ClientAdapterRequest::set_type(::quantmodel::ClientAdapterRequest_RequestType value) {
  GOOGLE_DCHECK(::quantmodel::ClientAdapterRequest_RequestType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .quantmodel.DealingEngineRequest dealing_request = 5;
inline bool ClientAdapterRequest::has_dealing_request() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientAdapterRequest::set_has_dealing_request() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientAdapterRequest::clear_has_dealing_request() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientAdapterRequest::clear_dealing_request() {
  if (dealing_request_ != NULL) dealing_request_->::quantmodel::DealingEngineRequest::Clear();
  clear_has_dealing_request();
}
inline const ::quantmodel::DealingEngineRequest& ClientAdapterRequest::dealing_request() const {
  return dealing_request_ != NULL ? *dealing_request_ : *default_instance_->dealing_request_;
}
inline ::quantmodel::DealingEngineRequest* ClientAdapterRequest::mutable_dealing_request() {
  set_has_dealing_request();
  if (dealing_request_ == NULL) dealing_request_ = new ::quantmodel::DealingEngineRequest;
  return dealing_request_;
}
inline ::quantmodel::DealingEngineRequest* ClientAdapterRequest::release_dealing_request() {
  clear_has_dealing_request();
  ::quantmodel::DealingEngineRequest* temp = dealing_request_;
  dealing_request_ = NULL;
  return temp;
}

// optional .quantmodel.DatabaseEngineRequest database_request = 6;
inline bool ClientAdapterRequest::has_database_request() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientAdapterRequest::set_has_database_request() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientAdapterRequest::clear_has_database_request() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientAdapterRequest::clear_database_request() {
  if (database_request_ != NULL) database_request_->::quantmodel::DatabaseEngineRequest::Clear();
  clear_has_database_request();
}
inline const ::quantmodel::DatabaseEngineRequest& ClientAdapterRequest::database_request() const {
  return database_request_ != NULL ? *database_request_ : *default_instance_->database_request_;
}
inline ::quantmodel::DatabaseEngineRequest* ClientAdapterRequest::mutable_database_request() {
  set_has_database_request();
  if (database_request_ == NULL) database_request_ = new ::quantmodel::DatabaseEngineRequest;
  return database_request_;
}
inline ::quantmodel::DatabaseEngineRequest* ClientAdapterRequest::release_database_request() {
  clear_has_database_request();
  ::quantmodel::DatabaseEngineRequest* temp = database_request_;
  database_request_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ClientAdapterResponse

// optional string response_id = 1;
inline bool ClientAdapterResponse::has_response_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientAdapterResponse::set_has_response_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientAdapterResponse::clear_has_response_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientAdapterResponse::clear_response_id() {
  if (response_id_ != &::google::protobuf::internal::kEmptyString) {
    response_id_->clear();
  }
  clear_has_response_id();
}
inline const ::std::string& ClientAdapterResponse::response_id() const {
  return *response_id_;
}
inline void ClientAdapterResponse::set_response_id(const ::std::string& value) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(value);
}
inline void ClientAdapterResponse::set_response_id(const char* value) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(value);
}
inline void ClientAdapterResponse::set_response_id(const char* value, size_t size) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientAdapterResponse::mutable_response_id() {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  return response_id_;
}
inline ::std::string* ClientAdapterResponse::release_response_id() {
  clear_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_id_;
    response_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string request_id = 2;
inline bool ClientAdapterResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientAdapterResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientAdapterResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientAdapterResponse::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& ClientAdapterResponse::request_id() const {
  return *request_id_;
}
inline void ClientAdapterResponse::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void ClientAdapterResponse::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void ClientAdapterResponse::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientAdapterResponse::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* ClientAdapterResponse::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string session_id = 3;
inline bool ClientAdapterResponse::has_session_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientAdapterResponse::set_has_session_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientAdapterResponse::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientAdapterResponse::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& ClientAdapterResponse::session_id() const {
  return *session_id_;
}
inline void ClientAdapterResponse::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void ClientAdapterResponse::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void ClientAdapterResponse::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientAdapterResponse::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* ClientAdapterResponse::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 4;
inline bool ClientAdapterResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientAdapterResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientAdapterResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientAdapterResponse::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& ClientAdapterResponse::timestamp() const {
  return *timestamp_;
}
inline void ClientAdapterResponse::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void ClientAdapterResponse::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void ClientAdapterResponse::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientAdapterResponse::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* ClientAdapterResponse::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.ClientAdapterResponse.ResponseType type = 5;
inline bool ClientAdapterResponse::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientAdapterResponse::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientAdapterResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientAdapterResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::quantmodel::ClientAdapterResponse_ResponseType ClientAdapterResponse::type() const {
  return static_cast< ::quantmodel::ClientAdapterResponse_ResponseType >(type_);
}
inline void ClientAdapterResponse::set_type(::quantmodel::ClientAdapterResponse_ResponseType value) {
  GOOGLE_DCHECK(::quantmodel::ClientAdapterResponse_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string error_msg = 6;
inline bool ClientAdapterResponse::has_error_msg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientAdapterResponse::set_has_error_msg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientAdapterResponse::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientAdapterResponse::clear_error_msg() {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    error_msg_->clear();
  }
  clear_has_error_msg();
}
inline const ::std::string& ClientAdapterResponse::error_msg() const {
  return *error_msg_;
}
inline void ClientAdapterResponse::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void ClientAdapterResponse::set_error_msg(const char* value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void ClientAdapterResponse::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientAdapterResponse::mutable_error_msg() {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  return error_msg_;
}
inline ::std::string* ClientAdapterResponse::release_error_msg() {
  clear_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_msg_;
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.DealingEngineResponse dealing_response = 7;
inline bool ClientAdapterResponse::has_dealing_response() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientAdapterResponse::set_has_dealing_response() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientAdapterResponse::clear_has_dealing_response() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientAdapterResponse::clear_dealing_response() {
  if (dealing_response_ != NULL) dealing_response_->::quantmodel::DealingEngineResponse::Clear();
  clear_has_dealing_response();
}
inline const ::quantmodel::DealingEngineResponse& ClientAdapterResponse::dealing_response() const {
  return dealing_response_ != NULL ? *dealing_response_ : *default_instance_->dealing_response_;
}
inline ::quantmodel::DealingEngineResponse* ClientAdapterResponse::mutable_dealing_response() {
  set_has_dealing_response();
  if (dealing_response_ == NULL) dealing_response_ = new ::quantmodel::DealingEngineResponse;
  return dealing_response_;
}
inline ::quantmodel::DealingEngineResponse* ClientAdapterResponse::release_dealing_response() {
  clear_has_dealing_response();
  ::quantmodel::DealingEngineResponse* temp = dealing_response_;
  dealing_response_ = NULL;
  return temp;
}

// optional .quantmodel.DatabaseEngineResponse database_response = 8;
inline bool ClientAdapterResponse::has_database_response() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientAdapterResponse::set_has_database_response() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientAdapterResponse::clear_has_database_response() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientAdapterResponse::clear_database_response() {
  if (database_response_ != NULL) database_response_->::quantmodel::DatabaseEngineResponse::Clear();
  clear_has_database_response();
}
inline const ::quantmodel::DatabaseEngineResponse& ClientAdapterResponse::database_response() const {
  return database_response_ != NULL ? *database_response_ : *default_instance_->database_response_;
}
inline ::quantmodel::DatabaseEngineResponse* ClientAdapterResponse::mutable_database_response() {
  set_has_database_response();
  if (database_response_ == NULL) database_response_ = new ::quantmodel::DatabaseEngineResponse;
  return database_response_;
}
inline ::quantmodel::DatabaseEngineResponse* ClientAdapterResponse::release_database_response() {
  clear_has_database_response();
  ::quantmodel::DatabaseEngineResponse* temp = database_response_;
  database_response_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ClientAdapterBroadcast

// optional string broadcast_id = 1;
inline bool ClientAdapterBroadcast::has_broadcast_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientAdapterBroadcast::set_has_broadcast_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientAdapterBroadcast::clear_has_broadcast_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientAdapterBroadcast::clear_broadcast_id() {
  if (broadcast_id_ != &::google::protobuf::internal::kEmptyString) {
    broadcast_id_->clear();
  }
  clear_has_broadcast_id();
}
inline const ::std::string& ClientAdapterBroadcast::broadcast_id() const {
  return *broadcast_id_;
}
inline void ClientAdapterBroadcast::set_broadcast_id(const ::std::string& value) {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  broadcast_id_->assign(value);
}
inline void ClientAdapterBroadcast::set_broadcast_id(const char* value) {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  broadcast_id_->assign(value);
}
inline void ClientAdapterBroadcast::set_broadcast_id(const char* value, size_t size) {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  broadcast_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientAdapterBroadcast::mutable_broadcast_id() {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  return broadcast_id_;
}
inline ::std::string* ClientAdapterBroadcast::release_broadcast_id() {
  clear_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = broadcast_id_;
    broadcast_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 2;
inline bool ClientAdapterBroadcast::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientAdapterBroadcast::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientAdapterBroadcast::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientAdapterBroadcast::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& ClientAdapterBroadcast::timestamp() const {
  return *timestamp_;
}
inline void ClientAdapterBroadcast::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void ClientAdapterBroadcast::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void ClientAdapterBroadcast::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientAdapterBroadcast::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* ClientAdapterBroadcast::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.ClientAdapterBroadcast.BroadcastType type = 3;
inline bool ClientAdapterBroadcast::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientAdapterBroadcast::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientAdapterBroadcast::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientAdapterBroadcast::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::quantmodel::ClientAdapterBroadcast_BroadcastType ClientAdapterBroadcast::type() const {
  return static_cast< ::quantmodel::ClientAdapterBroadcast_BroadcastType >(type_);
}
inline void ClientAdapterBroadcast::set_type(::quantmodel::ClientAdapterBroadcast_BroadcastType value) {
  GOOGLE_DCHECK(::quantmodel::ClientAdapterBroadcast_BroadcastType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .quantmodel.DealingEngineBroadcast dealing_broadcast = 4;
inline bool ClientAdapterBroadcast::has_dealing_broadcast() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientAdapterBroadcast::set_has_dealing_broadcast() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientAdapterBroadcast::clear_has_dealing_broadcast() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientAdapterBroadcast::clear_dealing_broadcast() {
  if (dealing_broadcast_ != NULL) dealing_broadcast_->::quantmodel::DealingEngineBroadcast::Clear();
  clear_has_dealing_broadcast();
}
inline const ::quantmodel::DealingEngineBroadcast& ClientAdapterBroadcast::dealing_broadcast() const {
  return dealing_broadcast_ != NULL ? *dealing_broadcast_ : *default_instance_->dealing_broadcast_;
}
inline ::quantmodel::DealingEngineBroadcast* ClientAdapterBroadcast::mutable_dealing_broadcast() {
  set_has_dealing_broadcast();
  if (dealing_broadcast_ == NULL) dealing_broadcast_ = new ::quantmodel::DealingEngineBroadcast;
  return dealing_broadcast_;
}
inline ::quantmodel::DealingEngineBroadcast* ClientAdapterBroadcast::release_dealing_broadcast() {
  clear_has_dealing_broadcast();
  ::quantmodel::DealingEngineBroadcast* temp = dealing_broadcast_;
  dealing_broadcast_ = NULL;
  return temp;
}

// optional .quantmodel.MarketDataBroadcast marketdata_broadcast = 5;
inline bool ClientAdapterBroadcast::has_marketdata_broadcast() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientAdapterBroadcast::set_has_marketdata_broadcast() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientAdapterBroadcast::clear_has_marketdata_broadcast() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientAdapterBroadcast::clear_marketdata_broadcast() {
  if (marketdata_broadcast_ != NULL) marketdata_broadcast_->::quantmodel::MarketDataBroadcast::Clear();
  clear_has_marketdata_broadcast();
}
inline const ::quantmodel::MarketDataBroadcast& ClientAdapterBroadcast::marketdata_broadcast() const {
  return marketdata_broadcast_ != NULL ? *marketdata_broadcast_ : *default_instance_->marketdata_broadcast_;
}
inline ::quantmodel::MarketDataBroadcast* ClientAdapterBroadcast::mutable_marketdata_broadcast() {
  set_has_marketdata_broadcast();
  if (marketdata_broadcast_ == NULL) marketdata_broadcast_ = new ::quantmodel::MarketDataBroadcast;
  return marketdata_broadcast_;
}
inline ::quantmodel::MarketDataBroadcast* ClientAdapterBroadcast::release_marketdata_broadcast() {
  clear_has_marketdata_broadcast();
  ::quantmodel::MarketDataBroadcast* temp = marketdata_broadcast_;
  marketdata_broadcast_ = NULL;
  return temp;
}

// optional .quantmodel.HeartbeatData heartbeat_data = 6;
inline bool ClientAdapterBroadcast::has_heartbeat_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientAdapterBroadcast::set_has_heartbeat_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientAdapterBroadcast::clear_has_heartbeat_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientAdapterBroadcast::clear_heartbeat_data() {
  if (heartbeat_data_ != NULL) heartbeat_data_->::quantmodel::HeartbeatData::Clear();
  clear_has_heartbeat_data();
}
inline const ::quantmodel::HeartbeatData& ClientAdapterBroadcast::heartbeat_data() const {
  return heartbeat_data_ != NULL ? *heartbeat_data_ : *default_instance_->heartbeat_data_;
}
inline ::quantmodel::HeartbeatData* ClientAdapterBroadcast::mutable_heartbeat_data() {
  set_has_heartbeat_data();
  if (heartbeat_data_ == NULL) heartbeat_data_ = new ::quantmodel::HeartbeatData;
  return heartbeat_data_;
}
inline ::quantmodel::HeartbeatData* ClientAdapterBroadcast::release_heartbeat_data() {
  clear_has_heartbeat_data();
  ::quantmodel::HeartbeatData* temp = heartbeat_data_;
  heartbeat_data_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// InvestmentSystemRequest

// optional string request_id = 1;
inline bool InvestmentSystemRequest::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvestmentSystemRequest::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvestmentSystemRequest::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvestmentSystemRequest::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& InvestmentSystemRequest::request_id() const {
  return *request_id_;
}
inline void InvestmentSystemRequest::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void InvestmentSystemRequest::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void InvestmentSystemRequest::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemRequest::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* InvestmentSystemRequest::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string session_id = 2;
inline bool InvestmentSystemRequest::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvestmentSystemRequest::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvestmentSystemRequest::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvestmentSystemRequest::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& InvestmentSystemRequest::session_id() const {
  return *session_id_;
}
inline void InvestmentSystemRequest::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void InvestmentSystemRequest::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void InvestmentSystemRequest::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemRequest::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* InvestmentSystemRequest::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 3;
inline bool InvestmentSystemRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvestmentSystemRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvestmentSystemRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvestmentSystemRequest::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& InvestmentSystemRequest::timestamp() const {
  return *timestamp_;
}
inline void InvestmentSystemRequest::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void InvestmentSystemRequest::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void InvestmentSystemRequest::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemRequest::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* InvestmentSystemRequest::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.InvestmentSystemRequest.RequestType type = 4;
inline bool InvestmentSystemRequest::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvestmentSystemRequest::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvestmentSystemRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvestmentSystemRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::quantmodel::InvestmentSystemRequest_RequestType InvestmentSystemRequest::type() const {
  return static_cast< ::quantmodel::InvestmentSystemRequest_RequestType >(type_);
}
inline void InvestmentSystemRequest::set_type(::quantmodel::InvestmentSystemRequest_RequestType value) {
  GOOGLE_DCHECK(::quantmodel::InvestmentSystemRequest_RequestType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string delegate = 5;
inline bool InvestmentSystemRequest::has_delegate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InvestmentSystemRequest::set_has_delegate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InvestmentSystemRequest::clear_has_delegate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InvestmentSystemRequest::clear_delegate() {
  if (delegate_ != &::google::protobuf::internal::kEmptyString) {
    delegate_->clear();
  }
  clear_has_delegate();
}
inline const ::std::string& InvestmentSystemRequest::delegate() const {
  return *delegate_;
}
inline void InvestmentSystemRequest::set_delegate(const ::std::string& value) {
  set_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    delegate_ = new ::std::string;
  }
  delegate_->assign(value);
}
inline void InvestmentSystemRequest::set_delegate(const char* value) {
  set_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    delegate_ = new ::std::string;
  }
  delegate_->assign(value);
}
inline void InvestmentSystemRequest::set_delegate(const char* value, size_t size) {
  set_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    delegate_ = new ::std::string;
  }
  delegate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemRequest::mutable_delegate() {
  set_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    delegate_ = new ::std::string;
  }
  return delegate_;
}
inline ::std::string* InvestmentSystemRequest::release_delegate() {
  clear_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = delegate_;
    delegate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// InvestmentSystemResponse

// optional string response_id = 1;
inline bool InvestmentSystemResponse::has_response_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvestmentSystemResponse::set_has_response_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvestmentSystemResponse::clear_has_response_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvestmentSystemResponse::clear_response_id() {
  if (response_id_ != &::google::protobuf::internal::kEmptyString) {
    response_id_->clear();
  }
  clear_has_response_id();
}
inline const ::std::string& InvestmentSystemResponse::response_id() const {
  return *response_id_;
}
inline void InvestmentSystemResponse::set_response_id(const ::std::string& value) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(value);
}
inline void InvestmentSystemResponse::set_response_id(const char* value) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(value);
}
inline void InvestmentSystemResponse::set_response_id(const char* value, size_t size) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemResponse::mutable_response_id() {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  return response_id_;
}
inline ::std::string* InvestmentSystemResponse::release_response_id() {
  clear_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_id_;
    response_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string request_id = 2;
inline bool InvestmentSystemResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvestmentSystemResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvestmentSystemResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvestmentSystemResponse::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& InvestmentSystemResponse::request_id() const {
  return *request_id_;
}
inline void InvestmentSystemResponse::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void InvestmentSystemResponse::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void InvestmentSystemResponse::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemResponse::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* InvestmentSystemResponse::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 3;
inline bool InvestmentSystemResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvestmentSystemResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvestmentSystemResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvestmentSystemResponse::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& InvestmentSystemResponse::timestamp() const {
  return *timestamp_;
}
inline void InvestmentSystemResponse::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void InvestmentSystemResponse::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void InvestmentSystemResponse::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemResponse::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* InvestmentSystemResponse::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.InvestmentSystemResponse.ResponseType type = 4;
inline bool InvestmentSystemResponse::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvestmentSystemResponse::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvestmentSystemResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvestmentSystemResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::quantmodel::InvestmentSystemResponse_ResponseType InvestmentSystemResponse::type() const {
  return static_cast< ::quantmodel::InvestmentSystemResponse_ResponseType >(type_);
}
inline void InvestmentSystemResponse::set_type(::quantmodel::InvestmentSystemResponse_ResponseType value) {
  GOOGLE_DCHECK(::quantmodel::InvestmentSystemResponse_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string error_msg = 5;
inline bool InvestmentSystemResponse::has_error_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InvestmentSystemResponse::set_has_error_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InvestmentSystemResponse::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InvestmentSystemResponse::clear_error_msg() {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    error_msg_->clear();
  }
  clear_has_error_msg();
}
inline const ::std::string& InvestmentSystemResponse::error_msg() const {
  return *error_msg_;
}
inline void InvestmentSystemResponse::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void InvestmentSystemResponse::set_error_msg(const char* value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void InvestmentSystemResponse::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemResponse::mutable_error_msg() {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  return error_msg_;
}
inline ::std::string* InvestmentSystemResponse::release_error_msg() {
  clear_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_msg_;
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string session_id = 6;
inline bool InvestmentSystemResponse::has_session_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InvestmentSystemResponse::set_has_session_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InvestmentSystemResponse::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InvestmentSystemResponse::clear_session_id() {
  if (session_id_ != &::google::protobuf::internal::kEmptyString) {
    session_id_->clear();
  }
  clear_has_session_id();
}
inline const ::std::string& InvestmentSystemResponse::session_id() const {
  return *session_id_;
}
inline void InvestmentSystemResponse::set_session_id(const ::std::string& value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void InvestmentSystemResponse::set_session_id(const char* value) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(value);
}
inline void InvestmentSystemResponse::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemResponse::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    session_id_ = new ::std::string;
  }
  return session_id_;
}
inline ::std::string* InvestmentSystemResponse::release_session_id() {
  clear_has_session_id();
  if (session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_id_;
    session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes delegate = 7;
inline bool InvestmentSystemResponse::has_delegate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InvestmentSystemResponse::set_has_delegate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InvestmentSystemResponse::clear_has_delegate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InvestmentSystemResponse::clear_delegate() {
  if (delegate_ != &::google::protobuf::internal::kEmptyString) {
    delegate_->clear();
  }
  clear_has_delegate();
}
inline const ::std::string& InvestmentSystemResponse::delegate() const {
  return *delegate_;
}
inline void InvestmentSystemResponse::set_delegate(const ::std::string& value) {
  set_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    delegate_ = new ::std::string;
  }
  delegate_->assign(value);
}
inline void InvestmentSystemResponse::set_delegate(const char* value) {
  set_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    delegate_ = new ::std::string;
  }
  delegate_->assign(value);
}
inline void InvestmentSystemResponse::set_delegate(const void* value, size_t size) {
  set_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    delegate_ = new ::std::string;
  }
  delegate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemResponse::mutable_delegate() {
  set_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    delegate_ = new ::std::string;
  }
  return delegate_;
}
inline ::std::string* InvestmentSystemResponse::release_delegate() {
  clear_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = delegate_;
    delegate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// InvestmentSystemBroadcast

// optional string broadcast_id = 1;
inline bool InvestmentSystemBroadcast::has_broadcast_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvestmentSystemBroadcast::set_has_broadcast_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvestmentSystemBroadcast::clear_has_broadcast_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvestmentSystemBroadcast::clear_broadcast_id() {
  if (broadcast_id_ != &::google::protobuf::internal::kEmptyString) {
    broadcast_id_->clear();
  }
  clear_has_broadcast_id();
}
inline const ::std::string& InvestmentSystemBroadcast::broadcast_id() const {
  return *broadcast_id_;
}
inline void InvestmentSystemBroadcast::set_broadcast_id(const ::std::string& value) {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  broadcast_id_->assign(value);
}
inline void InvestmentSystemBroadcast::set_broadcast_id(const char* value) {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  broadcast_id_->assign(value);
}
inline void InvestmentSystemBroadcast::set_broadcast_id(const char* value, size_t size) {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  broadcast_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemBroadcast::mutable_broadcast_id() {
  set_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    broadcast_id_ = new ::std::string;
  }
  return broadcast_id_;
}
inline ::std::string* InvestmentSystemBroadcast::release_broadcast_id() {
  clear_has_broadcast_id();
  if (broadcast_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = broadcast_id_;
    broadcast_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 2;
inline bool InvestmentSystemBroadcast::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvestmentSystemBroadcast::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvestmentSystemBroadcast::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvestmentSystemBroadcast::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& InvestmentSystemBroadcast::timestamp() const {
  return *timestamp_;
}
inline void InvestmentSystemBroadcast::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void InvestmentSystemBroadcast::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void InvestmentSystemBroadcast::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemBroadcast::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* InvestmentSystemBroadcast::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .quantmodel.InvestmentSystemBroadcast.BroadcastType type = 3;
inline bool InvestmentSystemBroadcast::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvestmentSystemBroadcast::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvestmentSystemBroadcast::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvestmentSystemBroadcast::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::quantmodel::InvestmentSystemBroadcast_BroadcastType InvestmentSystemBroadcast::type() const {
  return static_cast< ::quantmodel::InvestmentSystemBroadcast_BroadcastType >(type_);
}
inline void InvestmentSystemBroadcast::set_type(::quantmodel::InvestmentSystemBroadcast_BroadcastType value) {
  GOOGLE_DCHECK(::quantmodel::InvestmentSystemBroadcast_BroadcastType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bytes delegate = 4;
inline bool InvestmentSystemBroadcast::has_delegate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvestmentSystemBroadcast::set_has_delegate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvestmentSystemBroadcast::clear_has_delegate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvestmentSystemBroadcast::clear_delegate() {
  if (delegate_ != &::google::protobuf::internal::kEmptyString) {
    delegate_->clear();
  }
  clear_has_delegate();
}
inline const ::std::string& InvestmentSystemBroadcast::delegate() const {
  return *delegate_;
}
inline void InvestmentSystemBroadcast::set_delegate(const ::std::string& value) {
  set_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    delegate_ = new ::std::string;
  }
  delegate_->assign(value);
}
inline void InvestmentSystemBroadcast::set_delegate(const char* value) {
  set_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    delegate_ = new ::std::string;
  }
  delegate_->assign(value);
}
inline void InvestmentSystemBroadcast::set_delegate(const void* value, size_t size) {
  set_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    delegate_ = new ::std::string;
  }
  delegate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemBroadcast::mutable_delegate() {
  set_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    delegate_ = new ::std::string;
  }
  return delegate_;
}
inline ::std::string* InvestmentSystemBroadcast::release_delegate() {
  clear_has_delegate();
  if (delegate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = delegate_;
    delegate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace quantmodel

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::FixMarketData_EntryType>() {
  return ::quantmodel::FixMarketData_EntryType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::CMEMarketData_EntryType>() {
  return ::quantmodel::CMEMarketData_EntryType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::CMEMarketData_UpdateAction>() {
  return ::quantmodel::CMEMarketData_UpdateAction_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::CMEMarketData_AggressorType>() {
  return ::quantmodel::CMEMarketData_AggressorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::FastEngineBroadcast_BroadcastType>() {
  return ::quantmodel::FastEngineBroadcast_BroadcastType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::MarketDataTradeData_AggressorType>() {
  return ::quantmodel::MarketDataTradeData_AggressorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::MarketDataQuoteData_QuoteType>() {
  return ::quantmodel::MarketDataQuoteData_QuoteType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::MarketDataBroadcast_BroadcastType>() {
  return ::quantmodel::MarketDataBroadcast_BroadcastType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::PositionOvernightData_PositionType>() {
  return ::quantmodel::PositionOvernightData_PositionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::DraftOrderData_SideCode>() {
  return ::quantmodel::DraftOrderData_SideCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::DraftOrderData_OrderType>() {
  return ::quantmodel::DraftOrderData_OrderType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::DraftOrderData_TimeInForce>() {
  return ::quantmodel::DraftOrderData_TimeInForce_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::OrderData_SideCode>() {
  return ::quantmodel::OrderData_SideCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::OrderData_OrderType>() {
  return ::quantmodel::OrderData_OrderType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::OrderData_OrderStatus>() {
  return ::quantmodel::OrderData_OrderStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::OrderData_TimeInForce>() {
  return ::quantmodel::OrderData_TimeInForce_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::DatabaseEngineRequest_QueryType>() {
  return ::quantmodel::DatabaseEngineRequest_QueryType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::DealingEngineRequest_RequestType>() {
  return ::quantmodel::DealingEngineRequest_RequestType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::DealingEngineResponse_ResponseType>() {
  return ::quantmodel::DealingEngineResponse_ResponseType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::DealingEngineBroadcast_BroadcastType>() {
  return ::quantmodel::DealingEngineBroadcast_BroadcastType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::FixEngineRequest_RequestType>() {
  return ::quantmodel::FixEngineRequest_RequestType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::FixEngineResponse_ResponseType>() {
  return ::quantmodel::FixEngineResponse_ResponseType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::ClientAdapterRequest_RequestType>() {
  return ::quantmodel::ClientAdapterRequest_RequestType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::ClientAdapterResponse_ResponseType>() {
  return ::quantmodel::ClientAdapterResponse_ResponseType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::ClientAdapterBroadcast_BroadcastType>() {
  return ::quantmodel::ClientAdapterBroadcast_BroadcastType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::InvestmentSystemRequest_RequestType>() {
  return ::quantmodel::InvestmentSystemRequest_RequestType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::InvestmentSystemResponse_ResponseType>() {
  return ::quantmodel::InvestmentSystemResponse_ResponseType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::quantmodel::InvestmentSystemBroadcast_BroadcastType>() {
  return ::quantmodel::InvestmentSystemBroadcast_BroadcastType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_quantmodel_2eproto__INCLUDED
