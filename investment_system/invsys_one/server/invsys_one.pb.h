// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: invsys_one.proto

#ifndef PROTOBUF_invsys_5fone_2eproto__INCLUDED
#define PROTOBUF_invsys_5fone_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace investment_system {
namespace invsys_one {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_invsys_5fone_2eproto();
void protobuf_AssignDesc_invsys_5fone_2eproto();
void protobuf_ShutdownFile_invsys_5fone_2eproto();

class Timebar;
class Trend;
class Pivot;
class OrderExecution;
class InvestmentSystemOneRequest;
class InvestmentSystemOneResponse;
class InvestmentSystemOneData;

enum Trend_TrendType {
  Trend_TrendType_UP_TREND = 1,
  Trend_TrendType_DOWN_TREND = 2
};
bool Trend_TrendType_IsValid(int value);
const Trend_TrendType Trend_TrendType_TrendType_MIN = Trend_TrendType_UP_TREND;
const Trend_TrendType Trend_TrendType_TrendType_MAX = Trend_TrendType_DOWN_TREND;
const int Trend_TrendType_TrendType_ARRAYSIZE = Trend_TrendType_TrendType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Trend_TrendType_descriptor();
inline const ::std::string& Trend_TrendType_Name(Trend_TrendType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Trend_TrendType_descriptor(), value);
}
inline bool Trend_TrendType_Parse(
    const ::std::string& name, Trend_TrendType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Trend_TrendType>(
    Trend_TrendType_descriptor(), name, value);
}
enum Pivot_PivotType {
  Pivot_PivotType_UP_PIVOT = 1,
  Pivot_PivotType_DOWN_PIVOT = 2
};
bool Pivot_PivotType_IsValid(int value);
const Pivot_PivotType Pivot_PivotType_PivotType_MIN = Pivot_PivotType_UP_PIVOT;
const Pivot_PivotType Pivot_PivotType_PivotType_MAX = Pivot_PivotType_DOWN_PIVOT;
const int Pivot_PivotType_PivotType_ARRAYSIZE = Pivot_PivotType_PivotType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Pivot_PivotType_descriptor();
inline const ::std::string& Pivot_PivotType_Name(Pivot_PivotType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Pivot_PivotType_descriptor(), value);
}
inline bool Pivot_PivotType_Parse(
    const ::std::string& name, Pivot_PivotType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Pivot_PivotType>(
    Pivot_PivotType_descriptor(), name, value);
}
enum OrderExecution_ExecutionType {
  OrderExecution_ExecutionType_BUY = 1,
  OrderExecution_ExecutionType_SELL = 2
};
bool OrderExecution_ExecutionType_IsValid(int value);
const OrderExecution_ExecutionType OrderExecution_ExecutionType_ExecutionType_MIN = OrderExecution_ExecutionType_BUY;
const OrderExecution_ExecutionType OrderExecution_ExecutionType_ExecutionType_MAX = OrderExecution_ExecutionType_SELL;
const int OrderExecution_ExecutionType_ExecutionType_ARRAYSIZE = OrderExecution_ExecutionType_ExecutionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderExecution_ExecutionType_descriptor();
inline const ::std::string& OrderExecution_ExecutionType_Name(OrderExecution_ExecutionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderExecution_ExecutionType_descriptor(), value);
}
inline bool OrderExecution_ExecutionType_Parse(
    const ::std::string& name, OrderExecution_ExecutionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderExecution_ExecutionType>(
    OrderExecution_ExecutionType_descriptor(), name, value);
}
enum InvestmentSystemOneRequest_RequestType {
  InvestmentSystemOneRequest_RequestType_LOGIN = 1,
  InvestmentSystemOneRequest_RequestType_PAUSE = 2,
  InvestmentSystemOneRequest_RequestType_RESUME = 3,
  InvestmentSystemOneRequest_RequestType_FLATTEN = 4,
  InvestmentSystemOneRequest_RequestType_SHUTDOWN = 5
};
bool InvestmentSystemOneRequest_RequestType_IsValid(int value);
const InvestmentSystemOneRequest_RequestType InvestmentSystemOneRequest_RequestType_RequestType_MIN = InvestmentSystemOneRequest_RequestType_LOGIN;
const InvestmentSystemOneRequest_RequestType InvestmentSystemOneRequest_RequestType_RequestType_MAX = InvestmentSystemOneRequest_RequestType_SHUTDOWN;
const int InvestmentSystemOneRequest_RequestType_RequestType_ARRAYSIZE = InvestmentSystemOneRequest_RequestType_RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InvestmentSystemOneRequest_RequestType_descriptor();
inline const ::std::string& InvestmentSystemOneRequest_RequestType_Name(InvestmentSystemOneRequest_RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InvestmentSystemOneRequest_RequestType_descriptor(), value);
}
inline bool InvestmentSystemOneRequest_RequestType_Parse(
    const ::std::string& name, InvestmentSystemOneRequest_RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InvestmentSystemOneRequest_RequestType>(
    InvestmentSystemOneRequest_RequestType_descriptor(), name, value);
}
enum InvestmentSystemOneResponse_ResponseType {
  InvestmentSystemOneResponse_ResponseType_ACKNOWLEDGEMENT = 1,
  InvestmentSystemOneResponse_ResponseType_REJECT = 2,
  InvestmentSystemOneResponse_ResponseType_ERROR = 3
};
bool InvestmentSystemOneResponse_ResponseType_IsValid(int value);
const InvestmentSystemOneResponse_ResponseType InvestmentSystemOneResponse_ResponseType_ResponseType_MIN = InvestmentSystemOneResponse_ResponseType_ACKNOWLEDGEMENT;
const InvestmentSystemOneResponse_ResponseType InvestmentSystemOneResponse_ResponseType_ResponseType_MAX = InvestmentSystemOneResponse_ResponseType_ERROR;
const int InvestmentSystemOneResponse_ResponseType_ResponseType_ARRAYSIZE = InvestmentSystemOneResponse_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InvestmentSystemOneResponse_ResponseType_descriptor();
inline const ::std::string& InvestmentSystemOneResponse_ResponseType_Name(InvestmentSystemOneResponse_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InvestmentSystemOneResponse_ResponseType_descriptor(), value);
}
inline bool InvestmentSystemOneResponse_ResponseType_Parse(
    const ::std::string& name, InvestmentSystemOneResponse_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InvestmentSystemOneResponse_ResponseType>(
    InvestmentSystemOneResponse_ResponseType_descriptor(), name, value);
}
enum InvestmentSystemOneData_DataType {
  InvestmentSystemOneData_DataType_SYSTEM = 1,
  InvestmentSystemOneData_DataType_TIMEBAR = 2,
  InvestmentSystemOneData_DataType_TREND = 3,
  InvestmentSystemOneData_DataType_PIVOT = 4,
  InvestmentSystemOneData_DataType_EXECUTION = 5,
  InvestmentSystemOneData_DataType_LOGIN = 6
};
bool InvestmentSystemOneData_DataType_IsValid(int value);
const InvestmentSystemOneData_DataType InvestmentSystemOneData_DataType_DataType_MIN = InvestmentSystemOneData_DataType_SYSTEM;
const InvestmentSystemOneData_DataType InvestmentSystemOneData_DataType_DataType_MAX = InvestmentSystemOneData_DataType_LOGIN;
const int InvestmentSystemOneData_DataType_DataType_ARRAYSIZE = InvestmentSystemOneData_DataType_DataType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InvestmentSystemOneData_DataType_descriptor();
inline const ::std::string& InvestmentSystemOneData_DataType_Name(InvestmentSystemOneData_DataType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InvestmentSystemOneData_DataType_descriptor(), value);
}
inline bool InvestmentSystemOneData_DataType_Parse(
    const ::std::string& name, InvestmentSystemOneData_DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InvestmentSystemOneData_DataType>(
    InvestmentSystemOneData_DataType_descriptor(), name, value);
}
// ===================================================================

class Timebar : public ::google::protobuf::Message {
 public:
  Timebar();
  virtual ~Timebar();
  
  Timebar(const Timebar& from);
  
  inline Timebar& operator=(const Timebar& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Timebar& default_instance();
  
  void Swap(Timebar* other);
  
  // implements Message ----------------------------------------------
  
  Timebar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Timebar& from);
  void MergeFrom(const Timebar& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);
  
  // optional double open = 2 [default = 0];
  inline bool has_open() const;
  inline void clear_open();
  static const int kOpenFieldNumber = 2;
  inline double open() const;
  inline void set_open(double value);
  
  // optional double high = 3 [default = 0];
  inline bool has_high() const;
  inline void clear_high();
  static const int kHighFieldNumber = 3;
  inline double high() const;
  inline void set_high(double value);
  
  // optional double low = 4 [default = 0];
  inline bool has_low() const;
  inline void clear_low();
  static const int kLowFieldNumber = 4;
  inline double low() const;
  inline void set_low(double value);
  
  // optional double close = 5 [default = 0];
  inline bool has_close() const;
  inline void clear_close();
  static const int kCloseFieldNumber = 5;
  inline double close() const;
  inline void set_close(double value);
  
  // optional uint32 buy_qty = 6 [default = 0];
  inline bool has_buy_qty() const;
  inline void clear_buy_qty();
  static const int kBuyQtyFieldNumber = 6;
  inline ::google::protobuf::uint32 buy_qty() const;
  inline void set_buy_qty(::google::protobuf::uint32 value);
  
  // optional uint32 sell_qty = 7 [default = 0];
  inline bool has_sell_qty() const;
  inline void clear_sell_qty();
  static const int kSellQtyFieldNumber = 7;
  inline ::google::protobuf::uint32 sell_qty() const;
  inline void set_sell_qty(::google::protobuf::uint32 value);
  
  // optional uint32 unkn_qty = 8 [default = 0];
  inline bool has_unkn_qty() const;
  inline void clear_unkn_qty();
  static const int kUnknQtyFieldNumber = 8;
  inline ::google::protobuf::uint32 unkn_qty() const;
  inline void set_unkn_qty(::google::protobuf::uint32 value);
  
  // optional double buy_val = 9 [default = 0];
  inline bool has_buy_val() const;
  inline void clear_buy_val();
  static const int kBuyValFieldNumber = 9;
  inline double buy_val() const;
  inline void set_buy_val(double value);
  
  // optional double sell_val = 10 [default = 0];
  inline bool has_sell_val() const;
  inline void clear_sell_val();
  static const int kSellValFieldNumber = 10;
  inline double sell_val() const;
  inline void set_sell_val(double value);
  
  // optional double unkn_val = 11 [default = 0];
  inline bool has_unkn_val() const;
  inline void clear_unkn_val();
  static const int kUnknValFieldNumber = 11;
  inline double unkn_val() const;
  inline void set_unkn_val(double value);
  
  // @@protoc_insertion_point(class_scope:investment_system.invsys_one.Timebar)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_open();
  inline void clear_has_open();
  inline void set_has_high();
  inline void clear_has_high();
  inline void set_has_low();
  inline void clear_has_low();
  inline void set_has_close();
  inline void clear_has_close();
  inline void set_has_buy_qty();
  inline void clear_has_buy_qty();
  inline void set_has_sell_qty();
  inline void clear_has_sell_qty();
  inline void set_has_unkn_qty();
  inline void clear_has_unkn_qty();
  inline void set_has_buy_val();
  inline void clear_has_buy_val();
  inline void set_has_sell_val();
  inline void clear_has_sell_val();
  inline void set_has_unkn_val();
  inline void clear_has_unkn_val();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double open_;
  double high_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 buy_qty_;
  double low_;
  double close_;
  ::google::protobuf::uint32 sell_qty_;
  ::google::protobuf::uint32 unkn_qty_;
  double buy_val_;
  double sell_val_;
  double unkn_val_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_invsys_5fone_2eproto();
  friend void protobuf_AssignDesc_invsys_5fone_2eproto();
  friend void protobuf_ShutdownFile_invsys_5fone_2eproto();
  
  void InitAsDefaultInstance();
  static Timebar* default_instance_;
};
// -------------------------------------------------------------------

class Trend : public ::google::protobuf::Message {
 public:
  Trend();
  virtual ~Trend();
  
  Trend(const Trend& from);
  
  inline Trend& operator=(const Trend& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Trend& default_instance();
  
  void Swap(Trend* other);
  
  // implements Message ----------------------------------------------
  
  Trend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Trend& from);
  void MergeFrom(const Trend& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Trend_TrendType TrendType;
  static const TrendType UP_TREND = Trend_TrendType_UP_TREND;
  static const TrendType DOWN_TREND = Trend_TrendType_DOWN_TREND;
  static inline bool TrendType_IsValid(int value) {
    return Trend_TrendType_IsValid(value);
  }
  static const TrendType TrendType_MIN =
    Trend_TrendType_TrendType_MIN;
  static const TrendType TrendType_MAX =
    Trend_TrendType_TrendType_MAX;
  static const int TrendType_ARRAYSIZE =
    Trend_TrendType_TrendType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrendType_descriptor() {
    return Trend_TrendType_descriptor();
  }
  static inline const ::std::string& TrendType_Name(TrendType value) {
    return Trend_TrendType_Name(value);
  }
  static inline bool TrendType_Parse(const ::std::string& name,
      TrendType* value) {
    return Trend_TrendType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional uint32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);
  
  // optional .investment_system.invsys_one.Trend.TrendType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::investment_system::invsys_one::Trend_TrendType type() const;
  inline void set_type(::investment_system::invsys_one::Trend_TrendType value);
  
  // optional double high = 3 [default = 0];
  inline bool has_high() const;
  inline void clear_high();
  static const int kHighFieldNumber = 3;
  inline double high() const;
  inline void set_high(double value);
  
  // optional double low = 4 [default = 0];
  inline bool has_low() const;
  inline void clear_low();
  static const int kLowFieldNumber = 4;
  inline double low() const;
  inline void set_low(double value);
  
  // @@protoc_insertion_point(class_scope:investment_system.invsys_one.Trend)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_high();
  inline void clear_has_high();
  inline void set_has_low();
  inline void clear_has_low();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 timestamp_;
  int type_;
  double high_;
  double low_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_invsys_5fone_2eproto();
  friend void protobuf_AssignDesc_invsys_5fone_2eproto();
  friend void protobuf_ShutdownFile_invsys_5fone_2eproto();
  
  void InitAsDefaultInstance();
  static Trend* default_instance_;
};
// -------------------------------------------------------------------

class Pivot : public ::google::protobuf::Message {
 public:
  Pivot();
  virtual ~Pivot();
  
  Pivot(const Pivot& from);
  
  inline Pivot& operator=(const Pivot& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pivot& default_instance();
  
  void Swap(Pivot* other);
  
  // implements Message ----------------------------------------------
  
  Pivot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pivot& from);
  void MergeFrom(const Pivot& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Pivot_PivotType PivotType;
  static const PivotType UP_PIVOT = Pivot_PivotType_UP_PIVOT;
  static const PivotType DOWN_PIVOT = Pivot_PivotType_DOWN_PIVOT;
  static inline bool PivotType_IsValid(int value) {
    return Pivot_PivotType_IsValid(value);
  }
  static const PivotType PivotType_MIN =
    Pivot_PivotType_PivotType_MIN;
  static const PivotType PivotType_MAX =
    Pivot_PivotType_PivotType_MAX;
  static const int PivotType_ARRAYSIZE =
    Pivot_PivotType_PivotType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PivotType_descriptor() {
    return Pivot_PivotType_descriptor();
  }
  static inline const ::std::string& PivotType_Name(PivotType value) {
    return Pivot_PivotType_Name(value);
  }
  static inline bool PivotType_Parse(const ::std::string& name,
      PivotType* value) {
    return Pivot_PivotType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional uint32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);
  
  // optional .investment_system.invsys_one.Pivot.PivotType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::investment_system::invsys_one::Pivot_PivotType type() const;
  inline void set_type(::investment_system::invsys_one::Pivot_PivotType value);
  
  // optional double price = 3 [default = 0];
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline double price() const;
  inline void set_price(double value);
  
  // @@protoc_insertion_point(class_scope:investment_system.invsys_one.Pivot)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_price();
  inline void clear_has_price();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 timestamp_;
  int type_;
  double price_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_invsys_5fone_2eproto();
  friend void protobuf_AssignDesc_invsys_5fone_2eproto();
  friend void protobuf_ShutdownFile_invsys_5fone_2eproto();
  
  void InitAsDefaultInstance();
  static Pivot* default_instance_;
};
// -------------------------------------------------------------------

class OrderExecution : public ::google::protobuf::Message {
 public:
  OrderExecution();
  virtual ~OrderExecution();
  
  OrderExecution(const OrderExecution& from);
  
  inline OrderExecution& operator=(const OrderExecution& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderExecution& default_instance();
  
  void Swap(OrderExecution* other);
  
  // implements Message ----------------------------------------------
  
  OrderExecution* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderExecution& from);
  void MergeFrom(const OrderExecution& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef OrderExecution_ExecutionType ExecutionType;
  static const ExecutionType BUY = OrderExecution_ExecutionType_BUY;
  static const ExecutionType SELL = OrderExecution_ExecutionType_SELL;
  static inline bool ExecutionType_IsValid(int value) {
    return OrderExecution_ExecutionType_IsValid(value);
  }
  static const ExecutionType ExecutionType_MIN =
    OrderExecution_ExecutionType_ExecutionType_MIN;
  static const ExecutionType ExecutionType_MAX =
    OrderExecution_ExecutionType_ExecutionType_MAX;
  static const int ExecutionType_ARRAYSIZE =
    OrderExecution_ExecutionType_ExecutionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExecutionType_descriptor() {
    return OrderExecution_ExecutionType_descriptor();
  }
  static inline const ::std::string& ExecutionType_Name(ExecutionType value) {
    return OrderExecution_ExecutionType_Name(value);
  }
  static inline bool ExecutionType_Parse(const ::std::string& name,
      ExecutionType* value) {
    return OrderExecution_ExecutionType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional uint32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);
  
  // optional uint32 timebar = 2;
  inline bool has_timebar() const;
  inline void clear_timebar();
  static const int kTimebarFieldNumber = 2;
  inline ::google::protobuf::uint32 timebar() const;
  inline void set_timebar(::google::protobuf::uint32 value);
  
  // optional .investment_system.invsys_one.OrderExecution.ExecutionType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::investment_system::invsys_one::OrderExecution_ExecutionType type() const;
  inline void set_type(::investment_system::invsys_one::OrderExecution_ExecutionType value);
  
  // optional double price = 4 [default = 0];
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline double price() const;
  inline void set_price(double value);
  
  // optional uint32 quantity = 5 [default = 0];
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 5;
  inline ::google::protobuf::uint32 quantity() const;
  inline void set_quantity(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:investment_system.invsys_one.OrderExecution)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_timebar();
  inline void clear_has_timebar();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 timebar_;
  double price_;
  int type_;
  ::google::protobuf::uint32 quantity_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_invsys_5fone_2eproto();
  friend void protobuf_AssignDesc_invsys_5fone_2eproto();
  friend void protobuf_ShutdownFile_invsys_5fone_2eproto();
  
  void InitAsDefaultInstance();
  static OrderExecution* default_instance_;
};
// -------------------------------------------------------------------

class InvestmentSystemOneRequest : public ::google::protobuf::Message {
 public:
  InvestmentSystemOneRequest();
  virtual ~InvestmentSystemOneRequest();
  
  InvestmentSystemOneRequest(const InvestmentSystemOneRequest& from);
  
  inline InvestmentSystemOneRequest& operator=(const InvestmentSystemOneRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvestmentSystemOneRequest& default_instance();
  
  void Swap(InvestmentSystemOneRequest* other);
  
  // implements Message ----------------------------------------------
  
  InvestmentSystemOneRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvestmentSystemOneRequest& from);
  void MergeFrom(const InvestmentSystemOneRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef InvestmentSystemOneRequest_RequestType RequestType;
  static const RequestType LOGIN = InvestmentSystemOneRequest_RequestType_LOGIN;
  static const RequestType PAUSE = InvestmentSystemOneRequest_RequestType_PAUSE;
  static const RequestType RESUME = InvestmentSystemOneRequest_RequestType_RESUME;
  static const RequestType FLATTEN = InvestmentSystemOneRequest_RequestType_FLATTEN;
  static const RequestType SHUTDOWN = InvestmentSystemOneRequest_RequestType_SHUTDOWN;
  static inline bool RequestType_IsValid(int value) {
    return InvestmentSystemOneRequest_RequestType_IsValid(value);
  }
  static const RequestType RequestType_MIN =
    InvestmentSystemOneRequest_RequestType_RequestType_MIN;
  static const RequestType RequestType_MAX =
    InvestmentSystemOneRequest_RequestType_RequestType_MAX;
  static const int RequestType_ARRAYSIZE =
    InvestmentSystemOneRequest_RequestType_RequestType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RequestType_descriptor() {
    return InvestmentSystemOneRequest_RequestType_descriptor();
  }
  static inline const ::std::string& RequestType_Name(RequestType value) {
    return InvestmentSystemOneRequest_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(const ::std::string& name,
      RequestType* value) {
    return InvestmentSystemOneRequest_RequestType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  
  // optional string timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // optional .investment_system.invsys_one.InvestmentSystemOneRequest.RequestType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::investment_system::invsys_one::InvestmentSystemOneRequest_RequestType type() const;
  inline void set_type(::investment_system::invsys_one::InvestmentSystemOneRequest_RequestType value);
  
  // @@protoc_insertion_point(class_scope:investment_system.invsys_one.InvestmentSystemOneRequest)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* request_id_;
  ::std::string* timestamp_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_invsys_5fone_2eproto();
  friend void protobuf_AssignDesc_invsys_5fone_2eproto();
  friend void protobuf_ShutdownFile_invsys_5fone_2eproto();
  
  void InitAsDefaultInstance();
  static InvestmentSystemOneRequest* default_instance_;
};
// -------------------------------------------------------------------

class InvestmentSystemOneResponse : public ::google::protobuf::Message {
 public:
  InvestmentSystemOneResponse();
  virtual ~InvestmentSystemOneResponse();
  
  InvestmentSystemOneResponse(const InvestmentSystemOneResponse& from);
  
  inline InvestmentSystemOneResponse& operator=(const InvestmentSystemOneResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvestmentSystemOneResponse& default_instance();
  
  void Swap(InvestmentSystemOneResponse* other);
  
  // implements Message ----------------------------------------------
  
  InvestmentSystemOneResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvestmentSystemOneResponse& from);
  void MergeFrom(const InvestmentSystemOneResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef InvestmentSystemOneResponse_ResponseType ResponseType;
  static const ResponseType ACKNOWLEDGEMENT = InvestmentSystemOneResponse_ResponseType_ACKNOWLEDGEMENT;
  static const ResponseType REJECT = InvestmentSystemOneResponse_ResponseType_REJECT;
  static const ResponseType ERROR = InvestmentSystemOneResponse_ResponseType_ERROR;
  static inline bool ResponseType_IsValid(int value) {
    return InvestmentSystemOneResponse_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    InvestmentSystemOneResponse_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    InvestmentSystemOneResponse_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    InvestmentSystemOneResponse_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return InvestmentSystemOneResponse_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return InvestmentSystemOneResponse_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return InvestmentSystemOneResponse_ResponseType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string response_id = 1;
  inline bool has_response_id() const;
  inline void clear_response_id();
  static const int kResponseIdFieldNumber = 1;
  inline const ::std::string& response_id() const;
  inline void set_response_id(const ::std::string& value);
  inline void set_response_id(const char* value);
  inline void set_response_id(const char* value, size_t size);
  inline ::std::string* mutable_response_id();
  inline ::std::string* release_response_id();
  
  // optional string request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  
  // optional string timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // optional .investment_system.invsys_one.InvestmentSystemOneResponse.ResponseType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::investment_system::invsys_one::InvestmentSystemOneResponse_ResponseType type() const;
  inline void set_type(::investment_system::invsys_one::InvestmentSystemOneResponse_ResponseType value);
  
  // optional string error_msg = 5;
  inline bool has_error_msg() const;
  inline void clear_error_msg();
  static const int kErrorMsgFieldNumber = 5;
  inline const ::std::string& error_msg() const;
  inline void set_error_msg(const ::std::string& value);
  inline void set_error_msg(const char* value);
  inline void set_error_msg(const char* value, size_t size);
  inline ::std::string* mutable_error_msg();
  inline ::std::string* release_error_msg();
  
  // @@protoc_insertion_point(class_scope:investment_system.invsys_one.InvestmentSystemOneResponse)
 private:
  inline void set_has_response_id();
  inline void clear_has_response_id();
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* response_id_;
  ::std::string* request_id_;
  ::std::string* timestamp_;
  ::std::string* error_msg_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_invsys_5fone_2eproto();
  friend void protobuf_AssignDesc_invsys_5fone_2eproto();
  friend void protobuf_ShutdownFile_invsys_5fone_2eproto();
  
  void InitAsDefaultInstance();
  static InvestmentSystemOneResponse* default_instance_;
};
// -------------------------------------------------------------------

class InvestmentSystemOneData : public ::google::protobuf::Message {
 public:
  InvestmentSystemOneData();
  virtual ~InvestmentSystemOneData();
  
  InvestmentSystemOneData(const InvestmentSystemOneData& from);
  
  inline InvestmentSystemOneData& operator=(const InvestmentSystemOneData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InvestmentSystemOneData& default_instance();
  
  void Swap(InvestmentSystemOneData* other);
  
  // implements Message ----------------------------------------------
  
  InvestmentSystemOneData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvestmentSystemOneData& from);
  void MergeFrom(const InvestmentSystemOneData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef InvestmentSystemOneData_DataType DataType;
  static const DataType SYSTEM = InvestmentSystemOneData_DataType_SYSTEM;
  static const DataType TIMEBAR = InvestmentSystemOneData_DataType_TIMEBAR;
  static const DataType TREND = InvestmentSystemOneData_DataType_TREND;
  static const DataType PIVOT = InvestmentSystemOneData_DataType_PIVOT;
  static const DataType EXECUTION = InvestmentSystemOneData_DataType_EXECUTION;
  static const DataType LOGIN = InvestmentSystemOneData_DataType_LOGIN;
  static inline bool DataType_IsValid(int value) {
    return InvestmentSystemOneData_DataType_IsValid(value);
  }
  static const DataType DataType_MIN =
    InvestmentSystemOneData_DataType_DataType_MIN;
  static const DataType DataType_MAX =
    InvestmentSystemOneData_DataType_DataType_MAX;
  static const int DataType_ARRAYSIZE =
    InvestmentSystemOneData_DataType_DataType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DataType_descriptor() {
    return InvestmentSystemOneData_DataType_descriptor();
  }
  static inline const ::std::string& DataType_Name(DataType value) {
    return InvestmentSystemOneData_DataType_Name(value);
  }
  static inline bool DataType_Parse(const ::std::string& name,
      DataType* value) {
    return InvestmentSystemOneData_DataType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .investment_system.invsys_one.InvestmentSystemOneData.DataType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::investment_system::invsys_one::InvestmentSystemOneData_DataType type() const;
  inline void set_type(::investment_system::invsys_one::InvestmentSystemOneData_DataType value);
  
  // optional string opening_tm = 2;
  inline bool has_opening_tm() const;
  inline void clear_opening_tm();
  static const int kOpeningTmFieldNumber = 2;
  inline const ::std::string& opening_tm() const;
  inline void set_opening_tm(const ::std::string& value);
  inline void set_opening_tm(const char* value);
  inline void set_opening_tm(const char* value, size_t size);
  inline ::std::string* mutable_opening_tm();
  inline ::std::string* release_opening_tm();
  
  // optional string closing_tm = 3;
  inline bool has_closing_tm() const;
  inline void clear_closing_tm();
  static const int kClosingTmFieldNumber = 3;
  inline const ::std::string& closing_tm() const;
  inline void set_closing_tm(const ::std::string& value);
  inline void set_closing_tm(const char* value);
  inline void set_closing_tm(const char* value, size_t size);
  inline ::std::string* mutable_closing_tm();
  inline ::std::string* release_closing_tm();
  
  // optional string update_tm = 4;
  inline bool has_update_tm() const;
  inline void clear_update_tm();
  static const int kUpdateTmFieldNumber = 4;
  inline const ::std::string& update_tm() const;
  inline void set_update_tm(const ::std::string& value);
  inline void set_update_tm(const char* value);
  inline void set_update_tm(const char* value, size_t size);
  inline ::std::string* mutable_update_tm();
  inline ::std::string* release_update_tm();
  
  // optional string status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  
  // optional double best_bid = 6;
  inline bool has_best_bid() const;
  inline void clear_best_bid();
  static const int kBestBidFieldNumber = 6;
  inline double best_bid() const;
  inline void set_best_bid(double value);
  
  // optional double best_ask = 7;
  inline bool has_best_ask() const;
  inline void clear_best_ask();
  static const int kBestAskFieldNumber = 7;
  inline double best_ask() const;
  inline void set_best_ask(double value);
  
  // optional double open_pl = 8;
  inline bool has_open_pl() const;
  inline void clear_open_pl();
  static const int kOpenPlFieldNumber = 8;
  inline double open_pl() const;
  inline void set_open_pl(double value);
  
  // optional double closed_pl = 9;
  inline bool has_closed_pl() const;
  inline void clear_closed_pl();
  static const int kClosedPlFieldNumber = 9;
  inline double closed_pl() const;
  inline void set_closed_pl(double value);
  
  // repeated .investment_system.invsys_one.OrderExecution order_execution = 10;
  inline int order_execution_size() const;
  inline void clear_order_execution();
  static const int kOrderExecutionFieldNumber = 10;
  inline const ::investment_system::invsys_one::OrderExecution& order_execution(int index) const;
  inline ::investment_system::invsys_one::OrderExecution* mutable_order_execution(int index);
  inline ::investment_system::invsys_one::OrderExecution* add_order_execution();
  inline const ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::OrderExecution >&
      order_execution() const;
  inline ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::OrderExecution >*
      mutable_order_execution();
  
  // repeated .investment_system.invsys_one.Timebar timebar = 11;
  inline int timebar_size() const;
  inline void clear_timebar();
  static const int kTimebarFieldNumber = 11;
  inline const ::investment_system::invsys_one::Timebar& timebar(int index) const;
  inline ::investment_system::invsys_one::Timebar* mutable_timebar(int index);
  inline ::investment_system::invsys_one::Timebar* add_timebar();
  inline const ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Timebar >&
      timebar() const;
  inline ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Timebar >*
      mutable_timebar();
  
  // repeated .investment_system.invsys_one.Trend trend = 12;
  inline int trend_size() const;
  inline void clear_trend();
  static const int kTrendFieldNumber = 12;
  inline const ::investment_system::invsys_one::Trend& trend(int index) const;
  inline ::investment_system::invsys_one::Trend* mutable_trend(int index);
  inline ::investment_system::invsys_one::Trend* add_trend();
  inline const ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Trend >&
      trend() const;
  inline ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Trend >*
      mutable_trend();
  
  // repeated .investment_system.invsys_one.Pivot pivot = 13;
  inline int pivot_size() const;
  inline void clear_pivot();
  static const int kPivotFieldNumber = 13;
  inline const ::investment_system::invsys_one::Pivot& pivot(int index) const;
  inline ::investment_system::invsys_one::Pivot* mutable_pivot(int index);
  inline ::investment_system::invsys_one::Pivot* add_pivot();
  inline const ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Pivot >&
      pivot() const;
  inline ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Pivot >*
      mutable_pivot();
  
  // @@protoc_insertion_point(class_scope:investment_system.invsys_one.InvestmentSystemOneData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_opening_tm();
  inline void clear_has_opening_tm();
  inline void set_has_closing_tm();
  inline void clear_has_closing_tm();
  inline void set_has_update_tm();
  inline void clear_has_update_tm();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_best_bid();
  inline void clear_has_best_bid();
  inline void set_has_best_ask();
  inline void clear_has_best_ask();
  inline void set_has_open_pl();
  inline void clear_has_open_pl();
  inline void set_has_closed_pl();
  inline void clear_has_closed_pl();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* opening_tm_;
  ::std::string* closing_tm_;
  ::std::string* update_tm_;
  ::std::string* status_;
  double best_bid_;
  double best_ask_;
  double open_pl_;
  double closed_pl_;
  ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::OrderExecution > order_execution_;
  ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Timebar > timebar_;
  ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Trend > trend_;
  ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Pivot > pivot_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_invsys_5fone_2eproto();
  friend void protobuf_AssignDesc_invsys_5fone_2eproto();
  friend void protobuf_ShutdownFile_invsys_5fone_2eproto();
  
  void InitAsDefaultInstance();
  static InvestmentSystemOneData* default_instance_;
};
// ===================================================================


// ===================================================================

// Timebar

// optional uint32 timestamp = 1;
inline bool Timebar::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Timebar::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Timebar::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Timebar::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 Timebar::timestamp() const {
  return timestamp_;
}
inline void Timebar::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional double open = 2 [default = 0];
inline bool Timebar::has_open() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Timebar::set_has_open() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Timebar::clear_has_open() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Timebar::clear_open() {
  open_ = 0;
  clear_has_open();
}
inline double Timebar::open() const {
  return open_;
}
inline void Timebar::set_open(double value) {
  set_has_open();
  open_ = value;
}

// optional double high = 3 [default = 0];
inline bool Timebar::has_high() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Timebar::set_has_high() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Timebar::clear_has_high() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Timebar::clear_high() {
  high_ = 0;
  clear_has_high();
}
inline double Timebar::high() const {
  return high_;
}
inline void Timebar::set_high(double value) {
  set_has_high();
  high_ = value;
}

// optional double low = 4 [default = 0];
inline bool Timebar::has_low() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Timebar::set_has_low() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Timebar::clear_has_low() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Timebar::clear_low() {
  low_ = 0;
  clear_has_low();
}
inline double Timebar::low() const {
  return low_;
}
inline void Timebar::set_low(double value) {
  set_has_low();
  low_ = value;
}

// optional double close = 5 [default = 0];
inline bool Timebar::has_close() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Timebar::set_has_close() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Timebar::clear_has_close() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Timebar::clear_close() {
  close_ = 0;
  clear_has_close();
}
inline double Timebar::close() const {
  return close_;
}
inline void Timebar::set_close(double value) {
  set_has_close();
  close_ = value;
}

// optional uint32 buy_qty = 6 [default = 0];
inline bool Timebar::has_buy_qty() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Timebar::set_has_buy_qty() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Timebar::clear_has_buy_qty() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Timebar::clear_buy_qty() {
  buy_qty_ = 0u;
  clear_has_buy_qty();
}
inline ::google::protobuf::uint32 Timebar::buy_qty() const {
  return buy_qty_;
}
inline void Timebar::set_buy_qty(::google::protobuf::uint32 value) {
  set_has_buy_qty();
  buy_qty_ = value;
}

// optional uint32 sell_qty = 7 [default = 0];
inline bool Timebar::has_sell_qty() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Timebar::set_has_sell_qty() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Timebar::clear_has_sell_qty() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Timebar::clear_sell_qty() {
  sell_qty_ = 0u;
  clear_has_sell_qty();
}
inline ::google::protobuf::uint32 Timebar::sell_qty() const {
  return sell_qty_;
}
inline void Timebar::set_sell_qty(::google::protobuf::uint32 value) {
  set_has_sell_qty();
  sell_qty_ = value;
}

// optional uint32 unkn_qty = 8 [default = 0];
inline bool Timebar::has_unkn_qty() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Timebar::set_has_unkn_qty() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Timebar::clear_has_unkn_qty() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Timebar::clear_unkn_qty() {
  unkn_qty_ = 0u;
  clear_has_unkn_qty();
}
inline ::google::protobuf::uint32 Timebar::unkn_qty() const {
  return unkn_qty_;
}
inline void Timebar::set_unkn_qty(::google::protobuf::uint32 value) {
  set_has_unkn_qty();
  unkn_qty_ = value;
}

// optional double buy_val = 9 [default = 0];
inline bool Timebar::has_buy_val() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Timebar::set_has_buy_val() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Timebar::clear_has_buy_val() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Timebar::clear_buy_val() {
  buy_val_ = 0;
  clear_has_buy_val();
}
inline double Timebar::buy_val() const {
  return buy_val_;
}
inline void Timebar::set_buy_val(double value) {
  set_has_buy_val();
  buy_val_ = value;
}

// optional double sell_val = 10 [default = 0];
inline bool Timebar::has_sell_val() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Timebar::set_has_sell_val() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Timebar::clear_has_sell_val() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Timebar::clear_sell_val() {
  sell_val_ = 0;
  clear_has_sell_val();
}
inline double Timebar::sell_val() const {
  return sell_val_;
}
inline void Timebar::set_sell_val(double value) {
  set_has_sell_val();
  sell_val_ = value;
}

// optional double unkn_val = 11 [default = 0];
inline bool Timebar::has_unkn_val() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Timebar::set_has_unkn_val() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Timebar::clear_has_unkn_val() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Timebar::clear_unkn_val() {
  unkn_val_ = 0;
  clear_has_unkn_val();
}
inline double Timebar::unkn_val() const {
  return unkn_val_;
}
inline void Timebar::set_unkn_val(double value) {
  set_has_unkn_val();
  unkn_val_ = value;
}

// -------------------------------------------------------------------

// Trend

// optional uint32 timestamp = 1;
inline bool Trend::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trend::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trend::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trend::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 Trend::timestamp() const {
  return timestamp_;
}
inline void Trend::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .investment_system.invsys_one.Trend.TrendType type = 2;
inline bool Trend::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Trend::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Trend::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Trend::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::investment_system::invsys_one::Trend_TrendType Trend::type() const {
  return static_cast< ::investment_system::invsys_one::Trend_TrendType >(type_);
}
inline void Trend::set_type(::investment_system::invsys_one::Trend_TrendType value) {
  GOOGLE_DCHECK(::investment_system::invsys_one::Trend_TrendType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional double high = 3 [default = 0];
inline bool Trend::has_high() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Trend::set_has_high() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Trend::clear_has_high() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Trend::clear_high() {
  high_ = 0;
  clear_has_high();
}
inline double Trend::high() const {
  return high_;
}
inline void Trend::set_high(double value) {
  set_has_high();
  high_ = value;
}

// optional double low = 4 [default = 0];
inline bool Trend::has_low() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Trend::set_has_low() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Trend::clear_has_low() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Trend::clear_low() {
  low_ = 0;
  clear_has_low();
}
inline double Trend::low() const {
  return low_;
}
inline void Trend::set_low(double value) {
  set_has_low();
  low_ = value;
}

// -------------------------------------------------------------------

// Pivot

// optional uint32 timestamp = 1;
inline bool Pivot::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pivot::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pivot::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pivot::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 Pivot::timestamp() const {
  return timestamp_;
}
inline void Pivot::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .investment_system.invsys_one.Pivot.PivotType type = 2;
inline bool Pivot::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pivot::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pivot::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pivot::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::investment_system::invsys_one::Pivot_PivotType Pivot::type() const {
  return static_cast< ::investment_system::invsys_one::Pivot_PivotType >(type_);
}
inline void Pivot::set_type(::investment_system::invsys_one::Pivot_PivotType value) {
  GOOGLE_DCHECK(::investment_system::invsys_one::Pivot_PivotType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional double price = 3 [default = 0];
inline bool Pivot::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pivot::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pivot::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pivot::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double Pivot::price() const {
  return price_;
}
inline void Pivot::set_price(double value) {
  set_has_price();
  price_ = value;
}

// -------------------------------------------------------------------

// OrderExecution

// optional uint32 timestamp = 1;
inline bool OrderExecution::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderExecution::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderExecution::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderExecution::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 OrderExecution::timestamp() const {
  return timestamp_;
}
inline void OrderExecution::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional uint32 timebar = 2;
inline bool OrderExecution::has_timebar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderExecution::set_has_timebar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderExecution::clear_has_timebar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderExecution::clear_timebar() {
  timebar_ = 0u;
  clear_has_timebar();
}
inline ::google::protobuf::uint32 OrderExecution::timebar() const {
  return timebar_;
}
inline void OrderExecution::set_timebar(::google::protobuf::uint32 value) {
  set_has_timebar();
  timebar_ = value;
}

// optional .investment_system.invsys_one.OrderExecution.ExecutionType type = 3;
inline bool OrderExecution::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderExecution::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderExecution::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderExecution::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::investment_system::invsys_one::OrderExecution_ExecutionType OrderExecution::type() const {
  return static_cast< ::investment_system::invsys_one::OrderExecution_ExecutionType >(type_);
}
inline void OrderExecution::set_type(::investment_system::invsys_one::OrderExecution_ExecutionType value) {
  GOOGLE_DCHECK(::investment_system::invsys_one::OrderExecution_ExecutionType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional double price = 4 [default = 0];
inline bool OrderExecution::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderExecution::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderExecution::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderExecution::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double OrderExecution::price() const {
  return price_;
}
inline void OrderExecution::set_price(double value) {
  set_has_price();
  price_ = value;
}

// optional uint32 quantity = 5 [default = 0];
inline bool OrderExecution::has_quantity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderExecution::set_has_quantity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderExecution::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderExecution::clear_quantity() {
  quantity_ = 0u;
  clear_has_quantity();
}
inline ::google::protobuf::uint32 OrderExecution::quantity() const {
  return quantity_;
}
inline void OrderExecution::set_quantity(::google::protobuf::uint32 value) {
  set_has_quantity();
  quantity_ = value;
}

// -------------------------------------------------------------------

// InvestmentSystemOneRequest

// optional string request_id = 1;
inline bool InvestmentSystemOneRequest::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvestmentSystemOneRequest::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvestmentSystemOneRequest::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvestmentSystemOneRequest::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& InvestmentSystemOneRequest::request_id() const {
  return *request_id_;
}
inline void InvestmentSystemOneRequest::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void InvestmentSystemOneRequest::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void InvestmentSystemOneRequest::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemOneRequest::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* InvestmentSystemOneRequest::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 2;
inline bool InvestmentSystemOneRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvestmentSystemOneRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvestmentSystemOneRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvestmentSystemOneRequest::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& InvestmentSystemOneRequest::timestamp() const {
  return *timestamp_;
}
inline void InvestmentSystemOneRequest::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void InvestmentSystemOneRequest::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void InvestmentSystemOneRequest::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemOneRequest::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* InvestmentSystemOneRequest::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .investment_system.invsys_one.InvestmentSystemOneRequest.RequestType type = 3;
inline bool InvestmentSystemOneRequest::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvestmentSystemOneRequest::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvestmentSystemOneRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvestmentSystemOneRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::investment_system::invsys_one::InvestmentSystemOneRequest_RequestType InvestmentSystemOneRequest::type() const {
  return static_cast< ::investment_system::invsys_one::InvestmentSystemOneRequest_RequestType >(type_);
}
inline void InvestmentSystemOneRequest::set_type(::investment_system::invsys_one::InvestmentSystemOneRequest_RequestType value) {
  GOOGLE_DCHECK(::investment_system::invsys_one::InvestmentSystemOneRequest_RequestType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// InvestmentSystemOneResponse

// optional string response_id = 1;
inline bool InvestmentSystemOneResponse::has_response_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvestmentSystemOneResponse::set_has_response_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvestmentSystemOneResponse::clear_has_response_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvestmentSystemOneResponse::clear_response_id() {
  if (response_id_ != &::google::protobuf::internal::kEmptyString) {
    response_id_->clear();
  }
  clear_has_response_id();
}
inline const ::std::string& InvestmentSystemOneResponse::response_id() const {
  return *response_id_;
}
inline void InvestmentSystemOneResponse::set_response_id(const ::std::string& value) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(value);
}
inline void InvestmentSystemOneResponse::set_response_id(const char* value) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(value);
}
inline void InvestmentSystemOneResponse::set_response_id(const char* value, size_t size) {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  response_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemOneResponse::mutable_response_id() {
  set_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    response_id_ = new ::std::string;
  }
  return response_id_;
}
inline ::std::string* InvestmentSystemOneResponse::release_response_id() {
  clear_has_response_id();
  if (response_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = response_id_;
    response_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string request_id = 2;
inline bool InvestmentSystemOneResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvestmentSystemOneResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvestmentSystemOneResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvestmentSystemOneResponse::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& InvestmentSystemOneResponse::request_id() const {
  return *request_id_;
}
inline void InvestmentSystemOneResponse::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void InvestmentSystemOneResponse::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void InvestmentSystemOneResponse::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemOneResponse::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* InvestmentSystemOneResponse::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string timestamp = 3;
inline bool InvestmentSystemOneResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvestmentSystemOneResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvestmentSystemOneResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvestmentSystemOneResponse::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& InvestmentSystemOneResponse::timestamp() const {
  return *timestamp_;
}
inline void InvestmentSystemOneResponse::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void InvestmentSystemOneResponse::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void InvestmentSystemOneResponse::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemOneResponse::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* InvestmentSystemOneResponse::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .investment_system.invsys_one.InvestmentSystemOneResponse.ResponseType type = 4;
inline bool InvestmentSystemOneResponse::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvestmentSystemOneResponse::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvestmentSystemOneResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvestmentSystemOneResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::investment_system::invsys_one::InvestmentSystemOneResponse_ResponseType InvestmentSystemOneResponse::type() const {
  return static_cast< ::investment_system::invsys_one::InvestmentSystemOneResponse_ResponseType >(type_);
}
inline void InvestmentSystemOneResponse::set_type(::investment_system::invsys_one::InvestmentSystemOneResponse_ResponseType value) {
  GOOGLE_DCHECK(::investment_system::invsys_one::InvestmentSystemOneResponse_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string error_msg = 5;
inline bool InvestmentSystemOneResponse::has_error_msg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InvestmentSystemOneResponse::set_has_error_msg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InvestmentSystemOneResponse::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InvestmentSystemOneResponse::clear_error_msg() {
  if (error_msg_ != &::google::protobuf::internal::kEmptyString) {
    error_msg_->clear();
  }
  clear_has_error_msg();
}
inline const ::std::string& InvestmentSystemOneResponse::error_msg() const {
  return *error_msg_;
}
inline void InvestmentSystemOneResponse::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void InvestmentSystemOneResponse::set_error_msg(const char* value) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(value);
}
inline void InvestmentSystemOneResponse::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  error_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemOneResponse::mutable_error_msg() {
  set_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    error_msg_ = new ::std::string;
  }
  return error_msg_;
}
inline ::std::string* InvestmentSystemOneResponse::release_error_msg() {
  clear_has_error_msg();
  if (error_msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_msg_;
    error_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// InvestmentSystemOneData

// optional .investment_system.invsys_one.InvestmentSystemOneData.DataType type = 1;
inline bool InvestmentSystemOneData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvestmentSystemOneData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvestmentSystemOneData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvestmentSystemOneData::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::investment_system::invsys_one::InvestmentSystemOneData_DataType InvestmentSystemOneData::type() const {
  return static_cast< ::investment_system::invsys_one::InvestmentSystemOneData_DataType >(type_);
}
inline void InvestmentSystemOneData::set_type(::investment_system::invsys_one::InvestmentSystemOneData_DataType value) {
  GOOGLE_DCHECK(::investment_system::invsys_one::InvestmentSystemOneData_DataType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string opening_tm = 2;
inline bool InvestmentSystemOneData::has_opening_tm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvestmentSystemOneData::set_has_opening_tm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvestmentSystemOneData::clear_has_opening_tm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvestmentSystemOneData::clear_opening_tm() {
  if (opening_tm_ != &::google::protobuf::internal::kEmptyString) {
    opening_tm_->clear();
  }
  clear_has_opening_tm();
}
inline const ::std::string& InvestmentSystemOneData::opening_tm() const {
  return *opening_tm_;
}
inline void InvestmentSystemOneData::set_opening_tm(const ::std::string& value) {
  set_has_opening_tm();
  if (opening_tm_ == &::google::protobuf::internal::kEmptyString) {
    opening_tm_ = new ::std::string;
  }
  opening_tm_->assign(value);
}
inline void InvestmentSystemOneData::set_opening_tm(const char* value) {
  set_has_opening_tm();
  if (opening_tm_ == &::google::protobuf::internal::kEmptyString) {
    opening_tm_ = new ::std::string;
  }
  opening_tm_->assign(value);
}
inline void InvestmentSystemOneData::set_opening_tm(const char* value, size_t size) {
  set_has_opening_tm();
  if (opening_tm_ == &::google::protobuf::internal::kEmptyString) {
    opening_tm_ = new ::std::string;
  }
  opening_tm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemOneData::mutable_opening_tm() {
  set_has_opening_tm();
  if (opening_tm_ == &::google::protobuf::internal::kEmptyString) {
    opening_tm_ = new ::std::string;
  }
  return opening_tm_;
}
inline ::std::string* InvestmentSystemOneData::release_opening_tm() {
  clear_has_opening_tm();
  if (opening_tm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opening_tm_;
    opening_tm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string closing_tm = 3;
inline bool InvestmentSystemOneData::has_closing_tm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvestmentSystemOneData::set_has_closing_tm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvestmentSystemOneData::clear_has_closing_tm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvestmentSystemOneData::clear_closing_tm() {
  if (closing_tm_ != &::google::protobuf::internal::kEmptyString) {
    closing_tm_->clear();
  }
  clear_has_closing_tm();
}
inline const ::std::string& InvestmentSystemOneData::closing_tm() const {
  return *closing_tm_;
}
inline void InvestmentSystemOneData::set_closing_tm(const ::std::string& value) {
  set_has_closing_tm();
  if (closing_tm_ == &::google::protobuf::internal::kEmptyString) {
    closing_tm_ = new ::std::string;
  }
  closing_tm_->assign(value);
}
inline void InvestmentSystemOneData::set_closing_tm(const char* value) {
  set_has_closing_tm();
  if (closing_tm_ == &::google::protobuf::internal::kEmptyString) {
    closing_tm_ = new ::std::string;
  }
  closing_tm_->assign(value);
}
inline void InvestmentSystemOneData::set_closing_tm(const char* value, size_t size) {
  set_has_closing_tm();
  if (closing_tm_ == &::google::protobuf::internal::kEmptyString) {
    closing_tm_ = new ::std::string;
  }
  closing_tm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemOneData::mutable_closing_tm() {
  set_has_closing_tm();
  if (closing_tm_ == &::google::protobuf::internal::kEmptyString) {
    closing_tm_ = new ::std::string;
  }
  return closing_tm_;
}
inline ::std::string* InvestmentSystemOneData::release_closing_tm() {
  clear_has_closing_tm();
  if (closing_tm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = closing_tm_;
    closing_tm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string update_tm = 4;
inline bool InvestmentSystemOneData::has_update_tm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvestmentSystemOneData::set_has_update_tm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvestmentSystemOneData::clear_has_update_tm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvestmentSystemOneData::clear_update_tm() {
  if (update_tm_ != &::google::protobuf::internal::kEmptyString) {
    update_tm_->clear();
  }
  clear_has_update_tm();
}
inline const ::std::string& InvestmentSystemOneData::update_tm() const {
  return *update_tm_;
}
inline void InvestmentSystemOneData::set_update_tm(const ::std::string& value) {
  set_has_update_tm();
  if (update_tm_ == &::google::protobuf::internal::kEmptyString) {
    update_tm_ = new ::std::string;
  }
  update_tm_->assign(value);
}
inline void InvestmentSystemOneData::set_update_tm(const char* value) {
  set_has_update_tm();
  if (update_tm_ == &::google::protobuf::internal::kEmptyString) {
    update_tm_ = new ::std::string;
  }
  update_tm_->assign(value);
}
inline void InvestmentSystemOneData::set_update_tm(const char* value, size_t size) {
  set_has_update_tm();
  if (update_tm_ == &::google::protobuf::internal::kEmptyString) {
    update_tm_ = new ::std::string;
  }
  update_tm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemOneData::mutable_update_tm() {
  set_has_update_tm();
  if (update_tm_ == &::google::protobuf::internal::kEmptyString) {
    update_tm_ = new ::std::string;
  }
  return update_tm_;
}
inline ::std::string* InvestmentSystemOneData::release_update_tm() {
  clear_has_update_tm();
  if (update_tm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = update_tm_;
    update_tm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string status = 5;
inline bool InvestmentSystemOneData::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InvestmentSystemOneData::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InvestmentSystemOneData::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InvestmentSystemOneData::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& InvestmentSystemOneData::status() const {
  return *status_;
}
inline void InvestmentSystemOneData::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void InvestmentSystemOneData::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void InvestmentSystemOneData::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvestmentSystemOneData::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* InvestmentSystemOneData::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double best_bid = 6;
inline bool InvestmentSystemOneData::has_best_bid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InvestmentSystemOneData::set_has_best_bid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InvestmentSystemOneData::clear_has_best_bid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InvestmentSystemOneData::clear_best_bid() {
  best_bid_ = 0;
  clear_has_best_bid();
}
inline double InvestmentSystemOneData::best_bid() const {
  return best_bid_;
}
inline void InvestmentSystemOneData::set_best_bid(double value) {
  set_has_best_bid();
  best_bid_ = value;
}

// optional double best_ask = 7;
inline bool InvestmentSystemOneData::has_best_ask() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InvestmentSystemOneData::set_has_best_ask() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InvestmentSystemOneData::clear_has_best_ask() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InvestmentSystemOneData::clear_best_ask() {
  best_ask_ = 0;
  clear_has_best_ask();
}
inline double InvestmentSystemOneData::best_ask() const {
  return best_ask_;
}
inline void InvestmentSystemOneData::set_best_ask(double value) {
  set_has_best_ask();
  best_ask_ = value;
}

// optional double open_pl = 8;
inline bool InvestmentSystemOneData::has_open_pl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InvestmentSystemOneData::set_has_open_pl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InvestmentSystemOneData::clear_has_open_pl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InvestmentSystemOneData::clear_open_pl() {
  open_pl_ = 0;
  clear_has_open_pl();
}
inline double InvestmentSystemOneData::open_pl() const {
  return open_pl_;
}
inline void InvestmentSystemOneData::set_open_pl(double value) {
  set_has_open_pl();
  open_pl_ = value;
}

// optional double closed_pl = 9;
inline bool InvestmentSystemOneData::has_closed_pl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InvestmentSystemOneData::set_has_closed_pl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InvestmentSystemOneData::clear_has_closed_pl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InvestmentSystemOneData::clear_closed_pl() {
  closed_pl_ = 0;
  clear_has_closed_pl();
}
inline double InvestmentSystemOneData::closed_pl() const {
  return closed_pl_;
}
inline void InvestmentSystemOneData::set_closed_pl(double value) {
  set_has_closed_pl();
  closed_pl_ = value;
}

// repeated .investment_system.invsys_one.OrderExecution order_execution = 10;
inline int InvestmentSystemOneData::order_execution_size() const {
  return order_execution_.size();
}
inline void InvestmentSystemOneData::clear_order_execution() {
  order_execution_.Clear();
}
inline const ::investment_system::invsys_one::OrderExecution& InvestmentSystemOneData::order_execution(int index) const {
  return order_execution_.Get(index);
}
inline ::investment_system::invsys_one::OrderExecution* InvestmentSystemOneData::mutable_order_execution(int index) {
  return order_execution_.Mutable(index);
}
inline ::investment_system::invsys_one::OrderExecution* InvestmentSystemOneData::add_order_execution() {
  return order_execution_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::OrderExecution >&
InvestmentSystemOneData::order_execution() const {
  return order_execution_;
}
inline ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::OrderExecution >*
InvestmentSystemOneData::mutable_order_execution() {
  return &order_execution_;
}

// repeated .investment_system.invsys_one.Timebar timebar = 11;
inline int InvestmentSystemOneData::timebar_size() const {
  return timebar_.size();
}
inline void InvestmentSystemOneData::clear_timebar() {
  timebar_.Clear();
}
inline const ::investment_system::invsys_one::Timebar& InvestmentSystemOneData::timebar(int index) const {
  return timebar_.Get(index);
}
inline ::investment_system::invsys_one::Timebar* InvestmentSystemOneData::mutable_timebar(int index) {
  return timebar_.Mutable(index);
}
inline ::investment_system::invsys_one::Timebar* InvestmentSystemOneData::add_timebar() {
  return timebar_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Timebar >&
InvestmentSystemOneData::timebar() const {
  return timebar_;
}
inline ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Timebar >*
InvestmentSystemOneData::mutable_timebar() {
  return &timebar_;
}

// repeated .investment_system.invsys_one.Trend trend = 12;
inline int InvestmentSystemOneData::trend_size() const {
  return trend_.size();
}
inline void InvestmentSystemOneData::clear_trend() {
  trend_.Clear();
}
inline const ::investment_system::invsys_one::Trend& InvestmentSystemOneData::trend(int index) const {
  return trend_.Get(index);
}
inline ::investment_system::invsys_one::Trend* InvestmentSystemOneData::mutable_trend(int index) {
  return trend_.Mutable(index);
}
inline ::investment_system::invsys_one::Trend* InvestmentSystemOneData::add_trend() {
  return trend_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Trend >&
InvestmentSystemOneData::trend() const {
  return trend_;
}
inline ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Trend >*
InvestmentSystemOneData::mutable_trend() {
  return &trend_;
}

// repeated .investment_system.invsys_one.Pivot pivot = 13;
inline int InvestmentSystemOneData::pivot_size() const {
  return pivot_.size();
}
inline void InvestmentSystemOneData::clear_pivot() {
  pivot_.Clear();
}
inline const ::investment_system::invsys_one::Pivot& InvestmentSystemOneData::pivot(int index) const {
  return pivot_.Get(index);
}
inline ::investment_system::invsys_one::Pivot* InvestmentSystemOneData::mutable_pivot(int index) {
  return pivot_.Mutable(index);
}
inline ::investment_system::invsys_one::Pivot* InvestmentSystemOneData::add_pivot() {
  return pivot_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Pivot >&
InvestmentSystemOneData::pivot() const {
  return pivot_;
}
inline ::google::protobuf::RepeatedPtrField< ::investment_system::invsys_one::Pivot >*
InvestmentSystemOneData::mutable_pivot() {
  return &pivot_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace invsys_one
}  // namespace investment_system

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::investment_system::invsys_one::Trend_TrendType>() {
  return ::investment_system::invsys_one::Trend_TrendType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::investment_system::invsys_one::Pivot_PivotType>() {
  return ::investment_system::invsys_one::Pivot_PivotType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::investment_system::invsys_one::OrderExecution_ExecutionType>() {
  return ::investment_system::invsys_one::OrderExecution_ExecutionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::investment_system::invsys_one::InvestmentSystemOneRequest_RequestType>() {
  return ::investment_system::invsys_one::InvestmentSystemOneRequest_RequestType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::investment_system::invsys_one::InvestmentSystemOneResponse_ResponseType>() {
  return ::investment_system::invsys_one::InvestmentSystemOneResponse_ResponseType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::investment_system::invsys_one::InvestmentSystemOneData_DataType>() {
  return ::investment_system::invsys_one::InvestmentSystemOneData_DataType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_invsys_5fone_2eproto__INCLUDED
